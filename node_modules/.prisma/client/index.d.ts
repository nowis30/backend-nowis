
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Shareholder
 * 
 */
export type Shareholder = $Result.DefaultSelection<Prisma.$ShareholderPayload>
/**
 * Model CompanyShareholder
 * 
 */
export type CompanyShareholder = $Result.DefaultSelection<Prisma.$CompanyShareholderPayload>
/**
 * Model ShareClass
 * 
 */
export type ShareClass = $Result.DefaultSelection<Prisma.$ShareClassPayload>
/**
 * Model ShareTransaction
 * 
 */
export type ShareTransaction = $Result.DefaultSelection<Prisma.$ShareTransactionPayload>
/**
 * Model CorporateStatement
 * 
 */
export type CorporateStatement = $Result.DefaultSelection<Prisma.$CorporateStatementPayload>
/**
 * Model CorporateStatementLine
 * 
 */
export type CorporateStatementLine = $Result.DefaultSelection<Prisma.$CorporateStatementLinePayload>
/**
 * Model CorporateResolution
 * 
 */
export type CorporateResolution = $Result.DefaultSelection<Prisma.$CorporateResolutionPayload>
/**
 * Model PropertyUnit
 * 
 */
export type PropertyUnit = $Result.DefaultSelection<Prisma.$PropertyUnitPayload>
/**
 * Model Mortgage
 * 
 */
export type Mortgage = $Result.DefaultSelection<Prisma.$MortgagePayload>
/**
 * Model Revenue
 * 
 */
export type Revenue = $Result.DefaultSelection<Prisma.$RevenuePayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model DepreciationSetting
 * 
 */
export type DepreciationSetting = $Result.DefaultSelection<Prisma.$DepreciationSettingPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.shareholder`: Exposes CRUD operations for the **Shareholder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shareholders
    * const shareholders = await prisma.shareholder.findMany()
    * ```
    */
  get shareholder(): Prisma.ShareholderDelegate<ExtArgs>;

  /**
   * `prisma.companyShareholder`: Exposes CRUD operations for the **CompanyShareholder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyShareholders
    * const companyShareholders = await prisma.companyShareholder.findMany()
    * ```
    */
  get companyShareholder(): Prisma.CompanyShareholderDelegate<ExtArgs>;

  /**
   * `prisma.shareClass`: Exposes CRUD operations for the **ShareClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareClasses
    * const shareClasses = await prisma.shareClass.findMany()
    * ```
    */
  get shareClass(): Prisma.ShareClassDelegate<ExtArgs>;

  /**
   * `prisma.shareTransaction`: Exposes CRUD operations for the **ShareTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareTransactions
    * const shareTransactions = await prisma.shareTransaction.findMany()
    * ```
    */
  get shareTransaction(): Prisma.ShareTransactionDelegate<ExtArgs>;

  /**
   * `prisma.corporateStatement`: Exposes CRUD operations for the **CorporateStatement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorporateStatements
    * const corporateStatements = await prisma.corporateStatement.findMany()
    * ```
    */
  get corporateStatement(): Prisma.CorporateStatementDelegate<ExtArgs>;

  /**
   * `prisma.corporateStatementLine`: Exposes CRUD operations for the **CorporateStatementLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorporateStatementLines
    * const corporateStatementLines = await prisma.corporateStatementLine.findMany()
    * ```
    */
  get corporateStatementLine(): Prisma.CorporateStatementLineDelegate<ExtArgs>;

  /**
   * `prisma.corporateResolution`: Exposes CRUD operations for the **CorporateResolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CorporateResolutions
    * const corporateResolutions = await prisma.corporateResolution.findMany()
    * ```
    */
  get corporateResolution(): Prisma.CorporateResolutionDelegate<ExtArgs>;

  /**
   * `prisma.propertyUnit`: Exposes CRUD operations for the **PropertyUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyUnits
    * const propertyUnits = await prisma.propertyUnit.findMany()
    * ```
    */
  get propertyUnit(): Prisma.PropertyUnitDelegate<ExtArgs>;

  /**
   * `prisma.mortgage`: Exposes CRUD operations for the **Mortgage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mortgages
    * const mortgages = await prisma.mortgage.findMany()
    * ```
    */
  get mortgage(): Prisma.MortgageDelegate<ExtArgs>;

  /**
   * `prisma.revenue`: Exposes CRUD operations for the **Revenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Revenues
    * const revenues = await prisma.revenue.findMany()
    * ```
    */
  get revenue(): Prisma.RevenueDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.depreciationSetting`: Exposes CRUD operations for the **DepreciationSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepreciationSettings
    * const depreciationSettings = await prisma.depreciationSetting.findMany()
    * ```
    */
  get depreciationSetting(): Prisma.DepreciationSettingDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Property: 'Property',
    Company: 'Company',
    Shareholder: 'Shareholder',
    CompanyShareholder: 'CompanyShareholder',
    ShareClass: 'ShareClass',
    ShareTransaction: 'ShareTransaction',
    CorporateStatement: 'CorporateStatement',
    CorporateStatementLine: 'CorporateStatementLine',
    CorporateResolution: 'CorporateResolution',
    PropertyUnit: 'PropertyUnit',
    Mortgage: 'Mortgage',
    Revenue: 'Revenue',
    Expense: 'Expense',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    DepreciationSetting: 'DepreciationSetting',
    Role: 'Role',
    UserRole: 'UserRole',
    Attachment: 'Attachment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "property" | "company" | "shareholder" | "companyShareholder" | "shareClass" | "shareTransaction" | "corporateStatement" | "corporateStatementLine" | "corporateResolution" | "propertyUnit" | "mortgage" | "revenue" | "expense" | "invoice" | "invoiceItem" | "depreciationSetting" | "role" | "userRole" | "attachment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Shareholder: {
        payload: Prisma.$ShareholderPayload<ExtArgs>
        fields: Prisma.ShareholderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareholderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareholderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          findFirst: {
            args: Prisma.ShareholderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareholderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          findMany: {
            args: Prisma.ShareholderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>[]
          }
          create: {
            args: Prisma.ShareholderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          createMany: {
            args: Prisma.ShareholderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareholderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>[]
          }
          delete: {
            args: Prisma.ShareholderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          update: {
            args: Prisma.ShareholderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          deleteMany: {
            args: Prisma.ShareholderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareholderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareholderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareholderPayload>
          }
          aggregate: {
            args: Prisma.ShareholderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareholder>
          }
          groupBy: {
            args: Prisma.ShareholderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareholderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareholderCountArgs<ExtArgs>
            result: $Utils.Optional<ShareholderCountAggregateOutputType> | number
          }
        }
      }
      CompanyShareholder: {
        payload: Prisma.$CompanyShareholderPayload<ExtArgs>
        fields: Prisma.CompanyShareholderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyShareholderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyShareholderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
          }
          findFirst: {
            args: Prisma.CompanyShareholderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyShareholderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
          }
          findMany: {
            args: Prisma.CompanyShareholderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>[]
          }
          create: {
            args: Prisma.CompanyShareholderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
          }
          createMany: {
            args: Prisma.CompanyShareholderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyShareholderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>[]
          }
          delete: {
            args: Prisma.CompanyShareholderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
          }
          update: {
            args: Prisma.CompanyShareholderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
          }
          deleteMany: {
            args: Prisma.CompanyShareholderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyShareholderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyShareholderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyShareholderPayload>
          }
          aggregate: {
            args: Prisma.CompanyShareholderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyShareholder>
          }
          groupBy: {
            args: Prisma.CompanyShareholderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyShareholderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyShareholderCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyShareholderCountAggregateOutputType> | number
          }
        }
      }
      ShareClass: {
        payload: Prisma.$ShareClassPayload<ExtArgs>
        fields: Prisma.ShareClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>
          }
          findFirst: {
            args: Prisma.ShareClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>
          }
          findMany: {
            args: Prisma.ShareClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>[]
          }
          create: {
            args: Prisma.ShareClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>
          }
          createMany: {
            args: Prisma.ShareClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>[]
          }
          delete: {
            args: Prisma.ShareClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>
          }
          update: {
            args: Prisma.ShareClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>
          }
          deleteMany: {
            args: Prisma.ShareClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareClassPayload>
          }
          aggregate: {
            args: Prisma.ShareClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareClass>
          }
          groupBy: {
            args: Prisma.ShareClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareClassCountArgs<ExtArgs>
            result: $Utils.Optional<ShareClassCountAggregateOutputType> | number
          }
        }
      }
      ShareTransaction: {
        payload: Prisma.$ShareTransactionPayload<ExtArgs>
        fields: Prisma.ShareTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>
          }
          findFirst: {
            args: Prisma.ShareTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>
          }
          findMany: {
            args: Prisma.ShareTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>[]
          }
          create: {
            args: Prisma.ShareTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>
          }
          createMany: {
            args: Prisma.ShareTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>[]
          }
          delete: {
            args: Prisma.ShareTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>
          }
          update: {
            args: Prisma.ShareTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>
          }
          deleteMany: {
            args: Prisma.ShareTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShareTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareTransactionPayload>
          }
          aggregate: {
            args: Prisma.ShareTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareTransaction>
          }
          groupBy: {
            args: Prisma.ShareTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<ShareTransactionCountAggregateOutputType> | number
          }
        }
      }
      CorporateStatement: {
        payload: Prisma.$CorporateStatementPayload<ExtArgs>
        fields: Prisma.CorporateStatementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorporateStatementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorporateStatementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>
          }
          findFirst: {
            args: Prisma.CorporateStatementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorporateStatementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>
          }
          findMany: {
            args: Prisma.CorporateStatementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>[]
          }
          create: {
            args: Prisma.CorporateStatementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>
          }
          createMany: {
            args: Prisma.CorporateStatementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorporateStatementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>[]
          }
          delete: {
            args: Prisma.CorporateStatementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>
          }
          update: {
            args: Prisma.CorporateStatementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>
          }
          deleteMany: {
            args: Prisma.CorporateStatementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorporateStatementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CorporateStatementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementPayload>
          }
          aggregate: {
            args: Prisma.CorporateStatementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorporateStatement>
          }
          groupBy: {
            args: Prisma.CorporateStatementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorporateStatementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorporateStatementCountArgs<ExtArgs>
            result: $Utils.Optional<CorporateStatementCountAggregateOutputType> | number
          }
        }
      }
      CorporateStatementLine: {
        payload: Prisma.$CorporateStatementLinePayload<ExtArgs>
        fields: Prisma.CorporateStatementLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorporateStatementLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorporateStatementLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>
          }
          findFirst: {
            args: Prisma.CorporateStatementLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorporateStatementLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>
          }
          findMany: {
            args: Prisma.CorporateStatementLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>[]
          }
          create: {
            args: Prisma.CorporateStatementLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>
          }
          createMany: {
            args: Prisma.CorporateStatementLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorporateStatementLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>[]
          }
          delete: {
            args: Prisma.CorporateStatementLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>
          }
          update: {
            args: Prisma.CorporateStatementLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>
          }
          deleteMany: {
            args: Prisma.CorporateStatementLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorporateStatementLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CorporateStatementLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateStatementLinePayload>
          }
          aggregate: {
            args: Prisma.CorporateStatementLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorporateStatementLine>
          }
          groupBy: {
            args: Prisma.CorporateStatementLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorporateStatementLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorporateStatementLineCountArgs<ExtArgs>
            result: $Utils.Optional<CorporateStatementLineCountAggregateOutputType> | number
          }
        }
      }
      CorporateResolution: {
        payload: Prisma.$CorporateResolutionPayload<ExtArgs>
        fields: Prisma.CorporateResolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorporateResolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorporateResolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>
          }
          findFirst: {
            args: Prisma.CorporateResolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorporateResolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>
          }
          findMany: {
            args: Prisma.CorporateResolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>[]
          }
          create: {
            args: Prisma.CorporateResolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>
          }
          createMany: {
            args: Prisma.CorporateResolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorporateResolutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>[]
          }
          delete: {
            args: Prisma.CorporateResolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>
          }
          update: {
            args: Prisma.CorporateResolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>
          }
          deleteMany: {
            args: Prisma.CorporateResolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorporateResolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CorporateResolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorporateResolutionPayload>
          }
          aggregate: {
            args: Prisma.CorporateResolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorporateResolution>
          }
          groupBy: {
            args: Prisma.CorporateResolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorporateResolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorporateResolutionCountArgs<ExtArgs>
            result: $Utils.Optional<CorporateResolutionCountAggregateOutputType> | number
          }
        }
      }
      PropertyUnit: {
        payload: Prisma.$PropertyUnitPayload<ExtArgs>
        fields: Prisma.PropertyUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
          }
          findFirst: {
            args: Prisma.PropertyUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
          }
          findMany: {
            args: Prisma.PropertyUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>[]
          }
          create: {
            args: Prisma.PropertyUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
          }
          createMany: {
            args: Prisma.PropertyUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>[]
          }
          delete: {
            args: Prisma.PropertyUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
          }
          update: {
            args: Prisma.PropertyUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
          }
          deleteMany: {
            args: Prisma.PropertyUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
          }
          aggregate: {
            args: Prisma.PropertyUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyUnit>
          }
          groupBy: {
            args: Prisma.PropertyUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyUnitCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyUnitCountAggregateOutputType> | number
          }
        }
      }
      Mortgage: {
        payload: Prisma.$MortgagePayload<ExtArgs>
        fields: Prisma.MortgageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MortgageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MortgageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>
          }
          findFirst: {
            args: Prisma.MortgageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MortgageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>
          }
          findMany: {
            args: Prisma.MortgageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>[]
          }
          create: {
            args: Prisma.MortgageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>
          }
          createMany: {
            args: Prisma.MortgageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MortgageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>[]
          }
          delete: {
            args: Prisma.MortgageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>
          }
          update: {
            args: Prisma.MortgageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>
          }
          deleteMany: {
            args: Prisma.MortgageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MortgageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MortgageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortgagePayload>
          }
          aggregate: {
            args: Prisma.MortgageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMortgage>
          }
          groupBy: {
            args: Prisma.MortgageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MortgageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MortgageCountArgs<ExtArgs>
            result: $Utils.Optional<MortgageCountAggregateOutputType> | number
          }
        }
      }
      Revenue: {
        payload: Prisma.$RevenuePayload<ExtArgs>
        fields: Prisma.RevenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          findFirst: {
            args: Prisma.RevenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          findMany: {
            args: Prisma.RevenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>[]
          }
          create: {
            args: Prisma.RevenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          createMany: {
            args: Prisma.RevenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>[]
          }
          delete: {
            args: Prisma.RevenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          update: {
            args: Prisma.RevenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          deleteMany: {
            args: Prisma.RevenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          aggregate: {
            args: Prisma.RevenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenue>
          }
          groupBy: {
            args: Prisma.RevenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      DepreciationSetting: {
        payload: Prisma.$DepreciationSettingPayload<ExtArgs>
        fields: Prisma.DepreciationSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepreciationSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepreciationSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>
          }
          findFirst: {
            args: Prisma.DepreciationSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepreciationSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>
          }
          findMany: {
            args: Prisma.DepreciationSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>[]
          }
          create: {
            args: Prisma.DepreciationSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>
          }
          createMany: {
            args: Prisma.DepreciationSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepreciationSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>[]
          }
          delete: {
            args: Prisma.DepreciationSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>
          }
          update: {
            args: Prisma.DepreciationSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>
          }
          deleteMany: {
            args: Prisma.DepreciationSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepreciationSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepreciationSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationSettingPayload>
          }
          aggregate: {
            args: Prisma.DepreciationSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepreciationSetting>
          }
          groupBy: {
            args: Prisma.DepreciationSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepreciationSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepreciationSettingCountArgs<ExtArgs>
            result: $Utils.Optional<DepreciationSettingCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    properties: number
    companies: number
    shareholders: number
    roles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | UserCountOutputTypeCountPropertiesArgs
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    shareholders?: boolean | UserCountOutputTypeCountShareholdersArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShareholdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    units: number
    mortgages: number
    revenues: number
    expenses: number
    invoices: number
    attachments: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | PropertyCountOutputTypeCountUnitsArgs
    mortgages?: boolean | PropertyCountOutputTypeCountMortgagesArgs
    revenues?: boolean | PropertyCountOutputTypeCountRevenuesArgs
    expenses?: boolean | PropertyCountOutputTypeCountExpensesArgs
    invoices?: boolean | PropertyCountOutputTypeCountInvoicesArgs
    attachments?: boolean | PropertyCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyUnitWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountMortgagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MortgageWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountRevenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    properties: number
    shareholderLinks: number
    shareClasses: number
    shareTransactions: number
    statements: number
    resolutions: number
    userRoles: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | CompanyCountOutputTypeCountPropertiesArgs
    shareholderLinks?: boolean | CompanyCountOutputTypeCountShareholderLinksArgs
    shareClasses?: boolean | CompanyCountOutputTypeCountShareClassesArgs
    shareTransactions?: boolean | CompanyCountOutputTypeCountShareTransactionsArgs
    statements?: boolean | CompanyCountOutputTypeCountStatementsArgs
    resolutions?: boolean | CompanyCountOutputTypeCountResolutionsArgs
    userRoles?: boolean | CompanyCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountShareholderLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyShareholderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountShareClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareClassWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountShareTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransactionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStatementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateStatementWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountResolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateResolutionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type ShareholderCountOutputType
   */

  export type ShareholderCountOutputType = {
    companies: number
    shareTransactions: number
  }

  export type ShareholderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | ShareholderCountOutputTypeCountCompaniesArgs
    shareTransactions?: boolean | ShareholderCountOutputTypeCountShareTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ShareholderCountOutputType without action
   */
  export type ShareholderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareholderCountOutputType
     */
    select?: ShareholderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShareholderCountOutputType without action
   */
  export type ShareholderCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyShareholderWhereInput
  }

  /**
   * ShareholderCountOutputType without action
   */
  export type ShareholderCountOutputTypeCountShareTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransactionWhereInput
  }


  /**
   * Count Type ShareClassCountOutputType
   */

  export type ShareClassCountOutputType = {
    transactions: number
  }

  export type ShareClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ShareClassCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ShareClassCountOutputType without action
   */
  export type ShareClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClassCountOutputType
     */
    select?: ShareClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShareClassCountOutputType without action
   */
  export type ShareClassCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransactionWhereInput
  }


  /**
   * Count Type CorporateStatementCountOutputType
   */

  export type CorporateStatementCountOutputType = {
    lines: number
  }

  export type CorporateStatementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | CorporateStatementCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * CorporateStatementCountOutputType without action
   */
  export type CorporateStatementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementCountOutputType
     */
    select?: CorporateStatementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CorporateStatementCountOutputType without action
   */
  export type CorporateStatementCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateStatementLineWhereInput
  }


  /**
   * Count Type MortgageCountOutputType
   */

  export type MortgageCountOutputType = {
    attachments: number
  }

  export type MortgageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MortgageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MortgageCountOutputType without action
   */
  export type MortgageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortgageCountOutputType
     */
    select?: MortgageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MortgageCountOutputType without action
   */
  export type MortgageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    properties?: boolean | User$propertiesArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    shareholders?: boolean | User$shareholdersArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | User$propertiesArgs<ExtArgs>
    companies?: boolean | User$companiesArgs<ExtArgs>
    shareholders?: boolean | User$shareholdersArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      companies: Prisma.$CompanyPayload<ExtArgs>[]
      shareholders: Prisma.$ShareholderPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends User$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, User$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany"> | Null>
    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany"> | Null>
    shareholders<T extends User$shareholdersArgs<ExtArgs> = {}>(args?: Subset<T, User$shareholdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.properties
   */
  export type User$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * User.shareholders
   */
  export type User$shareholdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    where?: ShareholderWhereInput
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    cursor?: ShareholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    purchasePrice: Decimal | null
    currentValue: Decimal | null
  }

  export type PropertySumAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    purchasePrice: Decimal | null
    currentValue: Decimal | null
  }

  export type PropertyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    name: string | null
    address: string | null
    acquisitionDate: Date | null
    purchasePrice: Decimal | null
    currentValue: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    name: string | null
    address: string | null
    acquisitionDate: Date | null
    purchasePrice: Decimal | null
    currentValue: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    name: number
    address: number
    acquisitionDate: number
    purchasePrice: number
    currentValue: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    purchasePrice?: true
    currentValue?: true
  }

  export type PropertySumAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    purchasePrice?: true
    currentValue?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    name?: true
    address?: true
    acquisitionDate?: true
    purchasePrice?: true
    currentValue?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    name?: true
    address?: true
    acquisitionDate?: true
    purchasePrice?: true
    currentValue?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    name?: true
    address?: true
    acquisitionDate?: true
    purchasePrice?: true
    currentValue?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: number
    userId: number
    companyId: number | null
    name: string
    address: string | null
    acquisitionDate: Date | null
    purchasePrice: Decimal | null
    currentValue: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    acquisitionDate?: boolean
    purchasePrice?: boolean
    currentValue?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Property$companyArgs<ExtArgs>
    units?: boolean | Property$unitsArgs<ExtArgs>
    mortgages?: boolean | Property$mortgagesArgs<ExtArgs>
    revenues?: boolean | Property$revenuesArgs<ExtArgs>
    expenses?: boolean | Property$expensesArgs<ExtArgs>
    invoices?: boolean | Property$invoicesArgs<ExtArgs>
    depreciationInfo?: boolean | Property$depreciationInfoArgs<ExtArgs>
    attachments?: boolean | Property$attachmentsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    acquisitionDate?: boolean
    purchasePrice?: boolean
    currentValue?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Property$companyArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    name?: boolean
    address?: boolean
    acquisitionDate?: boolean
    purchasePrice?: boolean
    currentValue?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Property$companyArgs<ExtArgs>
    units?: boolean | Property$unitsArgs<ExtArgs>
    mortgages?: boolean | Property$mortgagesArgs<ExtArgs>
    revenues?: boolean | Property$revenuesArgs<ExtArgs>
    expenses?: boolean | Property$expensesArgs<ExtArgs>
    invoices?: boolean | Property$invoicesArgs<ExtArgs>
    depreciationInfo?: boolean | Property$depreciationInfoArgs<ExtArgs>
    attachments?: boolean | Property$attachmentsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | Property$companyArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
      units: Prisma.$PropertyUnitPayload<ExtArgs>[]
      mortgages: Prisma.$MortgagePayload<ExtArgs>[]
      revenues: Prisma.$RevenuePayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      depreciationInfo: Prisma.$DepreciationSettingPayload<ExtArgs> | null
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      companyId: number | null
      name: string
      address: string | null
      acquisitionDate: Date | null
      purchasePrice: Prisma.Decimal | null
      currentValue: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends Property$companyArgs<ExtArgs> = {}>(args?: Subset<T, Property$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    units<T extends Property$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Property$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "findMany"> | Null>
    mortgages<T extends Property$mortgagesArgs<ExtArgs> = {}>(args?: Subset<T, Property$mortgagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findMany"> | Null>
    revenues<T extends Property$revenuesArgs<ExtArgs> = {}>(args?: Subset<T, Property$revenuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Property$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Property$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Property$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Property$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    depreciationInfo<T extends Property$depreciationInfoArgs<ExtArgs> = {}>(args?: Subset<T, Property$depreciationInfoArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attachments<T extends Property$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Property$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */ 
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'Int'>
    readonly userId: FieldRef<"Property", 'Int'>
    readonly companyId: FieldRef<"Property", 'Int'>
    readonly name: FieldRef<"Property", 'String'>
    readonly address: FieldRef<"Property", 'String'>
    readonly acquisitionDate: FieldRef<"Property", 'DateTime'>
    readonly purchasePrice: FieldRef<"Property", 'Decimal'>
    readonly currentValue: FieldRef<"Property", 'Decimal'>
    readonly notes: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
  }

  /**
   * Property.company
   */
  export type Property$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Property.units
   */
  export type Property$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    where?: PropertyUnitWhereInput
    orderBy?: PropertyUnitOrderByWithRelationInput | PropertyUnitOrderByWithRelationInput[]
    cursor?: PropertyUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyUnitScalarFieldEnum | PropertyUnitScalarFieldEnum[]
  }

  /**
   * Property.mortgages
   */
  export type Property$mortgagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    where?: MortgageWhereInput
    orderBy?: MortgageOrderByWithRelationInput | MortgageOrderByWithRelationInput[]
    cursor?: MortgageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MortgageScalarFieldEnum | MortgageScalarFieldEnum[]
  }

  /**
   * Property.revenues
   */
  export type Property$revenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    where?: RevenueWhereInput
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    cursor?: RevenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Property.expenses
   */
  export type Property$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Property.invoices
   */
  export type Property$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Property.depreciationInfo
   */
  export type Property$depreciationInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    where?: DepreciationSettingWhereInput
  }

  /**
   * Property.attachments
   */
  export type Property$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    neq: string | null
    fiscalYearEnd: Date | null
    province: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    neq: string | null
    fiscalYearEnd: Date | null
    province: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    neq: number
    fiscalYearEnd: number
    province: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    neq?: true
    fiscalYearEnd?: true
    province?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    neq?: true
    fiscalYearEnd?: true
    province?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    neq?: true
    fiscalYearEnd?: true
    province?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    userId: number
    name: string
    neq: string | null
    fiscalYearEnd: Date | null
    province: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    neq?: boolean
    fiscalYearEnd?: boolean
    province?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | Company$propertiesArgs<ExtArgs>
    shareholderLinks?: boolean | Company$shareholderLinksArgs<ExtArgs>
    shareClasses?: boolean | Company$shareClassesArgs<ExtArgs>
    shareTransactions?: boolean | Company$shareTransactionsArgs<ExtArgs>
    statements?: boolean | Company$statementsArgs<ExtArgs>
    resolutions?: boolean | Company$resolutionsArgs<ExtArgs>
    userRoles?: boolean | Company$userRolesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    neq?: boolean
    fiscalYearEnd?: boolean
    province?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    neq?: boolean
    fiscalYearEnd?: boolean
    province?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | Company$propertiesArgs<ExtArgs>
    shareholderLinks?: boolean | Company$shareholderLinksArgs<ExtArgs>
    shareClasses?: boolean | Company$shareClassesArgs<ExtArgs>
    shareTransactions?: boolean | Company$shareTransactionsArgs<ExtArgs>
    statements?: boolean | Company$statementsArgs<ExtArgs>
    resolutions?: boolean | Company$resolutionsArgs<ExtArgs>
    userRoles?: boolean | Company$userRolesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      shareholderLinks: Prisma.$CompanyShareholderPayload<ExtArgs>[]
      shareClasses: Prisma.$ShareClassPayload<ExtArgs>[]
      shareTransactions: Prisma.$ShareTransactionPayload<ExtArgs>[]
      statements: Prisma.$CorporateStatementPayload<ExtArgs>[]
      resolutions: Prisma.$CorporateResolutionPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      neq: string | null
      fiscalYearEnd: Date | null
      province: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    properties<T extends Company$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Company$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany"> | Null>
    shareholderLinks<T extends Company$shareholderLinksArgs<ExtArgs> = {}>(args?: Subset<T, Company$shareholderLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findMany"> | Null>
    shareClasses<T extends Company$shareClassesArgs<ExtArgs> = {}>(args?: Subset<T, Company$shareClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findMany"> | Null>
    shareTransactions<T extends Company$shareTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$shareTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    statements<T extends Company$statementsArgs<ExtArgs> = {}>(args?: Subset<T, Company$statementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findMany"> | Null>
    resolutions<T extends Company$resolutionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$resolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends Company$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Company$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly userId: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
    readonly neq: FieldRef<"Company", 'String'>
    readonly fiscalYearEnd: FieldRef<"Company", 'DateTime'>
    readonly province: FieldRef<"Company", 'String'>
    readonly notes: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.properties
   */
  export type Company$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Company.shareholderLinks
   */
  export type Company$shareholderLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    where?: CompanyShareholderWhereInput
    orderBy?: CompanyShareholderOrderByWithRelationInput | CompanyShareholderOrderByWithRelationInput[]
    cursor?: CompanyShareholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyShareholderScalarFieldEnum | CompanyShareholderScalarFieldEnum[]
  }

  /**
   * Company.shareClasses
   */
  export type Company$shareClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    where?: ShareClassWhereInput
    orderBy?: ShareClassOrderByWithRelationInput | ShareClassOrderByWithRelationInput[]
    cursor?: ShareClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareClassScalarFieldEnum | ShareClassScalarFieldEnum[]
  }

  /**
   * Company.shareTransactions
   */
  export type Company$shareTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    where?: ShareTransactionWhereInput
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    cursor?: ShareTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareTransactionScalarFieldEnum | ShareTransactionScalarFieldEnum[]
  }

  /**
   * Company.statements
   */
  export type Company$statementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    where?: CorporateStatementWhereInput
    orderBy?: CorporateStatementOrderByWithRelationInput | CorporateStatementOrderByWithRelationInput[]
    cursor?: CorporateStatementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorporateStatementScalarFieldEnum | CorporateStatementScalarFieldEnum[]
  }

  /**
   * Company.resolutions
   */
  export type Company$resolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    where?: CorporateResolutionWhereInput
    orderBy?: CorporateResolutionOrderByWithRelationInput | CorporateResolutionOrderByWithRelationInput[]
    cursor?: CorporateResolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorporateResolutionScalarFieldEnum | CorporateResolutionScalarFieldEnum[]
  }

  /**
   * Company.userRoles
   */
  export type Company$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Shareholder
   */

  export type AggregateShareholder = {
    _count: ShareholderCountAggregateOutputType | null
    _avg: ShareholderAvgAggregateOutputType | null
    _sum: ShareholderSumAggregateOutputType | null
    _min: ShareholderMinAggregateOutputType | null
    _max: ShareholderMaxAggregateOutputType | null
  }

  export type ShareholderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ShareholderSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ShareholderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    displayName: string | null
    contactEmail: string | null
    contactPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShareholderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    displayName: string | null
    contactEmail: string | null
    contactPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShareholderCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    displayName: number
    contactEmail: number
    contactPhone: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShareholderAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ShareholderSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ShareholderMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    displayName?: true
    contactEmail?: true
    contactPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShareholderMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    displayName?: true
    contactEmail?: true
    contactPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShareholderCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    displayName?: true
    contactEmail?: true
    contactPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShareholderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shareholder to aggregate.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shareholders
    **/
    _count?: true | ShareholderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareholderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareholderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareholderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareholderMaxAggregateInputType
  }

  export type GetShareholderAggregateType<T extends ShareholderAggregateArgs> = {
        [P in keyof T & keyof AggregateShareholder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareholder[P]>
      : GetScalarType<T[P], AggregateShareholder[P]>
  }




  export type ShareholderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareholderWhereInput
    orderBy?: ShareholderOrderByWithAggregationInput | ShareholderOrderByWithAggregationInput[]
    by: ShareholderScalarFieldEnum[] | ShareholderScalarFieldEnum
    having?: ShareholderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareholderCountAggregateInputType | true
    _avg?: ShareholderAvgAggregateInputType
    _sum?: ShareholderSumAggregateInputType
    _min?: ShareholderMinAggregateInputType
    _max?: ShareholderMaxAggregateInputType
  }

  export type ShareholderGroupByOutputType = {
    id: number
    userId: number
    type: string
    displayName: string
    contactEmail: string | null
    contactPhone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShareholderCountAggregateOutputType | null
    _avg: ShareholderAvgAggregateOutputType | null
    _sum: ShareholderSumAggregateOutputType | null
    _min: ShareholderMinAggregateOutputType | null
    _max: ShareholderMaxAggregateOutputType | null
  }

  type GetShareholderGroupByPayload<T extends ShareholderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareholderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareholderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareholderGroupByOutputType[P]>
            : GetScalarType<T[P], ShareholderGroupByOutputType[P]>
        }
      >
    >


  export type ShareholderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    displayName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    companies?: boolean | Shareholder$companiesArgs<ExtArgs>
    shareTransactions?: boolean | Shareholder$shareTransactionsArgs<ExtArgs>
    _count?: boolean | ShareholderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareholder"]>

  export type ShareholderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    displayName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareholder"]>

  export type ShareholderSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    displayName?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShareholderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    companies?: boolean | Shareholder$companiesArgs<ExtArgs>
    shareTransactions?: boolean | Shareholder$shareTransactionsArgs<ExtArgs>
    _count?: boolean | ShareholderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShareholderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ShareholderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shareholder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      companies: Prisma.$CompanyShareholderPayload<ExtArgs>[]
      shareTransactions: Prisma.$ShareTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      displayName: string
      contactEmail: string | null
      contactPhone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shareholder"]>
    composites: {}
  }

  type ShareholderGetPayload<S extends boolean | null | undefined | ShareholderDefaultArgs> = $Result.GetResult<Prisma.$ShareholderPayload, S>

  type ShareholderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShareholderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShareholderCountAggregateInputType | true
    }

  export interface ShareholderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shareholder'], meta: { name: 'Shareholder' } }
    /**
     * Find zero or one Shareholder that matches the filter.
     * @param {ShareholderFindUniqueArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareholderFindUniqueArgs>(args: SelectSubset<T, ShareholderFindUniqueArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shareholder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShareholderFindUniqueOrThrowArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareholderFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareholderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shareholder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderFindFirstArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareholderFindFirstArgs>(args?: SelectSubset<T, ShareholderFindFirstArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shareholder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderFindFirstOrThrowArgs} args - Arguments to find a Shareholder
     * @example
     * // Get one Shareholder
     * const shareholder = await prisma.shareholder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareholderFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareholderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shareholders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shareholders
     * const shareholders = await prisma.shareholder.findMany()
     * 
     * // Get first 10 Shareholders
     * const shareholders = await prisma.shareholder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareholderWithIdOnly = await prisma.shareholder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareholderFindManyArgs>(args?: SelectSubset<T, ShareholderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shareholder.
     * @param {ShareholderCreateArgs} args - Arguments to create a Shareholder.
     * @example
     * // Create one Shareholder
     * const Shareholder = await prisma.shareholder.create({
     *   data: {
     *     // ... data to create a Shareholder
     *   }
     * })
     * 
     */
    create<T extends ShareholderCreateArgs>(args: SelectSubset<T, ShareholderCreateArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shareholders.
     * @param {ShareholderCreateManyArgs} args - Arguments to create many Shareholders.
     * @example
     * // Create many Shareholders
     * const shareholder = await prisma.shareholder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareholderCreateManyArgs>(args?: SelectSubset<T, ShareholderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shareholders and returns the data saved in the database.
     * @param {ShareholderCreateManyAndReturnArgs} args - Arguments to create many Shareholders.
     * @example
     * // Create many Shareholders
     * const shareholder = await prisma.shareholder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shareholders and only return the `id`
     * const shareholderWithIdOnly = await prisma.shareholder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareholderCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareholderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shareholder.
     * @param {ShareholderDeleteArgs} args - Arguments to delete one Shareholder.
     * @example
     * // Delete one Shareholder
     * const Shareholder = await prisma.shareholder.delete({
     *   where: {
     *     // ... filter to delete one Shareholder
     *   }
     * })
     * 
     */
    delete<T extends ShareholderDeleteArgs>(args: SelectSubset<T, ShareholderDeleteArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shareholder.
     * @param {ShareholderUpdateArgs} args - Arguments to update one Shareholder.
     * @example
     * // Update one Shareholder
     * const shareholder = await prisma.shareholder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareholderUpdateArgs>(args: SelectSubset<T, ShareholderUpdateArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shareholders.
     * @param {ShareholderDeleteManyArgs} args - Arguments to filter Shareholders to delete.
     * @example
     * // Delete a few Shareholders
     * const { count } = await prisma.shareholder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareholderDeleteManyArgs>(args?: SelectSubset<T, ShareholderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shareholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shareholders
     * const shareholder = await prisma.shareholder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareholderUpdateManyArgs>(args: SelectSubset<T, ShareholderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shareholder.
     * @param {ShareholderUpsertArgs} args - Arguments to update or create a Shareholder.
     * @example
     * // Update or create a Shareholder
     * const shareholder = await prisma.shareholder.upsert({
     *   create: {
     *     // ... data to create a Shareholder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shareholder we want to update
     *   }
     * })
     */
    upsert<T extends ShareholderUpsertArgs>(args: SelectSubset<T, ShareholderUpsertArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shareholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderCountArgs} args - Arguments to filter Shareholders to count.
     * @example
     * // Count the number of Shareholders
     * const count = await prisma.shareholder.count({
     *   where: {
     *     // ... the filter for the Shareholders we want to count
     *   }
     * })
    **/
    count<T extends ShareholderCountArgs>(
      args?: Subset<T, ShareholderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareholderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shareholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareholderAggregateArgs>(args: Subset<T, ShareholderAggregateArgs>): Prisma.PrismaPromise<GetShareholderAggregateType<T>>

    /**
     * Group by Shareholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareholderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareholderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareholderGroupByArgs['orderBy'] }
        : { orderBy?: ShareholderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareholderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareholderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shareholder model
   */
  readonly fields: ShareholderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shareholder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareholderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    companies<T extends Shareholder$companiesArgs<ExtArgs> = {}>(args?: Subset<T, Shareholder$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findMany"> | Null>
    shareTransactions<T extends Shareholder$shareTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Shareholder$shareTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shareholder model
   */ 
  interface ShareholderFieldRefs {
    readonly id: FieldRef<"Shareholder", 'Int'>
    readonly userId: FieldRef<"Shareholder", 'Int'>
    readonly type: FieldRef<"Shareholder", 'String'>
    readonly displayName: FieldRef<"Shareholder", 'String'>
    readonly contactEmail: FieldRef<"Shareholder", 'String'>
    readonly contactPhone: FieldRef<"Shareholder", 'String'>
    readonly notes: FieldRef<"Shareholder", 'String'>
    readonly createdAt: FieldRef<"Shareholder", 'DateTime'>
    readonly updatedAt: FieldRef<"Shareholder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shareholder findUnique
   */
  export type ShareholderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder findUniqueOrThrow
   */
  export type ShareholderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder findFirst
   */
  export type ShareholderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shareholders.
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shareholders.
     */
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder findFirstOrThrow
   */
  export type ShareholderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholder to fetch.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shareholders.
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shareholders.
     */
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder findMany
   */
  export type ShareholderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter, which Shareholders to fetch.
     */
    where?: ShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shareholders to fetch.
     */
    orderBy?: ShareholderOrderByWithRelationInput | ShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shareholders.
     */
    cursor?: ShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shareholders.
     */
    skip?: number
    distinct?: ShareholderScalarFieldEnum | ShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder create
   */
  export type ShareholderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * The data needed to create a Shareholder.
     */
    data: XOR<ShareholderCreateInput, ShareholderUncheckedCreateInput>
  }

  /**
   * Shareholder createMany
   */
  export type ShareholderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shareholders.
     */
    data: ShareholderCreateManyInput | ShareholderCreateManyInput[]
  }

  /**
   * Shareholder createManyAndReturn
   */
  export type ShareholderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shareholders.
     */
    data: ShareholderCreateManyInput | ShareholderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shareholder update
   */
  export type ShareholderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * The data needed to update a Shareholder.
     */
    data: XOR<ShareholderUpdateInput, ShareholderUncheckedUpdateInput>
    /**
     * Choose, which Shareholder to update.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder updateMany
   */
  export type ShareholderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shareholders.
     */
    data: XOR<ShareholderUpdateManyMutationInput, ShareholderUncheckedUpdateManyInput>
    /**
     * Filter which Shareholders to update
     */
    where?: ShareholderWhereInput
  }

  /**
   * Shareholder upsert
   */
  export type ShareholderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * The filter to search for the Shareholder to update in case it exists.
     */
    where: ShareholderWhereUniqueInput
    /**
     * In case the Shareholder found by the `where` argument doesn't exist, create a new Shareholder with this data.
     */
    create: XOR<ShareholderCreateInput, ShareholderUncheckedCreateInput>
    /**
     * In case the Shareholder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareholderUpdateInput, ShareholderUncheckedUpdateInput>
  }

  /**
   * Shareholder delete
   */
  export type ShareholderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
    /**
     * Filter which Shareholder to delete.
     */
    where: ShareholderWhereUniqueInput
  }

  /**
   * Shareholder deleteMany
   */
  export type ShareholderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shareholders to delete
     */
    where?: ShareholderWhereInput
  }

  /**
   * Shareholder.companies
   */
  export type Shareholder$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    where?: CompanyShareholderWhereInput
    orderBy?: CompanyShareholderOrderByWithRelationInput | CompanyShareholderOrderByWithRelationInput[]
    cursor?: CompanyShareholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyShareholderScalarFieldEnum | CompanyShareholderScalarFieldEnum[]
  }

  /**
   * Shareholder.shareTransactions
   */
  export type Shareholder$shareTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    where?: ShareTransactionWhereInput
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    cursor?: ShareTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareTransactionScalarFieldEnum | ShareTransactionScalarFieldEnum[]
  }

  /**
   * Shareholder without action
   */
  export type ShareholderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shareholder
     */
    select?: ShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareholderInclude<ExtArgs> | null
  }


  /**
   * Model CompanyShareholder
   */

  export type AggregateCompanyShareholder = {
    _count: CompanyShareholderCountAggregateOutputType | null
    _avg: CompanyShareholderAvgAggregateOutputType | null
    _sum: CompanyShareholderSumAggregateOutputType | null
    _min: CompanyShareholderMinAggregateOutputType | null
    _max: CompanyShareholderMaxAggregateOutputType | null
  }

  export type CompanyShareholderAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareholderId: number | null
    votingPercent: Decimal | null
  }

  export type CompanyShareholderSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareholderId: number | null
    votingPercent: Decimal | null
  }

  export type CompanyShareholderMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareholderId: number | null
    role: string | null
    votingPercent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyShareholderMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareholderId: number | null
    role: string | null
    votingPercent: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyShareholderCountAggregateOutputType = {
    id: number
    companyId: number
    shareholderId: number
    role: number
    votingPercent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyShareholderAvgAggregateInputType = {
    id?: true
    companyId?: true
    shareholderId?: true
    votingPercent?: true
  }

  export type CompanyShareholderSumAggregateInputType = {
    id?: true
    companyId?: true
    shareholderId?: true
    votingPercent?: true
  }

  export type CompanyShareholderMinAggregateInputType = {
    id?: true
    companyId?: true
    shareholderId?: true
    role?: true
    votingPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyShareholderMaxAggregateInputType = {
    id?: true
    companyId?: true
    shareholderId?: true
    role?: true
    votingPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyShareholderCountAggregateInputType = {
    id?: true
    companyId?: true
    shareholderId?: true
    role?: true
    votingPercent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyShareholderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyShareholder to aggregate.
     */
    where?: CompanyShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyShareholders to fetch.
     */
    orderBy?: CompanyShareholderOrderByWithRelationInput | CompanyShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyShareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyShareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyShareholders
    **/
    _count?: true | CompanyShareholderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyShareholderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyShareholderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyShareholderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyShareholderMaxAggregateInputType
  }

  export type GetCompanyShareholderAggregateType<T extends CompanyShareholderAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyShareholder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyShareholder[P]>
      : GetScalarType<T[P], AggregateCompanyShareholder[P]>
  }




  export type CompanyShareholderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyShareholderWhereInput
    orderBy?: CompanyShareholderOrderByWithAggregationInput | CompanyShareholderOrderByWithAggregationInput[]
    by: CompanyShareholderScalarFieldEnum[] | CompanyShareholderScalarFieldEnum
    having?: CompanyShareholderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyShareholderCountAggregateInputType | true
    _avg?: CompanyShareholderAvgAggregateInputType
    _sum?: CompanyShareholderSumAggregateInputType
    _min?: CompanyShareholderMinAggregateInputType
    _max?: CompanyShareholderMaxAggregateInputType
  }

  export type CompanyShareholderGroupByOutputType = {
    id: number
    companyId: number
    shareholderId: number
    role: string | null
    votingPercent: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyShareholderCountAggregateOutputType | null
    _avg: CompanyShareholderAvgAggregateOutputType | null
    _sum: CompanyShareholderSumAggregateOutputType | null
    _min: CompanyShareholderMinAggregateOutputType | null
    _max: CompanyShareholderMaxAggregateOutputType | null
  }

  type GetCompanyShareholderGroupByPayload<T extends CompanyShareholderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyShareholderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyShareholderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyShareholderGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyShareholderGroupByOutputType[P]>
        }
      >
    >


  export type CompanyShareholderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareholderId?: boolean
    role?: boolean
    votingPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyShareholder"]>

  export type CompanyShareholderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareholderId?: boolean
    role?: boolean
    votingPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyShareholder"]>

  export type CompanyShareholderSelectScalar = {
    id?: boolean
    companyId?: boolean
    shareholderId?: boolean
    role?: boolean
    votingPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyShareholderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }
  export type CompanyShareholderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }

  export type $CompanyShareholderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyShareholder"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      shareholder: Prisma.$ShareholderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      shareholderId: number
      role: string | null
      votingPercent: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyShareholder"]>
    composites: {}
  }

  type CompanyShareholderGetPayload<S extends boolean | null | undefined | CompanyShareholderDefaultArgs> = $Result.GetResult<Prisma.$CompanyShareholderPayload, S>

  type CompanyShareholderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyShareholderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyShareholderCountAggregateInputType | true
    }

  export interface CompanyShareholderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyShareholder'], meta: { name: 'CompanyShareholder' } }
    /**
     * Find zero or one CompanyShareholder that matches the filter.
     * @param {CompanyShareholderFindUniqueArgs} args - Arguments to find a CompanyShareholder
     * @example
     * // Get one CompanyShareholder
     * const companyShareholder = await prisma.companyShareholder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyShareholderFindUniqueArgs>(args: SelectSubset<T, CompanyShareholderFindUniqueArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyShareholder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyShareholderFindUniqueOrThrowArgs} args - Arguments to find a CompanyShareholder
     * @example
     * // Get one CompanyShareholder
     * const companyShareholder = await prisma.companyShareholder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyShareholderFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyShareholderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyShareholder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderFindFirstArgs} args - Arguments to find a CompanyShareholder
     * @example
     * // Get one CompanyShareholder
     * const companyShareholder = await prisma.companyShareholder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyShareholderFindFirstArgs>(args?: SelectSubset<T, CompanyShareholderFindFirstArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyShareholder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderFindFirstOrThrowArgs} args - Arguments to find a CompanyShareholder
     * @example
     * // Get one CompanyShareholder
     * const companyShareholder = await prisma.companyShareholder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyShareholderFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyShareholderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyShareholders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyShareholders
     * const companyShareholders = await prisma.companyShareholder.findMany()
     * 
     * // Get first 10 CompanyShareholders
     * const companyShareholders = await prisma.companyShareholder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyShareholderWithIdOnly = await prisma.companyShareholder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyShareholderFindManyArgs>(args?: SelectSubset<T, CompanyShareholderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyShareholder.
     * @param {CompanyShareholderCreateArgs} args - Arguments to create a CompanyShareholder.
     * @example
     * // Create one CompanyShareholder
     * const CompanyShareholder = await prisma.companyShareholder.create({
     *   data: {
     *     // ... data to create a CompanyShareholder
     *   }
     * })
     * 
     */
    create<T extends CompanyShareholderCreateArgs>(args: SelectSubset<T, CompanyShareholderCreateArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyShareholders.
     * @param {CompanyShareholderCreateManyArgs} args - Arguments to create many CompanyShareholders.
     * @example
     * // Create many CompanyShareholders
     * const companyShareholder = await prisma.companyShareholder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyShareholderCreateManyArgs>(args?: SelectSubset<T, CompanyShareholderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyShareholders and returns the data saved in the database.
     * @param {CompanyShareholderCreateManyAndReturnArgs} args - Arguments to create many CompanyShareholders.
     * @example
     * // Create many CompanyShareholders
     * const companyShareholder = await prisma.companyShareholder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyShareholders and only return the `id`
     * const companyShareholderWithIdOnly = await prisma.companyShareholder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyShareholderCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyShareholderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyShareholder.
     * @param {CompanyShareholderDeleteArgs} args - Arguments to delete one CompanyShareholder.
     * @example
     * // Delete one CompanyShareholder
     * const CompanyShareholder = await prisma.companyShareholder.delete({
     *   where: {
     *     // ... filter to delete one CompanyShareholder
     *   }
     * })
     * 
     */
    delete<T extends CompanyShareholderDeleteArgs>(args: SelectSubset<T, CompanyShareholderDeleteArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyShareholder.
     * @param {CompanyShareholderUpdateArgs} args - Arguments to update one CompanyShareholder.
     * @example
     * // Update one CompanyShareholder
     * const companyShareholder = await prisma.companyShareholder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyShareholderUpdateArgs>(args: SelectSubset<T, CompanyShareholderUpdateArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyShareholders.
     * @param {CompanyShareholderDeleteManyArgs} args - Arguments to filter CompanyShareholders to delete.
     * @example
     * // Delete a few CompanyShareholders
     * const { count } = await prisma.companyShareholder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyShareholderDeleteManyArgs>(args?: SelectSubset<T, CompanyShareholderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyShareholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyShareholders
     * const companyShareholder = await prisma.companyShareholder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyShareholderUpdateManyArgs>(args: SelectSubset<T, CompanyShareholderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyShareholder.
     * @param {CompanyShareholderUpsertArgs} args - Arguments to update or create a CompanyShareholder.
     * @example
     * // Update or create a CompanyShareholder
     * const companyShareholder = await prisma.companyShareholder.upsert({
     *   create: {
     *     // ... data to create a CompanyShareholder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyShareholder we want to update
     *   }
     * })
     */
    upsert<T extends CompanyShareholderUpsertArgs>(args: SelectSubset<T, CompanyShareholderUpsertArgs<ExtArgs>>): Prisma__CompanyShareholderClient<$Result.GetResult<Prisma.$CompanyShareholderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyShareholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderCountArgs} args - Arguments to filter CompanyShareholders to count.
     * @example
     * // Count the number of CompanyShareholders
     * const count = await prisma.companyShareholder.count({
     *   where: {
     *     // ... the filter for the CompanyShareholders we want to count
     *   }
     * })
    **/
    count<T extends CompanyShareholderCountArgs>(
      args?: Subset<T, CompanyShareholderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyShareholderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyShareholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyShareholderAggregateArgs>(args: Subset<T, CompanyShareholderAggregateArgs>): Prisma.PrismaPromise<GetCompanyShareholderAggregateType<T>>

    /**
     * Group by CompanyShareholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyShareholderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyShareholderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyShareholderGroupByArgs['orderBy'] }
        : { orderBy?: CompanyShareholderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyShareholderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyShareholderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyShareholder model
   */
  readonly fields: CompanyShareholderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyShareholder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyShareholderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shareholder<T extends ShareholderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShareholderDefaultArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyShareholder model
   */ 
  interface CompanyShareholderFieldRefs {
    readonly id: FieldRef<"CompanyShareholder", 'Int'>
    readonly companyId: FieldRef<"CompanyShareholder", 'Int'>
    readonly shareholderId: FieldRef<"CompanyShareholder", 'Int'>
    readonly role: FieldRef<"CompanyShareholder", 'String'>
    readonly votingPercent: FieldRef<"CompanyShareholder", 'Decimal'>
    readonly createdAt: FieldRef<"CompanyShareholder", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyShareholder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyShareholder findUnique
   */
  export type CompanyShareholderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyShareholder to fetch.
     */
    where: CompanyShareholderWhereUniqueInput
  }

  /**
   * CompanyShareholder findUniqueOrThrow
   */
  export type CompanyShareholderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyShareholder to fetch.
     */
    where: CompanyShareholderWhereUniqueInput
  }

  /**
   * CompanyShareholder findFirst
   */
  export type CompanyShareholderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyShareholder to fetch.
     */
    where?: CompanyShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyShareholders to fetch.
     */
    orderBy?: CompanyShareholderOrderByWithRelationInput | CompanyShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyShareholders.
     */
    cursor?: CompanyShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyShareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyShareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyShareholders.
     */
    distinct?: CompanyShareholderScalarFieldEnum | CompanyShareholderScalarFieldEnum[]
  }

  /**
   * CompanyShareholder findFirstOrThrow
   */
  export type CompanyShareholderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyShareholder to fetch.
     */
    where?: CompanyShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyShareholders to fetch.
     */
    orderBy?: CompanyShareholderOrderByWithRelationInput | CompanyShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyShareholders.
     */
    cursor?: CompanyShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyShareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyShareholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyShareholders.
     */
    distinct?: CompanyShareholderScalarFieldEnum | CompanyShareholderScalarFieldEnum[]
  }

  /**
   * CompanyShareholder findMany
   */
  export type CompanyShareholderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * Filter, which CompanyShareholders to fetch.
     */
    where?: CompanyShareholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyShareholders to fetch.
     */
    orderBy?: CompanyShareholderOrderByWithRelationInput | CompanyShareholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyShareholders.
     */
    cursor?: CompanyShareholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyShareholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyShareholders.
     */
    skip?: number
    distinct?: CompanyShareholderScalarFieldEnum | CompanyShareholderScalarFieldEnum[]
  }

  /**
   * CompanyShareholder create
   */
  export type CompanyShareholderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyShareholder.
     */
    data: XOR<CompanyShareholderCreateInput, CompanyShareholderUncheckedCreateInput>
  }

  /**
   * CompanyShareholder createMany
   */
  export type CompanyShareholderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyShareholders.
     */
    data: CompanyShareholderCreateManyInput | CompanyShareholderCreateManyInput[]
  }

  /**
   * CompanyShareholder createManyAndReturn
   */
  export type CompanyShareholderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyShareholders.
     */
    data: CompanyShareholderCreateManyInput | CompanyShareholderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyShareholder update
   */
  export type CompanyShareholderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyShareholder.
     */
    data: XOR<CompanyShareholderUpdateInput, CompanyShareholderUncheckedUpdateInput>
    /**
     * Choose, which CompanyShareholder to update.
     */
    where: CompanyShareholderWhereUniqueInput
  }

  /**
   * CompanyShareholder updateMany
   */
  export type CompanyShareholderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyShareholders.
     */
    data: XOR<CompanyShareholderUpdateManyMutationInput, CompanyShareholderUncheckedUpdateManyInput>
    /**
     * Filter which CompanyShareholders to update
     */
    where?: CompanyShareholderWhereInput
  }

  /**
   * CompanyShareholder upsert
   */
  export type CompanyShareholderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyShareholder to update in case it exists.
     */
    where: CompanyShareholderWhereUniqueInput
    /**
     * In case the CompanyShareholder found by the `where` argument doesn't exist, create a new CompanyShareholder with this data.
     */
    create: XOR<CompanyShareholderCreateInput, CompanyShareholderUncheckedCreateInput>
    /**
     * In case the CompanyShareholder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyShareholderUpdateInput, CompanyShareholderUncheckedUpdateInput>
  }

  /**
   * CompanyShareholder delete
   */
  export type CompanyShareholderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
    /**
     * Filter which CompanyShareholder to delete.
     */
    where: CompanyShareholderWhereUniqueInput
  }

  /**
   * CompanyShareholder deleteMany
   */
  export type CompanyShareholderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyShareholders to delete
     */
    where?: CompanyShareholderWhereInput
  }

  /**
   * CompanyShareholder without action
   */
  export type CompanyShareholderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyShareholder
     */
    select?: CompanyShareholderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyShareholderInclude<ExtArgs> | null
  }


  /**
   * Model ShareClass
   */

  export type AggregateShareClass = {
    _count: ShareClassCountAggregateOutputType | null
    _avg: ShareClassAvgAggregateOutputType | null
    _sum: ShareClassSumAggregateOutputType | null
    _min: ShareClassMinAggregateOutputType | null
    _max: ShareClassMaxAggregateOutputType | null
  }

  export type ShareClassAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ShareClassSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type ShareClassMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    code: string | null
    description: string | null
    hasVotingRights: boolean | null
    participatesInGrowth: boolean | null
    dividendPolicy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShareClassMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    code: string | null
    description: string | null
    hasVotingRights: boolean | null
    participatesInGrowth: boolean | null
    dividendPolicy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShareClassCountAggregateOutputType = {
    id: number
    companyId: number
    code: number
    description: number
    hasVotingRights: number
    participatesInGrowth: number
    dividendPolicy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShareClassAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ShareClassSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type ShareClassMinAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    description?: true
    hasVotingRights?: true
    participatesInGrowth?: true
    dividendPolicy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShareClassMaxAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    description?: true
    hasVotingRights?: true
    participatesInGrowth?: true
    dividendPolicy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShareClassCountAggregateInputType = {
    id?: true
    companyId?: true
    code?: true
    description?: true
    hasVotingRights?: true
    participatesInGrowth?: true
    dividendPolicy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShareClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareClass to aggregate.
     */
    where?: ShareClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareClasses to fetch.
     */
    orderBy?: ShareClassOrderByWithRelationInput | ShareClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareClasses
    **/
    _count?: true | ShareClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareClassMaxAggregateInputType
  }

  export type GetShareClassAggregateType<T extends ShareClassAggregateArgs> = {
        [P in keyof T & keyof AggregateShareClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareClass[P]>
      : GetScalarType<T[P], AggregateShareClass[P]>
  }




  export type ShareClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareClassWhereInput
    orderBy?: ShareClassOrderByWithAggregationInput | ShareClassOrderByWithAggregationInput[]
    by: ShareClassScalarFieldEnum[] | ShareClassScalarFieldEnum
    having?: ShareClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareClassCountAggregateInputType | true
    _avg?: ShareClassAvgAggregateInputType
    _sum?: ShareClassSumAggregateInputType
    _min?: ShareClassMinAggregateInputType
    _max?: ShareClassMaxAggregateInputType
  }

  export type ShareClassGroupByOutputType = {
    id: number
    companyId: number
    code: string
    description: string | null
    hasVotingRights: boolean
    participatesInGrowth: boolean
    dividendPolicy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShareClassCountAggregateOutputType | null
    _avg: ShareClassAvgAggregateOutputType | null
    _sum: ShareClassSumAggregateOutputType | null
    _min: ShareClassMinAggregateOutputType | null
    _max: ShareClassMaxAggregateOutputType | null
  }

  type GetShareClassGroupByPayload<T extends ShareClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareClassGroupByOutputType[P]>
            : GetScalarType<T[P], ShareClassGroupByOutputType[P]>
        }
      >
    >


  export type ShareClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    description?: boolean
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | ShareClass$transactionsArgs<ExtArgs>
    _count?: boolean | ShareClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareClass"]>

  export type ShareClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    code?: boolean
    description?: boolean
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareClass"]>

  export type ShareClassSelectScalar = {
    id?: boolean
    companyId?: boolean
    code?: boolean
    description?: boolean
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShareClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    transactions?: boolean | ShareClass$transactionsArgs<ExtArgs>
    _count?: boolean | ShareClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShareClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ShareClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareClass"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      transactions: Prisma.$ShareTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      code: string
      description: string | null
      hasVotingRights: boolean
      participatesInGrowth: boolean
      dividendPolicy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shareClass"]>
    composites: {}
  }

  type ShareClassGetPayload<S extends boolean | null | undefined | ShareClassDefaultArgs> = $Result.GetResult<Prisma.$ShareClassPayload, S>

  type ShareClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShareClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShareClassCountAggregateInputType | true
    }

  export interface ShareClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareClass'], meta: { name: 'ShareClass' } }
    /**
     * Find zero or one ShareClass that matches the filter.
     * @param {ShareClassFindUniqueArgs} args - Arguments to find a ShareClass
     * @example
     * // Get one ShareClass
     * const shareClass = await prisma.shareClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareClassFindUniqueArgs>(args: SelectSubset<T, ShareClassFindUniqueArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShareClass that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShareClassFindUniqueOrThrowArgs} args - Arguments to find a ShareClass
     * @example
     * // Get one ShareClass
     * const shareClass = await prisma.shareClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShareClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassFindFirstArgs} args - Arguments to find a ShareClass
     * @example
     * // Get one ShareClass
     * const shareClass = await prisma.shareClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareClassFindFirstArgs>(args?: SelectSubset<T, ShareClassFindFirstArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShareClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassFindFirstOrThrowArgs} args - Arguments to find a ShareClass
     * @example
     * // Get one ShareClass
     * const shareClass = await prisma.shareClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShareClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareClasses
     * const shareClasses = await prisma.shareClass.findMany()
     * 
     * // Get first 10 ShareClasses
     * const shareClasses = await prisma.shareClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareClassWithIdOnly = await prisma.shareClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareClassFindManyArgs>(args?: SelectSubset<T, ShareClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShareClass.
     * @param {ShareClassCreateArgs} args - Arguments to create a ShareClass.
     * @example
     * // Create one ShareClass
     * const ShareClass = await prisma.shareClass.create({
     *   data: {
     *     // ... data to create a ShareClass
     *   }
     * })
     * 
     */
    create<T extends ShareClassCreateArgs>(args: SelectSubset<T, ShareClassCreateArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShareClasses.
     * @param {ShareClassCreateManyArgs} args - Arguments to create many ShareClasses.
     * @example
     * // Create many ShareClasses
     * const shareClass = await prisma.shareClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareClassCreateManyArgs>(args?: SelectSubset<T, ShareClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShareClasses and returns the data saved in the database.
     * @param {ShareClassCreateManyAndReturnArgs} args - Arguments to create many ShareClasses.
     * @example
     * // Create many ShareClasses
     * const shareClass = await prisma.shareClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShareClasses and only return the `id`
     * const shareClassWithIdOnly = await prisma.shareClass.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShareClass.
     * @param {ShareClassDeleteArgs} args - Arguments to delete one ShareClass.
     * @example
     * // Delete one ShareClass
     * const ShareClass = await prisma.shareClass.delete({
     *   where: {
     *     // ... filter to delete one ShareClass
     *   }
     * })
     * 
     */
    delete<T extends ShareClassDeleteArgs>(args: SelectSubset<T, ShareClassDeleteArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShareClass.
     * @param {ShareClassUpdateArgs} args - Arguments to update one ShareClass.
     * @example
     * // Update one ShareClass
     * const shareClass = await prisma.shareClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareClassUpdateArgs>(args: SelectSubset<T, ShareClassUpdateArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShareClasses.
     * @param {ShareClassDeleteManyArgs} args - Arguments to filter ShareClasses to delete.
     * @example
     * // Delete a few ShareClasses
     * const { count } = await prisma.shareClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareClassDeleteManyArgs>(args?: SelectSubset<T, ShareClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareClasses
     * const shareClass = await prisma.shareClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareClassUpdateManyArgs>(args: SelectSubset<T, ShareClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShareClass.
     * @param {ShareClassUpsertArgs} args - Arguments to update or create a ShareClass.
     * @example
     * // Update or create a ShareClass
     * const shareClass = await prisma.shareClass.upsert({
     *   create: {
     *     // ... data to create a ShareClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareClass we want to update
     *   }
     * })
     */
    upsert<T extends ShareClassUpsertArgs>(args: SelectSubset<T, ShareClassUpsertArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShareClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassCountArgs} args - Arguments to filter ShareClasses to count.
     * @example
     * // Count the number of ShareClasses
     * const count = await prisma.shareClass.count({
     *   where: {
     *     // ... the filter for the ShareClasses we want to count
     *   }
     * })
    **/
    count<T extends ShareClassCountArgs>(
      args?: Subset<T, ShareClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareClassAggregateArgs>(args: Subset<T, ShareClassAggregateArgs>): Prisma.PrismaPromise<GetShareClassAggregateType<T>>

    /**
     * Group by ShareClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareClassGroupByArgs['orderBy'] }
        : { orderBy?: ShareClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareClass model
   */
  readonly fields: ShareClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends ShareClass$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, ShareClass$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareClass model
   */ 
  interface ShareClassFieldRefs {
    readonly id: FieldRef<"ShareClass", 'Int'>
    readonly companyId: FieldRef<"ShareClass", 'Int'>
    readonly code: FieldRef<"ShareClass", 'String'>
    readonly description: FieldRef<"ShareClass", 'String'>
    readonly hasVotingRights: FieldRef<"ShareClass", 'Boolean'>
    readonly participatesInGrowth: FieldRef<"ShareClass", 'Boolean'>
    readonly dividendPolicy: FieldRef<"ShareClass", 'String'>
    readonly createdAt: FieldRef<"ShareClass", 'DateTime'>
    readonly updatedAt: FieldRef<"ShareClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareClass findUnique
   */
  export type ShareClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * Filter, which ShareClass to fetch.
     */
    where: ShareClassWhereUniqueInput
  }

  /**
   * ShareClass findUniqueOrThrow
   */
  export type ShareClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * Filter, which ShareClass to fetch.
     */
    where: ShareClassWhereUniqueInput
  }

  /**
   * ShareClass findFirst
   */
  export type ShareClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * Filter, which ShareClass to fetch.
     */
    where?: ShareClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareClasses to fetch.
     */
    orderBy?: ShareClassOrderByWithRelationInput | ShareClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareClasses.
     */
    cursor?: ShareClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareClasses.
     */
    distinct?: ShareClassScalarFieldEnum | ShareClassScalarFieldEnum[]
  }

  /**
   * ShareClass findFirstOrThrow
   */
  export type ShareClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * Filter, which ShareClass to fetch.
     */
    where?: ShareClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareClasses to fetch.
     */
    orderBy?: ShareClassOrderByWithRelationInput | ShareClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareClasses.
     */
    cursor?: ShareClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareClasses.
     */
    distinct?: ShareClassScalarFieldEnum | ShareClassScalarFieldEnum[]
  }

  /**
   * ShareClass findMany
   */
  export type ShareClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * Filter, which ShareClasses to fetch.
     */
    where?: ShareClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareClasses to fetch.
     */
    orderBy?: ShareClassOrderByWithRelationInput | ShareClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareClasses.
     */
    cursor?: ShareClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareClasses.
     */
    skip?: number
    distinct?: ShareClassScalarFieldEnum | ShareClassScalarFieldEnum[]
  }

  /**
   * ShareClass create
   */
  export type ShareClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareClass.
     */
    data: XOR<ShareClassCreateInput, ShareClassUncheckedCreateInput>
  }

  /**
   * ShareClass createMany
   */
  export type ShareClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareClasses.
     */
    data: ShareClassCreateManyInput | ShareClassCreateManyInput[]
  }

  /**
   * ShareClass createManyAndReturn
   */
  export type ShareClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShareClasses.
     */
    data: ShareClassCreateManyInput | ShareClassCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareClass update
   */
  export type ShareClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareClass.
     */
    data: XOR<ShareClassUpdateInput, ShareClassUncheckedUpdateInput>
    /**
     * Choose, which ShareClass to update.
     */
    where: ShareClassWhereUniqueInput
  }

  /**
   * ShareClass updateMany
   */
  export type ShareClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareClasses.
     */
    data: XOR<ShareClassUpdateManyMutationInput, ShareClassUncheckedUpdateManyInput>
    /**
     * Filter which ShareClasses to update
     */
    where?: ShareClassWhereInput
  }

  /**
   * ShareClass upsert
   */
  export type ShareClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareClass to update in case it exists.
     */
    where: ShareClassWhereUniqueInput
    /**
     * In case the ShareClass found by the `where` argument doesn't exist, create a new ShareClass with this data.
     */
    create: XOR<ShareClassCreateInput, ShareClassUncheckedCreateInput>
    /**
     * In case the ShareClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareClassUpdateInput, ShareClassUncheckedUpdateInput>
  }

  /**
   * ShareClass delete
   */
  export type ShareClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
    /**
     * Filter which ShareClass to delete.
     */
    where: ShareClassWhereUniqueInput
  }

  /**
   * ShareClass deleteMany
   */
  export type ShareClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareClasses to delete
     */
    where?: ShareClassWhereInput
  }

  /**
   * ShareClass.transactions
   */
  export type ShareClass$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    where?: ShareTransactionWhereInput
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    cursor?: ShareTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareTransactionScalarFieldEnum | ShareTransactionScalarFieldEnum[]
  }

  /**
   * ShareClass without action
   */
  export type ShareClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareClass
     */
    select?: ShareClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareClassInclude<ExtArgs> | null
  }


  /**
   * Model ShareTransaction
   */

  export type AggregateShareTransaction = {
    _count: ShareTransactionCountAggregateOutputType | null
    _avg: ShareTransactionAvgAggregateOutputType | null
    _sum: ShareTransactionSumAggregateOutputType | null
    _min: ShareTransactionMinAggregateOutputType | null
    _max: ShareTransactionMaxAggregateOutputType | null
  }

  export type ShareTransactionAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareClassId: number | null
    shareholderId: number | null
    quantity: Decimal | null
    pricePerShare: Decimal | null
    considerationPaid: Decimal | null
    fairMarketValue: Decimal | null
  }

  export type ShareTransactionSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareClassId: number | null
    shareholderId: number | null
    quantity: Decimal | null
    pricePerShare: Decimal | null
    considerationPaid: Decimal | null
    fairMarketValue: Decimal | null
  }

  export type ShareTransactionMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareClassId: number | null
    shareholderId: number | null
    type: string | null
    transactionDate: Date | null
    quantity: Decimal | null
    pricePerShare: Decimal | null
    considerationPaid: Decimal | null
    fairMarketValue: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShareTransactionMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    shareClassId: number | null
    shareholderId: number | null
    type: string | null
    transactionDate: Date | null
    quantity: Decimal | null
    pricePerShare: Decimal | null
    considerationPaid: Decimal | null
    fairMarketValue: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShareTransactionCountAggregateOutputType = {
    id: number
    companyId: number
    shareClassId: number
    shareholderId: number
    type: number
    transactionDate: number
    quantity: number
    pricePerShare: number
    considerationPaid: number
    fairMarketValue: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShareTransactionAvgAggregateInputType = {
    id?: true
    companyId?: true
    shareClassId?: true
    shareholderId?: true
    quantity?: true
    pricePerShare?: true
    considerationPaid?: true
    fairMarketValue?: true
  }

  export type ShareTransactionSumAggregateInputType = {
    id?: true
    companyId?: true
    shareClassId?: true
    shareholderId?: true
    quantity?: true
    pricePerShare?: true
    considerationPaid?: true
    fairMarketValue?: true
  }

  export type ShareTransactionMinAggregateInputType = {
    id?: true
    companyId?: true
    shareClassId?: true
    shareholderId?: true
    type?: true
    transactionDate?: true
    quantity?: true
    pricePerShare?: true
    considerationPaid?: true
    fairMarketValue?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShareTransactionMaxAggregateInputType = {
    id?: true
    companyId?: true
    shareClassId?: true
    shareholderId?: true
    type?: true
    transactionDate?: true
    quantity?: true
    pricePerShare?: true
    considerationPaid?: true
    fairMarketValue?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShareTransactionCountAggregateInputType = {
    id?: true
    companyId?: true
    shareClassId?: true
    shareholderId?: true
    type?: true
    transactionDate?: true
    quantity?: true
    pricePerShare?: true
    considerationPaid?: true
    fairMarketValue?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShareTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareTransaction to aggregate.
     */
    where?: ShareTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransactions to fetch.
     */
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareTransactions
    **/
    _count?: true | ShareTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShareTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShareTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareTransactionMaxAggregateInputType
  }

  export type GetShareTransactionAggregateType<T extends ShareTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateShareTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareTransaction[P]>
      : GetScalarType<T[P], AggregateShareTransaction[P]>
  }




  export type ShareTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareTransactionWhereInput
    orderBy?: ShareTransactionOrderByWithAggregationInput | ShareTransactionOrderByWithAggregationInput[]
    by: ShareTransactionScalarFieldEnum[] | ShareTransactionScalarFieldEnum
    having?: ShareTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareTransactionCountAggregateInputType | true
    _avg?: ShareTransactionAvgAggregateInputType
    _sum?: ShareTransactionSumAggregateInputType
    _min?: ShareTransactionMinAggregateInputType
    _max?: ShareTransactionMaxAggregateInputType
  }

  export type ShareTransactionGroupByOutputType = {
    id: number
    companyId: number
    shareClassId: number
    shareholderId: number
    type: string
    transactionDate: Date
    quantity: Decimal
    pricePerShare: Decimal | null
    considerationPaid: Decimal | null
    fairMarketValue: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShareTransactionCountAggregateOutputType | null
    _avg: ShareTransactionAvgAggregateOutputType | null
    _sum: ShareTransactionSumAggregateOutputType | null
    _min: ShareTransactionMinAggregateOutputType | null
    _max: ShareTransactionMaxAggregateOutputType | null
  }

  type GetShareTransactionGroupByPayload<T extends ShareTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], ShareTransactionGroupByOutputType[P]>
        }
      >
    >


  export type ShareTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareClassId?: boolean
    shareholderId?: boolean
    type?: boolean
    transactionDate?: boolean
    quantity?: boolean
    pricePerShare?: boolean
    considerationPaid?: boolean
    fairMarketValue?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareClass?: boolean | ShareClassDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareTransaction"]>

  export type ShareTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    shareClassId?: boolean
    shareholderId?: boolean
    type?: boolean
    transactionDate?: boolean
    quantity?: boolean
    pricePerShare?: boolean
    considerationPaid?: boolean
    fairMarketValue?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareClass?: boolean | ShareClassDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareTransaction"]>

  export type ShareTransactionSelectScalar = {
    id?: boolean
    companyId?: boolean
    shareClassId?: boolean
    shareholderId?: boolean
    type?: boolean
    transactionDate?: boolean
    quantity?: boolean
    pricePerShare?: boolean
    considerationPaid?: boolean
    fairMarketValue?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShareTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareClass?: boolean | ShareClassDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }
  export type ShareTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    shareClass?: boolean | ShareClassDefaultArgs<ExtArgs>
    shareholder?: boolean | ShareholderDefaultArgs<ExtArgs>
  }

  export type $ShareTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareTransaction"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      shareClass: Prisma.$ShareClassPayload<ExtArgs>
      shareholder: Prisma.$ShareholderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      shareClassId: number
      shareholderId: number
      type: string
      transactionDate: Date
      quantity: Prisma.Decimal
      pricePerShare: Prisma.Decimal | null
      considerationPaid: Prisma.Decimal | null
      fairMarketValue: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shareTransaction"]>
    composites: {}
  }

  type ShareTransactionGetPayload<S extends boolean | null | undefined | ShareTransactionDefaultArgs> = $Result.GetResult<Prisma.$ShareTransactionPayload, S>

  type ShareTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShareTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShareTransactionCountAggregateInputType | true
    }

  export interface ShareTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareTransaction'], meta: { name: 'ShareTransaction' } }
    /**
     * Find zero or one ShareTransaction that matches the filter.
     * @param {ShareTransactionFindUniqueArgs} args - Arguments to find a ShareTransaction
     * @example
     * // Get one ShareTransaction
     * const shareTransaction = await prisma.shareTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareTransactionFindUniqueArgs>(args: SelectSubset<T, ShareTransactionFindUniqueArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShareTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShareTransactionFindUniqueOrThrowArgs} args - Arguments to find a ShareTransaction
     * @example
     * // Get one ShareTransaction
     * const shareTransaction = await prisma.shareTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShareTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionFindFirstArgs} args - Arguments to find a ShareTransaction
     * @example
     * // Get one ShareTransaction
     * const shareTransaction = await prisma.shareTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareTransactionFindFirstArgs>(args?: SelectSubset<T, ShareTransactionFindFirstArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShareTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionFindFirstOrThrowArgs} args - Arguments to find a ShareTransaction
     * @example
     * // Get one ShareTransaction
     * const shareTransaction = await prisma.shareTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShareTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareTransactions
     * const shareTransactions = await prisma.shareTransaction.findMany()
     * 
     * // Get first 10 ShareTransactions
     * const shareTransactions = await prisma.shareTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareTransactionWithIdOnly = await prisma.shareTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareTransactionFindManyArgs>(args?: SelectSubset<T, ShareTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShareTransaction.
     * @param {ShareTransactionCreateArgs} args - Arguments to create a ShareTransaction.
     * @example
     * // Create one ShareTransaction
     * const ShareTransaction = await prisma.shareTransaction.create({
     *   data: {
     *     // ... data to create a ShareTransaction
     *   }
     * })
     * 
     */
    create<T extends ShareTransactionCreateArgs>(args: SelectSubset<T, ShareTransactionCreateArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShareTransactions.
     * @param {ShareTransactionCreateManyArgs} args - Arguments to create many ShareTransactions.
     * @example
     * // Create many ShareTransactions
     * const shareTransaction = await prisma.shareTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareTransactionCreateManyArgs>(args?: SelectSubset<T, ShareTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShareTransactions and returns the data saved in the database.
     * @param {ShareTransactionCreateManyAndReturnArgs} args - Arguments to create many ShareTransactions.
     * @example
     * // Create many ShareTransactions
     * const shareTransaction = await prisma.shareTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShareTransactions and only return the `id`
     * const shareTransactionWithIdOnly = await prisma.shareTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShareTransaction.
     * @param {ShareTransactionDeleteArgs} args - Arguments to delete one ShareTransaction.
     * @example
     * // Delete one ShareTransaction
     * const ShareTransaction = await prisma.shareTransaction.delete({
     *   where: {
     *     // ... filter to delete one ShareTransaction
     *   }
     * })
     * 
     */
    delete<T extends ShareTransactionDeleteArgs>(args: SelectSubset<T, ShareTransactionDeleteArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShareTransaction.
     * @param {ShareTransactionUpdateArgs} args - Arguments to update one ShareTransaction.
     * @example
     * // Update one ShareTransaction
     * const shareTransaction = await prisma.shareTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareTransactionUpdateArgs>(args: SelectSubset<T, ShareTransactionUpdateArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShareTransactions.
     * @param {ShareTransactionDeleteManyArgs} args - Arguments to filter ShareTransactions to delete.
     * @example
     * // Delete a few ShareTransactions
     * const { count } = await prisma.shareTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareTransactionDeleteManyArgs>(args?: SelectSubset<T, ShareTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareTransactions
     * const shareTransaction = await prisma.shareTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareTransactionUpdateManyArgs>(args: SelectSubset<T, ShareTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShareTransaction.
     * @param {ShareTransactionUpsertArgs} args - Arguments to update or create a ShareTransaction.
     * @example
     * // Update or create a ShareTransaction
     * const shareTransaction = await prisma.shareTransaction.upsert({
     *   create: {
     *     // ... data to create a ShareTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareTransaction we want to update
     *   }
     * })
     */
    upsert<T extends ShareTransactionUpsertArgs>(args: SelectSubset<T, ShareTransactionUpsertArgs<ExtArgs>>): Prisma__ShareTransactionClient<$Result.GetResult<Prisma.$ShareTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShareTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionCountArgs} args - Arguments to filter ShareTransactions to count.
     * @example
     * // Count the number of ShareTransactions
     * const count = await prisma.shareTransaction.count({
     *   where: {
     *     // ... the filter for the ShareTransactions we want to count
     *   }
     * })
    **/
    count<T extends ShareTransactionCountArgs>(
      args?: Subset<T, ShareTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareTransactionAggregateArgs>(args: Subset<T, ShareTransactionAggregateArgs>): Prisma.PrismaPromise<GetShareTransactionAggregateType<T>>

    /**
     * Group by ShareTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareTransactionGroupByArgs['orderBy'] }
        : { orderBy?: ShareTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareTransaction model
   */
  readonly fields: ShareTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shareClass<T extends ShareClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShareClassDefaultArgs<ExtArgs>>): Prisma__ShareClassClient<$Result.GetResult<Prisma.$ShareClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    shareholder<T extends ShareholderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShareholderDefaultArgs<ExtArgs>>): Prisma__ShareholderClient<$Result.GetResult<Prisma.$ShareholderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareTransaction model
   */ 
  interface ShareTransactionFieldRefs {
    readonly id: FieldRef<"ShareTransaction", 'Int'>
    readonly companyId: FieldRef<"ShareTransaction", 'Int'>
    readonly shareClassId: FieldRef<"ShareTransaction", 'Int'>
    readonly shareholderId: FieldRef<"ShareTransaction", 'Int'>
    readonly type: FieldRef<"ShareTransaction", 'String'>
    readonly transactionDate: FieldRef<"ShareTransaction", 'DateTime'>
    readonly quantity: FieldRef<"ShareTransaction", 'Decimal'>
    readonly pricePerShare: FieldRef<"ShareTransaction", 'Decimal'>
    readonly considerationPaid: FieldRef<"ShareTransaction", 'Decimal'>
    readonly fairMarketValue: FieldRef<"ShareTransaction", 'Decimal'>
    readonly notes: FieldRef<"ShareTransaction", 'String'>
    readonly createdAt: FieldRef<"ShareTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"ShareTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareTransaction findUnique
   */
  export type ShareTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransaction to fetch.
     */
    where: ShareTransactionWhereUniqueInput
  }

  /**
   * ShareTransaction findUniqueOrThrow
   */
  export type ShareTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransaction to fetch.
     */
    where: ShareTransactionWhereUniqueInput
  }

  /**
   * ShareTransaction findFirst
   */
  export type ShareTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransaction to fetch.
     */
    where?: ShareTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransactions to fetch.
     */
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareTransactions.
     */
    cursor?: ShareTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareTransactions.
     */
    distinct?: ShareTransactionScalarFieldEnum | ShareTransactionScalarFieldEnum[]
  }

  /**
   * ShareTransaction findFirstOrThrow
   */
  export type ShareTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransaction to fetch.
     */
    where?: ShareTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransactions to fetch.
     */
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareTransactions.
     */
    cursor?: ShareTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareTransactions.
     */
    distinct?: ShareTransactionScalarFieldEnum | ShareTransactionScalarFieldEnum[]
  }

  /**
   * ShareTransaction findMany
   */
  export type ShareTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * Filter, which ShareTransactions to fetch.
     */
    where?: ShareTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareTransactions to fetch.
     */
    orderBy?: ShareTransactionOrderByWithRelationInput | ShareTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareTransactions.
     */
    cursor?: ShareTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareTransactions.
     */
    skip?: number
    distinct?: ShareTransactionScalarFieldEnum | ShareTransactionScalarFieldEnum[]
  }

  /**
   * ShareTransaction create
   */
  export type ShareTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareTransaction.
     */
    data: XOR<ShareTransactionCreateInput, ShareTransactionUncheckedCreateInput>
  }

  /**
   * ShareTransaction createMany
   */
  export type ShareTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareTransactions.
     */
    data: ShareTransactionCreateManyInput | ShareTransactionCreateManyInput[]
  }

  /**
   * ShareTransaction createManyAndReturn
   */
  export type ShareTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShareTransactions.
     */
    data: ShareTransactionCreateManyInput | ShareTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareTransaction update
   */
  export type ShareTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareTransaction.
     */
    data: XOR<ShareTransactionUpdateInput, ShareTransactionUncheckedUpdateInput>
    /**
     * Choose, which ShareTransaction to update.
     */
    where: ShareTransactionWhereUniqueInput
  }

  /**
   * ShareTransaction updateMany
   */
  export type ShareTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareTransactions.
     */
    data: XOR<ShareTransactionUpdateManyMutationInput, ShareTransactionUncheckedUpdateManyInput>
    /**
     * Filter which ShareTransactions to update
     */
    where?: ShareTransactionWhereInput
  }

  /**
   * ShareTransaction upsert
   */
  export type ShareTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareTransaction to update in case it exists.
     */
    where: ShareTransactionWhereUniqueInput
    /**
     * In case the ShareTransaction found by the `where` argument doesn't exist, create a new ShareTransaction with this data.
     */
    create: XOR<ShareTransactionCreateInput, ShareTransactionUncheckedCreateInput>
    /**
     * In case the ShareTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareTransactionUpdateInput, ShareTransactionUncheckedUpdateInput>
  }

  /**
   * ShareTransaction delete
   */
  export type ShareTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
    /**
     * Filter which ShareTransaction to delete.
     */
    where: ShareTransactionWhereUniqueInput
  }

  /**
   * ShareTransaction deleteMany
   */
  export type ShareTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareTransactions to delete
     */
    where?: ShareTransactionWhereInput
  }

  /**
   * ShareTransaction without action
   */
  export type ShareTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareTransaction
     */
    select?: ShareTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareTransactionInclude<ExtArgs> | null
  }


  /**
   * Model CorporateStatement
   */

  export type AggregateCorporateStatement = {
    _count: CorporateStatementCountAggregateOutputType | null
    _avg: CorporateStatementAvgAggregateOutputType | null
    _sum: CorporateStatementSumAggregateOutputType | null
    _min: CorporateStatementMinAggregateOutputType | null
    _max: CorporateStatementMaxAggregateOutputType | null
  }

  export type CorporateStatementAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
    totalAssets: Decimal | null
    totalLiabilities: Decimal | null
    totalEquity: Decimal | null
    totalRevenue: Decimal | null
    totalExpenses: Decimal | null
    netIncome: Decimal | null
  }

  export type CorporateStatementSumAggregateOutputType = {
    id: number | null
    companyId: number | null
    totalAssets: Decimal | null
    totalLiabilities: Decimal | null
    totalEquity: Decimal | null
    totalRevenue: Decimal | null
    totalExpenses: Decimal | null
    netIncome: Decimal | null
  }

  export type CorporateStatementMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    statementType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    isAudited: boolean | null
    totalAssets: Decimal | null
    totalLiabilities: Decimal | null
    totalEquity: Decimal | null
    totalRevenue: Decimal | null
    totalExpenses: Decimal | null
    netIncome: Decimal | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateStatementMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    statementType: string | null
    periodStart: Date | null
    periodEnd: Date | null
    isAudited: boolean | null
    totalAssets: Decimal | null
    totalLiabilities: Decimal | null
    totalEquity: Decimal | null
    totalRevenue: Decimal | null
    totalExpenses: Decimal | null
    netIncome: Decimal | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateStatementCountAggregateOutputType = {
    id: number
    companyId: number
    statementType: number
    periodStart: number
    periodEnd: number
    isAudited: number
    totalAssets: number
    totalLiabilities: number
    totalEquity: number
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorporateStatementAvgAggregateInputType = {
    id?: true
    companyId?: true
    totalAssets?: true
    totalLiabilities?: true
    totalEquity?: true
    totalRevenue?: true
    totalExpenses?: true
    netIncome?: true
  }

  export type CorporateStatementSumAggregateInputType = {
    id?: true
    companyId?: true
    totalAssets?: true
    totalLiabilities?: true
    totalEquity?: true
    totalRevenue?: true
    totalExpenses?: true
    netIncome?: true
  }

  export type CorporateStatementMinAggregateInputType = {
    id?: true
    companyId?: true
    statementType?: true
    periodStart?: true
    periodEnd?: true
    isAudited?: true
    totalAssets?: true
    totalLiabilities?: true
    totalEquity?: true
    totalRevenue?: true
    totalExpenses?: true
    netIncome?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateStatementMaxAggregateInputType = {
    id?: true
    companyId?: true
    statementType?: true
    periodStart?: true
    periodEnd?: true
    isAudited?: true
    totalAssets?: true
    totalLiabilities?: true
    totalEquity?: true
    totalRevenue?: true
    totalExpenses?: true
    netIncome?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateStatementCountAggregateInputType = {
    id?: true
    companyId?: true
    statementType?: true
    periodStart?: true
    periodEnd?: true
    isAudited?: true
    totalAssets?: true
    totalLiabilities?: true
    totalEquity?: true
    totalRevenue?: true
    totalExpenses?: true
    netIncome?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorporateStatementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateStatement to aggregate.
     */
    where?: CorporateStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatements to fetch.
     */
    orderBy?: CorporateStatementOrderByWithRelationInput | CorporateStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorporateStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorporateStatements
    **/
    _count?: true | CorporateStatementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorporateStatementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorporateStatementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorporateStatementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorporateStatementMaxAggregateInputType
  }

  export type GetCorporateStatementAggregateType<T extends CorporateStatementAggregateArgs> = {
        [P in keyof T & keyof AggregateCorporateStatement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorporateStatement[P]>
      : GetScalarType<T[P], AggregateCorporateStatement[P]>
  }




  export type CorporateStatementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateStatementWhereInput
    orderBy?: CorporateStatementOrderByWithAggregationInput | CorporateStatementOrderByWithAggregationInput[]
    by: CorporateStatementScalarFieldEnum[] | CorporateStatementScalarFieldEnum
    having?: CorporateStatementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorporateStatementCountAggregateInputType | true
    _avg?: CorporateStatementAvgAggregateInputType
    _sum?: CorporateStatementSumAggregateInputType
    _min?: CorporateStatementMinAggregateInputType
    _max?: CorporateStatementMaxAggregateInputType
  }

  export type CorporateStatementGroupByOutputType = {
    id: number
    companyId: number
    statementType: string
    periodStart: Date
    periodEnd: Date
    isAudited: boolean
    totalAssets: Decimal
    totalLiabilities: Decimal
    totalEquity: Decimal
    totalRevenue: Decimal
    totalExpenses: Decimal
    netIncome: Decimal
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: CorporateStatementCountAggregateOutputType | null
    _avg: CorporateStatementAvgAggregateOutputType | null
    _sum: CorporateStatementSumAggregateOutputType | null
    _min: CorporateStatementMinAggregateOutputType | null
    _max: CorporateStatementMaxAggregateOutputType | null
  }

  type GetCorporateStatementGroupByPayload<T extends CorporateStatementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorporateStatementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorporateStatementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorporateStatementGroupByOutputType[P]>
            : GetScalarType<T[P], CorporateStatementGroupByOutputType[P]>
        }
      >
    >


  export type CorporateStatementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    statementType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    isAudited?: boolean
    totalAssets?: boolean
    totalLiabilities?: boolean
    totalEquity?: boolean
    totalRevenue?: boolean
    totalExpenses?: boolean
    netIncome?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lines?: boolean | CorporateStatement$linesArgs<ExtArgs>
    _count?: boolean | CorporateStatementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateStatement"]>

  export type CorporateStatementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    statementType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    isAudited?: boolean
    totalAssets?: boolean
    totalLiabilities?: boolean
    totalEquity?: boolean
    totalRevenue?: boolean
    totalExpenses?: boolean
    netIncome?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateStatement"]>

  export type CorporateStatementSelectScalar = {
    id?: boolean
    companyId?: boolean
    statementType?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    isAudited?: boolean
    totalAssets?: boolean
    totalLiabilities?: boolean
    totalEquity?: boolean
    totalRevenue?: boolean
    totalExpenses?: boolean
    netIncome?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorporateStatementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    lines?: boolean | CorporateStatement$linesArgs<ExtArgs>
    _count?: boolean | CorporateStatementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CorporateStatementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CorporateStatementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorporateStatement"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      lines: Prisma.$CorporateStatementLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      statementType: string
      periodStart: Date
      periodEnd: Date
      isAudited: boolean
      totalAssets: Prisma.Decimal
      totalLiabilities: Prisma.Decimal
      totalEquity: Prisma.Decimal
      totalRevenue: Prisma.Decimal
      totalExpenses: Prisma.Decimal
      netIncome: Prisma.Decimal
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corporateStatement"]>
    composites: {}
  }

  type CorporateStatementGetPayload<S extends boolean | null | undefined | CorporateStatementDefaultArgs> = $Result.GetResult<Prisma.$CorporateStatementPayload, S>

  type CorporateStatementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CorporateStatementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CorporateStatementCountAggregateInputType | true
    }

  export interface CorporateStatementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorporateStatement'], meta: { name: 'CorporateStatement' } }
    /**
     * Find zero or one CorporateStatement that matches the filter.
     * @param {CorporateStatementFindUniqueArgs} args - Arguments to find a CorporateStatement
     * @example
     * // Get one CorporateStatement
     * const corporateStatement = await prisma.corporateStatement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorporateStatementFindUniqueArgs>(args: SelectSubset<T, CorporateStatementFindUniqueArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CorporateStatement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CorporateStatementFindUniqueOrThrowArgs} args - Arguments to find a CorporateStatement
     * @example
     * // Get one CorporateStatement
     * const corporateStatement = await prisma.corporateStatement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorporateStatementFindUniqueOrThrowArgs>(args: SelectSubset<T, CorporateStatementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CorporateStatement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementFindFirstArgs} args - Arguments to find a CorporateStatement
     * @example
     * // Get one CorporateStatement
     * const corporateStatement = await prisma.corporateStatement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorporateStatementFindFirstArgs>(args?: SelectSubset<T, CorporateStatementFindFirstArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CorporateStatement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementFindFirstOrThrowArgs} args - Arguments to find a CorporateStatement
     * @example
     * // Get one CorporateStatement
     * const corporateStatement = await prisma.corporateStatement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorporateStatementFindFirstOrThrowArgs>(args?: SelectSubset<T, CorporateStatementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CorporateStatements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorporateStatements
     * const corporateStatements = await prisma.corporateStatement.findMany()
     * 
     * // Get first 10 CorporateStatements
     * const corporateStatements = await prisma.corporateStatement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corporateStatementWithIdOnly = await prisma.corporateStatement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorporateStatementFindManyArgs>(args?: SelectSubset<T, CorporateStatementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CorporateStatement.
     * @param {CorporateStatementCreateArgs} args - Arguments to create a CorporateStatement.
     * @example
     * // Create one CorporateStatement
     * const CorporateStatement = await prisma.corporateStatement.create({
     *   data: {
     *     // ... data to create a CorporateStatement
     *   }
     * })
     * 
     */
    create<T extends CorporateStatementCreateArgs>(args: SelectSubset<T, CorporateStatementCreateArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CorporateStatements.
     * @param {CorporateStatementCreateManyArgs} args - Arguments to create many CorporateStatements.
     * @example
     * // Create many CorporateStatements
     * const corporateStatement = await prisma.corporateStatement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorporateStatementCreateManyArgs>(args?: SelectSubset<T, CorporateStatementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorporateStatements and returns the data saved in the database.
     * @param {CorporateStatementCreateManyAndReturnArgs} args - Arguments to create many CorporateStatements.
     * @example
     * // Create many CorporateStatements
     * const corporateStatement = await prisma.corporateStatement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorporateStatements and only return the `id`
     * const corporateStatementWithIdOnly = await prisma.corporateStatement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorporateStatementCreateManyAndReturnArgs>(args?: SelectSubset<T, CorporateStatementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CorporateStatement.
     * @param {CorporateStatementDeleteArgs} args - Arguments to delete one CorporateStatement.
     * @example
     * // Delete one CorporateStatement
     * const CorporateStatement = await prisma.corporateStatement.delete({
     *   where: {
     *     // ... filter to delete one CorporateStatement
     *   }
     * })
     * 
     */
    delete<T extends CorporateStatementDeleteArgs>(args: SelectSubset<T, CorporateStatementDeleteArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CorporateStatement.
     * @param {CorporateStatementUpdateArgs} args - Arguments to update one CorporateStatement.
     * @example
     * // Update one CorporateStatement
     * const corporateStatement = await prisma.corporateStatement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorporateStatementUpdateArgs>(args: SelectSubset<T, CorporateStatementUpdateArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CorporateStatements.
     * @param {CorporateStatementDeleteManyArgs} args - Arguments to filter CorporateStatements to delete.
     * @example
     * // Delete a few CorporateStatements
     * const { count } = await prisma.corporateStatement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorporateStatementDeleteManyArgs>(args?: SelectSubset<T, CorporateStatementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorporateStatements
     * const corporateStatement = await prisma.corporateStatement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorporateStatementUpdateManyArgs>(args: SelectSubset<T, CorporateStatementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CorporateStatement.
     * @param {CorporateStatementUpsertArgs} args - Arguments to update or create a CorporateStatement.
     * @example
     * // Update or create a CorporateStatement
     * const corporateStatement = await prisma.corporateStatement.upsert({
     *   create: {
     *     // ... data to create a CorporateStatement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorporateStatement we want to update
     *   }
     * })
     */
    upsert<T extends CorporateStatementUpsertArgs>(args: SelectSubset<T, CorporateStatementUpsertArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CorporateStatements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementCountArgs} args - Arguments to filter CorporateStatements to count.
     * @example
     * // Count the number of CorporateStatements
     * const count = await prisma.corporateStatement.count({
     *   where: {
     *     // ... the filter for the CorporateStatements we want to count
     *   }
     * })
    **/
    count<T extends CorporateStatementCountArgs>(
      args?: Subset<T, CorporateStatementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorporateStatementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorporateStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorporateStatementAggregateArgs>(args: Subset<T, CorporateStatementAggregateArgs>): Prisma.PrismaPromise<GetCorporateStatementAggregateType<T>>

    /**
     * Group by CorporateStatement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorporateStatementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorporateStatementGroupByArgs['orderBy'] }
        : { orderBy?: CorporateStatementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorporateStatementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorporateStatementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorporateStatement model
   */
  readonly fields: CorporateStatementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorporateStatement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorporateStatementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lines<T extends CorporateStatement$linesArgs<ExtArgs> = {}>(args?: Subset<T, CorporateStatement$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorporateStatement model
   */ 
  interface CorporateStatementFieldRefs {
    readonly id: FieldRef<"CorporateStatement", 'Int'>
    readonly companyId: FieldRef<"CorporateStatement", 'Int'>
    readonly statementType: FieldRef<"CorporateStatement", 'String'>
    readonly periodStart: FieldRef<"CorporateStatement", 'DateTime'>
    readonly periodEnd: FieldRef<"CorporateStatement", 'DateTime'>
    readonly isAudited: FieldRef<"CorporateStatement", 'Boolean'>
    readonly totalAssets: FieldRef<"CorporateStatement", 'Decimal'>
    readonly totalLiabilities: FieldRef<"CorporateStatement", 'Decimal'>
    readonly totalEquity: FieldRef<"CorporateStatement", 'Decimal'>
    readonly totalRevenue: FieldRef<"CorporateStatement", 'Decimal'>
    readonly totalExpenses: FieldRef<"CorporateStatement", 'Decimal'>
    readonly netIncome: FieldRef<"CorporateStatement", 'Decimal'>
    readonly metadata: FieldRef<"CorporateStatement", 'String'>
    readonly createdAt: FieldRef<"CorporateStatement", 'DateTime'>
    readonly updatedAt: FieldRef<"CorporateStatement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorporateStatement findUnique
   */
  export type CorporateStatementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatement to fetch.
     */
    where: CorporateStatementWhereUniqueInput
  }

  /**
   * CorporateStatement findUniqueOrThrow
   */
  export type CorporateStatementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatement to fetch.
     */
    where: CorporateStatementWhereUniqueInput
  }

  /**
   * CorporateStatement findFirst
   */
  export type CorporateStatementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatement to fetch.
     */
    where?: CorporateStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatements to fetch.
     */
    orderBy?: CorporateStatementOrderByWithRelationInput | CorporateStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateStatements.
     */
    cursor?: CorporateStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateStatements.
     */
    distinct?: CorporateStatementScalarFieldEnum | CorporateStatementScalarFieldEnum[]
  }

  /**
   * CorporateStatement findFirstOrThrow
   */
  export type CorporateStatementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatement to fetch.
     */
    where?: CorporateStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatements to fetch.
     */
    orderBy?: CorporateStatementOrderByWithRelationInput | CorporateStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateStatements.
     */
    cursor?: CorporateStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateStatements.
     */
    distinct?: CorporateStatementScalarFieldEnum | CorporateStatementScalarFieldEnum[]
  }

  /**
   * CorporateStatement findMany
   */
  export type CorporateStatementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatements to fetch.
     */
    where?: CorporateStatementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatements to fetch.
     */
    orderBy?: CorporateStatementOrderByWithRelationInput | CorporateStatementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorporateStatements.
     */
    cursor?: CorporateStatementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatements.
     */
    skip?: number
    distinct?: CorporateStatementScalarFieldEnum | CorporateStatementScalarFieldEnum[]
  }

  /**
   * CorporateStatement create
   */
  export type CorporateStatementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * The data needed to create a CorporateStatement.
     */
    data: XOR<CorporateStatementCreateInput, CorporateStatementUncheckedCreateInput>
  }

  /**
   * CorporateStatement createMany
   */
  export type CorporateStatementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorporateStatements.
     */
    data: CorporateStatementCreateManyInput | CorporateStatementCreateManyInput[]
  }

  /**
   * CorporateStatement createManyAndReturn
   */
  export type CorporateStatementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CorporateStatements.
     */
    data: CorporateStatementCreateManyInput | CorporateStatementCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateStatement update
   */
  export type CorporateStatementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * The data needed to update a CorporateStatement.
     */
    data: XOR<CorporateStatementUpdateInput, CorporateStatementUncheckedUpdateInput>
    /**
     * Choose, which CorporateStatement to update.
     */
    where: CorporateStatementWhereUniqueInput
  }

  /**
   * CorporateStatement updateMany
   */
  export type CorporateStatementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorporateStatements.
     */
    data: XOR<CorporateStatementUpdateManyMutationInput, CorporateStatementUncheckedUpdateManyInput>
    /**
     * Filter which CorporateStatements to update
     */
    where?: CorporateStatementWhereInput
  }

  /**
   * CorporateStatement upsert
   */
  export type CorporateStatementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * The filter to search for the CorporateStatement to update in case it exists.
     */
    where: CorporateStatementWhereUniqueInput
    /**
     * In case the CorporateStatement found by the `where` argument doesn't exist, create a new CorporateStatement with this data.
     */
    create: XOR<CorporateStatementCreateInput, CorporateStatementUncheckedCreateInput>
    /**
     * In case the CorporateStatement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorporateStatementUpdateInput, CorporateStatementUncheckedUpdateInput>
  }

  /**
   * CorporateStatement delete
   */
  export type CorporateStatementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
    /**
     * Filter which CorporateStatement to delete.
     */
    where: CorporateStatementWhereUniqueInput
  }

  /**
   * CorporateStatement deleteMany
   */
  export type CorporateStatementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateStatements to delete
     */
    where?: CorporateStatementWhereInput
  }

  /**
   * CorporateStatement.lines
   */
  export type CorporateStatement$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    where?: CorporateStatementLineWhereInput
    orderBy?: CorporateStatementLineOrderByWithRelationInput | CorporateStatementLineOrderByWithRelationInput[]
    cursor?: CorporateStatementLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorporateStatementLineScalarFieldEnum | CorporateStatementLineScalarFieldEnum[]
  }

  /**
   * CorporateStatement without action
   */
  export type CorporateStatementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatement
     */
    select?: CorporateStatementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementInclude<ExtArgs> | null
  }


  /**
   * Model CorporateStatementLine
   */

  export type AggregateCorporateStatementLine = {
    _count: CorporateStatementLineCountAggregateOutputType | null
    _avg: CorporateStatementLineAvgAggregateOutputType | null
    _sum: CorporateStatementLineSumAggregateOutputType | null
    _min: CorporateStatementLineMinAggregateOutputType | null
    _max: CorporateStatementLineMaxAggregateOutputType | null
  }

  export type CorporateStatementLineAvgAggregateOutputType = {
    id: number | null
    statementId: number | null
    amount: Decimal | null
    orderIndex: number | null
  }

  export type CorporateStatementLineSumAggregateOutputType = {
    id: number | null
    statementId: number | null
    amount: Decimal | null
    orderIndex: number | null
  }

  export type CorporateStatementLineMinAggregateOutputType = {
    id: number | null
    statementId: number | null
    category: string | null
    label: string | null
    amount: Decimal | null
    orderIndex: number | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateStatementLineMaxAggregateOutputType = {
    id: number | null
    statementId: number | null
    category: string | null
    label: string | null
    amount: Decimal | null
    orderIndex: number | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateStatementLineCountAggregateOutputType = {
    id: number
    statementId: number
    category: number
    label: number
    amount: number
    orderIndex: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorporateStatementLineAvgAggregateInputType = {
    id?: true
    statementId?: true
    amount?: true
    orderIndex?: true
  }

  export type CorporateStatementLineSumAggregateInputType = {
    id?: true
    statementId?: true
    amount?: true
    orderIndex?: true
  }

  export type CorporateStatementLineMinAggregateInputType = {
    id?: true
    statementId?: true
    category?: true
    label?: true
    amount?: true
    orderIndex?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateStatementLineMaxAggregateInputType = {
    id?: true
    statementId?: true
    category?: true
    label?: true
    amount?: true
    orderIndex?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateStatementLineCountAggregateInputType = {
    id?: true
    statementId?: true
    category?: true
    label?: true
    amount?: true
    orderIndex?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorporateStatementLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateStatementLine to aggregate.
     */
    where?: CorporateStatementLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatementLines to fetch.
     */
    orderBy?: CorporateStatementLineOrderByWithRelationInput | CorporateStatementLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorporateStatementLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatementLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatementLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorporateStatementLines
    **/
    _count?: true | CorporateStatementLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorporateStatementLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorporateStatementLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorporateStatementLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorporateStatementLineMaxAggregateInputType
  }

  export type GetCorporateStatementLineAggregateType<T extends CorporateStatementLineAggregateArgs> = {
        [P in keyof T & keyof AggregateCorporateStatementLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorporateStatementLine[P]>
      : GetScalarType<T[P], AggregateCorporateStatementLine[P]>
  }




  export type CorporateStatementLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateStatementLineWhereInput
    orderBy?: CorporateStatementLineOrderByWithAggregationInput | CorporateStatementLineOrderByWithAggregationInput[]
    by: CorporateStatementLineScalarFieldEnum[] | CorporateStatementLineScalarFieldEnum
    having?: CorporateStatementLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorporateStatementLineCountAggregateInputType | true
    _avg?: CorporateStatementLineAvgAggregateInputType
    _sum?: CorporateStatementLineSumAggregateInputType
    _min?: CorporateStatementLineMinAggregateInputType
    _max?: CorporateStatementLineMaxAggregateInputType
  }

  export type CorporateStatementLineGroupByOutputType = {
    id: number
    statementId: number
    category: string
    label: string
    amount: Decimal
    orderIndex: number
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: CorporateStatementLineCountAggregateOutputType | null
    _avg: CorporateStatementLineAvgAggregateOutputType | null
    _sum: CorporateStatementLineSumAggregateOutputType | null
    _min: CorporateStatementLineMinAggregateOutputType | null
    _max: CorporateStatementLineMaxAggregateOutputType | null
  }

  type GetCorporateStatementLineGroupByPayload<T extends CorporateStatementLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorporateStatementLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorporateStatementLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorporateStatementLineGroupByOutputType[P]>
            : GetScalarType<T[P], CorporateStatementLineGroupByOutputType[P]>
        }
      >
    >


  export type CorporateStatementLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statementId?: boolean
    category?: boolean
    label?: boolean
    amount?: boolean
    orderIndex?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    statement?: boolean | CorporateStatementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateStatementLine"]>

  export type CorporateStatementLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statementId?: boolean
    category?: boolean
    label?: boolean
    amount?: boolean
    orderIndex?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    statement?: boolean | CorporateStatementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateStatementLine"]>

  export type CorporateStatementLineSelectScalar = {
    id?: boolean
    statementId?: boolean
    category?: boolean
    label?: boolean
    amount?: boolean
    orderIndex?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorporateStatementLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statement?: boolean | CorporateStatementDefaultArgs<ExtArgs>
  }
  export type CorporateStatementLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statement?: boolean | CorporateStatementDefaultArgs<ExtArgs>
  }

  export type $CorporateStatementLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorporateStatementLine"
    objects: {
      statement: Prisma.$CorporateStatementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statementId: number
      category: string
      label: string
      amount: Prisma.Decimal
      orderIndex: number
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corporateStatementLine"]>
    composites: {}
  }

  type CorporateStatementLineGetPayload<S extends boolean | null | undefined | CorporateStatementLineDefaultArgs> = $Result.GetResult<Prisma.$CorporateStatementLinePayload, S>

  type CorporateStatementLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CorporateStatementLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CorporateStatementLineCountAggregateInputType | true
    }

  export interface CorporateStatementLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorporateStatementLine'], meta: { name: 'CorporateStatementLine' } }
    /**
     * Find zero or one CorporateStatementLine that matches the filter.
     * @param {CorporateStatementLineFindUniqueArgs} args - Arguments to find a CorporateStatementLine
     * @example
     * // Get one CorporateStatementLine
     * const corporateStatementLine = await prisma.corporateStatementLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorporateStatementLineFindUniqueArgs>(args: SelectSubset<T, CorporateStatementLineFindUniqueArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CorporateStatementLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CorporateStatementLineFindUniqueOrThrowArgs} args - Arguments to find a CorporateStatementLine
     * @example
     * // Get one CorporateStatementLine
     * const corporateStatementLine = await prisma.corporateStatementLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorporateStatementLineFindUniqueOrThrowArgs>(args: SelectSubset<T, CorporateStatementLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CorporateStatementLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineFindFirstArgs} args - Arguments to find a CorporateStatementLine
     * @example
     * // Get one CorporateStatementLine
     * const corporateStatementLine = await prisma.corporateStatementLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorporateStatementLineFindFirstArgs>(args?: SelectSubset<T, CorporateStatementLineFindFirstArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CorporateStatementLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineFindFirstOrThrowArgs} args - Arguments to find a CorporateStatementLine
     * @example
     * // Get one CorporateStatementLine
     * const corporateStatementLine = await prisma.corporateStatementLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorporateStatementLineFindFirstOrThrowArgs>(args?: SelectSubset<T, CorporateStatementLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CorporateStatementLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorporateStatementLines
     * const corporateStatementLines = await prisma.corporateStatementLine.findMany()
     * 
     * // Get first 10 CorporateStatementLines
     * const corporateStatementLines = await prisma.corporateStatementLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corporateStatementLineWithIdOnly = await prisma.corporateStatementLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorporateStatementLineFindManyArgs>(args?: SelectSubset<T, CorporateStatementLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CorporateStatementLine.
     * @param {CorporateStatementLineCreateArgs} args - Arguments to create a CorporateStatementLine.
     * @example
     * // Create one CorporateStatementLine
     * const CorporateStatementLine = await prisma.corporateStatementLine.create({
     *   data: {
     *     // ... data to create a CorporateStatementLine
     *   }
     * })
     * 
     */
    create<T extends CorporateStatementLineCreateArgs>(args: SelectSubset<T, CorporateStatementLineCreateArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CorporateStatementLines.
     * @param {CorporateStatementLineCreateManyArgs} args - Arguments to create many CorporateStatementLines.
     * @example
     * // Create many CorporateStatementLines
     * const corporateStatementLine = await prisma.corporateStatementLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorporateStatementLineCreateManyArgs>(args?: SelectSubset<T, CorporateStatementLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorporateStatementLines and returns the data saved in the database.
     * @param {CorporateStatementLineCreateManyAndReturnArgs} args - Arguments to create many CorporateStatementLines.
     * @example
     * // Create many CorporateStatementLines
     * const corporateStatementLine = await prisma.corporateStatementLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorporateStatementLines and only return the `id`
     * const corporateStatementLineWithIdOnly = await prisma.corporateStatementLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorporateStatementLineCreateManyAndReturnArgs>(args?: SelectSubset<T, CorporateStatementLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CorporateStatementLine.
     * @param {CorporateStatementLineDeleteArgs} args - Arguments to delete one CorporateStatementLine.
     * @example
     * // Delete one CorporateStatementLine
     * const CorporateStatementLine = await prisma.corporateStatementLine.delete({
     *   where: {
     *     // ... filter to delete one CorporateStatementLine
     *   }
     * })
     * 
     */
    delete<T extends CorporateStatementLineDeleteArgs>(args: SelectSubset<T, CorporateStatementLineDeleteArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CorporateStatementLine.
     * @param {CorporateStatementLineUpdateArgs} args - Arguments to update one CorporateStatementLine.
     * @example
     * // Update one CorporateStatementLine
     * const corporateStatementLine = await prisma.corporateStatementLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorporateStatementLineUpdateArgs>(args: SelectSubset<T, CorporateStatementLineUpdateArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CorporateStatementLines.
     * @param {CorporateStatementLineDeleteManyArgs} args - Arguments to filter CorporateStatementLines to delete.
     * @example
     * // Delete a few CorporateStatementLines
     * const { count } = await prisma.corporateStatementLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorporateStatementLineDeleteManyArgs>(args?: SelectSubset<T, CorporateStatementLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateStatementLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorporateStatementLines
     * const corporateStatementLine = await prisma.corporateStatementLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorporateStatementLineUpdateManyArgs>(args: SelectSubset<T, CorporateStatementLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CorporateStatementLine.
     * @param {CorporateStatementLineUpsertArgs} args - Arguments to update or create a CorporateStatementLine.
     * @example
     * // Update or create a CorporateStatementLine
     * const corporateStatementLine = await prisma.corporateStatementLine.upsert({
     *   create: {
     *     // ... data to create a CorporateStatementLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorporateStatementLine we want to update
     *   }
     * })
     */
    upsert<T extends CorporateStatementLineUpsertArgs>(args: SelectSubset<T, CorporateStatementLineUpsertArgs<ExtArgs>>): Prisma__CorporateStatementLineClient<$Result.GetResult<Prisma.$CorporateStatementLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CorporateStatementLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineCountArgs} args - Arguments to filter CorporateStatementLines to count.
     * @example
     * // Count the number of CorporateStatementLines
     * const count = await prisma.corporateStatementLine.count({
     *   where: {
     *     // ... the filter for the CorporateStatementLines we want to count
     *   }
     * })
    **/
    count<T extends CorporateStatementLineCountArgs>(
      args?: Subset<T, CorporateStatementLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorporateStatementLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorporateStatementLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorporateStatementLineAggregateArgs>(args: Subset<T, CorporateStatementLineAggregateArgs>): Prisma.PrismaPromise<GetCorporateStatementLineAggregateType<T>>

    /**
     * Group by CorporateStatementLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateStatementLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorporateStatementLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorporateStatementLineGroupByArgs['orderBy'] }
        : { orderBy?: CorporateStatementLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorporateStatementLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorporateStatementLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorporateStatementLine model
   */
  readonly fields: CorporateStatementLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorporateStatementLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorporateStatementLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    statement<T extends CorporateStatementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CorporateStatementDefaultArgs<ExtArgs>>): Prisma__CorporateStatementClient<$Result.GetResult<Prisma.$CorporateStatementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorporateStatementLine model
   */ 
  interface CorporateStatementLineFieldRefs {
    readonly id: FieldRef<"CorporateStatementLine", 'Int'>
    readonly statementId: FieldRef<"CorporateStatementLine", 'Int'>
    readonly category: FieldRef<"CorporateStatementLine", 'String'>
    readonly label: FieldRef<"CorporateStatementLine", 'String'>
    readonly amount: FieldRef<"CorporateStatementLine", 'Decimal'>
    readonly orderIndex: FieldRef<"CorporateStatementLine", 'Int'>
    readonly metadata: FieldRef<"CorporateStatementLine", 'String'>
    readonly createdAt: FieldRef<"CorporateStatementLine", 'DateTime'>
    readonly updatedAt: FieldRef<"CorporateStatementLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorporateStatementLine findUnique
   */
  export type CorporateStatementLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatementLine to fetch.
     */
    where: CorporateStatementLineWhereUniqueInput
  }

  /**
   * CorporateStatementLine findUniqueOrThrow
   */
  export type CorporateStatementLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatementLine to fetch.
     */
    where: CorporateStatementLineWhereUniqueInput
  }

  /**
   * CorporateStatementLine findFirst
   */
  export type CorporateStatementLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatementLine to fetch.
     */
    where?: CorporateStatementLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatementLines to fetch.
     */
    orderBy?: CorporateStatementLineOrderByWithRelationInput | CorporateStatementLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateStatementLines.
     */
    cursor?: CorporateStatementLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatementLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatementLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateStatementLines.
     */
    distinct?: CorporateStatementLineScalarFieldEnum | CorporateStatementLineScalarFieldEnum[]
  }

  /**
   * CorporateStatementLine findFirstOrThrow
   */
  export type CorporateStatementLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatementLine to fetch.
     */
    where?: CorporateStatementLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatementLines to fetch.
     */
    orderBy?: CorporateStatementLineOrderByWithRelationInput | CorporateStatementLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateStatementLines.
     */
    cursor?: CorporateStatementLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatementLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatementLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateStatementLines.
     */
    distinct?: CorporateStatementLineScalarFieldEnum | CorporateStatementLineScalarFieldEnum[]
  }

  /**
   * CorporateStatementLine findMany
   */
  export type CorporateStatementLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * Filter, which CorporateStatementLines to fetch.
     */
    where?: CorporateStatementLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateStatementLines to fetch.
     */
    orderBy?: CorporateStatementLineOrderByWithRelationInput | CorporateStatementLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorporateStatementLines.
     */
    cursor?: CorporateStatementLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateStatementLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateStatementLines.
     */
    skip?: number
    distinct?: CorporateStatementLineScalarFieldEnum | CorporateStatementLineScalarFieldEnum[]
  }

  /**
   * CorporateStatementLine create
   */
  export type CorporateStatementLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * The data needed to create a CorporateStatementLine.
     */
    data: XOR<CorporateStatementLineCreateInput, CorporateStatementLineUncheckedCreateInput>
  }

  /**
   * CorporateStatementLine createMany
   */
  export type CorporateStatementLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorporateStatementLines.
     */
    data: CorporateStatementLineCreateManyInput | CorporateStatementLineCreateManyInput[]
  }

  /**
   * CorporateStatementLine createManyAndReturn
   */
  export type CorporateStatementLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CorporateStatementLines.
     */
    data: CorporateStatementLineCreateManyInput | CorporateStatementLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateStatementLine update
   */
  export type CorporateStatementLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * The data needed to update a CorporateStatementLine.
     */
    data: XOR<CorporateStatementLineUpdateInput, CorporateStatementLineUncheckedUpdateInput>
    /**
     * Choose, which CorporateStatementLine to update.
     */
    where: CorporateStatementLineWhereUniqueInput
  }

  /**
   * CorporateStatementLine updateMany
   */
  export type CorporateStatementLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorporateStatementLines.
     */
    data: XOR<CorporateStatementLineUpdateManyMutationInput, CorporateStatementLineUncheckedUpdateManyInput>
    /**
     * Filter which CorporateStatementLines to update
     */
    where?: CorporateStatementLineWhereInput
  }

  /**
   * CorporateStatementLine upsert
   */
  export type CorporateStatementLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * The filter to search for the CorporateStatementLine to update in case it exists.
     */
    where: CorporateStatementLineWhereUniqueInput
    /**
     * In case the CorporateStatementLine found by the `where` argument doesn't exist, create a new CorporateStatementLine with this data.
     */
    create: XOR<CorporateStatementLineCreateInput, CorporateStatementLineUncheckedCreateInput>
    /**
     * In case the CorporateStatementLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorporateStatementLineUpdateInput, CorporateStatementLineUncheckedUpdateInput>
  }

  /**
   * CorporateStatementLine delete
   */
  export type CorporateStatementLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
    /**
     * Filter which CorporateStatementLine to delete.
     */
    where: CorporateStatementLineWhereUniqueInput
  }

  /**
   * CorporateStatementLine deleteMany
   */
  export type CorporateStatementLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateStatementLines to delete
     */
    where?: CorporateStatementLineWhereInput
  }

  /**
   * CorporateStatementLine without action
   */
  export type CorporateStatementLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateStatementLine
     */
    select?: CorporateStatementLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateStatementLineInclude<ExtArgs> | null
  }


  /**
   * Model CorporateResolution
   */

  export type AggregateCorporateResolution = {
    _count: CorporateResolutionCountAggregateOutputType | null
    _avg: CorporateResolutionAvgAggregateOutputType | null
    _sum: CorporateResolutionSumAggregateOutputType | null
    _min: CorporateResolutionMinAggregateOutputType | null
    _max: CorporateResolutionMaxAggregateOutputType | null
  }

  export type CorporateResolutionAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CorporateResolutionSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type CorporateResolutionMinAggregateOutputType = {
    id: number | null
    companyId: number | null
    type: string | null
    title: string | null
    resolutionDate: Date | null
    body: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateResolutionMaxAggregateOutputType = {
    id: number | null
    companyId: number | null
    type: string | null
    title: string | null
    resolutionDate: Date | null
    body: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorporateResolutionCountAggregateOutputType = {
    id: number
    companyId: number
    type: number
    title: number
    resolutionDate: number
    body: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorporateResolutionAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CorporateResolutionSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type CorporateResolutionMinAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    title?: true
    resolutionDate?: true
    body?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateResolutionMaxAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    title?: true
    resolutionDate?: true
    body?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorporateResolutionCountAggregateInputType = {
    id?: true
    companyId?: true
    type?: true
    title?: true
    resolutionDate?: true
    body?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorporateResolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateResolution to aggregate.
     */
    where?: CorporateResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateResolutions to fetch.
     */
    orderBy?: CorporateResolutionOrderByWithRelationInput | CorporateResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorporateResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CorporateResolutions
    **/
    _count?: true | CorporateResolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorporateResolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorporateResolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorporateResolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorporateResolutionMaxAggregateInputType
  }

  export type GetCorporateResolutionAggregateType<T extends CorporateResolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateCorporateResolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorporateResolution[P]>
      : GetScalarType<T[P], AggregateCorporateResolution[P]>
  }




  export type CorporateResolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorporateResolutionWhereInput
    orderBy?: CorporateResolutionOrderByWithAggregationInput | CorporateResolutionOrderByWithAggregationInput[]
    by: CorporateResolutionScalarFieldEnum[] | CorporateResolutionScalarFieldEnum
    having?: CorporateResolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorporateResolutionCountAggregateInputType | true
    _avg?: CorporateResolutionAvgAggregateInputType
    _sum?: CorporateResolutionSumAggregateInputType
    _min?: CorporateResolutionMinAggregateInputType
    _max?: CorporateResolutionMaxAggregateInputType
  }

  export type CorporateResolutionGroupByOutputType = {
    id: number
    companyId: number
    type: string
    title: string
    resolutionDate: Date
    body: string | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: CorporateResolutionCountAggregateOutputType | null
    _avg: CorporateResolutionAvgAggregateOutputType | null
    _sum: CorporateResolutionSumAggregateOutputType | null
    _min: CorporateResolutionMinAggregateOutputType | null
    _max: CorporateResolutionMaxAggregateOutputType | null
  }

  type GetCorporateResolutionGroupByPayload<T extends CorporateResolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorporateResolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorporateResolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorporateResolutionGroupByOutputType[P]>
            : GetScalarType<T[P], CorporateResolutionGroupByOutputType[P]>
        }
      >
    >


  export type CorporateResolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    title?: boolean
    resolutionDate?: boolean
    body?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateResolution"]>

  export type CorporateResolutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    type?: boolean
    title?: boolean
    resolutionDate?: boolean
    body?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["corporateResolution"]>

  export type CorporateResolutionSelectScalar = {
    id?: boolean
    companyId?: boolean
    type?: boolean
    title?: boolean
    resolutionDate?: boolean
    body?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorporateResolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CorporateResolutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CorporateResolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CorporateResolution"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyId: number
      type: string
      title: string
      resolutionDate: Date
      body: string | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["corporateResolution"]>
    composites: {}
  }

  type CorporateResolutionGetPayload<S extends boolean | null | undefined | CorporateResolutionDefaultArgs> = $Result.GetResult<Prisma.$CorporateResolutionPayload, S>

  type CorporateResolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CorporateResolutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CorporateResolutionCountAggregateInputType | true
    }

  export interface CorporateResolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CorporateResolution'], meta: { name: 'CorporateResolution' } }
    /**
     * Find zero or one CorporateResolution that matches the filter.
     * @param {CorporateResolutionFindUniqueArgs} args - Arguments to find a CorporateResolution
     * @example
     * // Get one CorporateResolution
     * const corporateResolution = await prisma.corporateResolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorporateResolutionFindUniqueArgs>(args: SelectSubset<T, CorporateResolutionFindUniqueArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CorporateResolution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CorporateResolutionFindUniqueOrThrowArgs} args - Arguments to find a CorporateResolution
     * @example
     * // Get one CorporateResolution
     * const corporateResolution = await prisma.corporateResolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorporateResolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, CorporateResolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CorporateResolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionFindFirstArgs} args - Arguments to find a CorporateResolution
     * @example
     * // Get one CorporateResolution
     * const corporateResolution = await prisma.corporateResolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorporateResolutionFindFirstArgs>(args?: SelectSubset<T, CorporateResolutionFindFirstArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CorporateResolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionFindFirstOrThrowArgs} args - Arguments to find a CorporateResolution
     * @example
     * // Get one CorporateResolution
     * const corporateResolution = await prisma.corporateResolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorporateResolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, CorporateResolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CorporateResolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CorporateResolutions
     * const corporateResolutions = await prisma.corporateResolution.findMany()
     * 
     * // Get first 10 CorporateResolutions
     * const corporateResolutions = await prisma.corporateResolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const corporateResolutionWithIdOnly = await prisma.corporateResolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorporateResolutionFindManyArgs>(args?: SelectSubset<T, CorporateResolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CorporateResolution.
     * @param {CorporateResolutionCreateArgs} args - Arguments to create a CorporateResolution.
     * @example
     * // Create one CorporateResolution
     * const CorporateResolution = await prisma.corporateResolution.create({
     *   data: {
     *     // ... data to create a CorporateResolution
     *   }
     * })
     * 
     */
    create<T extends CorporateResolutionCreateArgs>(args: SelectSubset<T, CorporateResolutionCreateArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CorporateResolutions.
     * @param {CorporateResolutionCreateManyArgs} args - Arguments to create many CorporateResolutions.
     * @example
     * // Create many CorporateResolutions
     * const corporateResolution = await prisma.corporateResolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorporateResolutionCreateManyArgs>(args?: SelectSubset<T, CorporateResolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CorporateResolutions and returns the data saved in the database.
     * @param {CorporateResolutionCreateManyAndReturnArgs} args - Arguments to create many CorporateResolutions.
     * @example
     * // Create many CorporateResolutions
     * const corporateResolution = await prisma.corporateResolution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CorporateResolutions and only return the `id`
     * const corporateResolutionWithIdOnly = await prisma.corporateResolution.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorporateResolutionCreateManyAndReturnArgs>(args?: SelectSubset<T, CorporateResolutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CorporateResolution.
     * @param {CorporateResolutionDeleteArgs} args - Arguments to delete one CorporateResolution.
     * @example
     * // Delete one CorporateResolution
     * const CorporateResolution = await prisma.corporateResolution.delete({
     *   where: {
     *     // ... filter to delete one CorporateResolution
     *   }
     * })
     * 
     */
    delete<T extends CorporateResolutionDeleteArgs>(args: SelectSubset<T, CorporateResolutionDeleteArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CorporateResolution.
     * @param {CorporateResolutionUpdateArgs} args - Arguments to update one CorporateResolution.
     * @example
     * // Update one CorporateResolution
     * const corporateResolution = await prisma.corporateResolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorporateResolutionUpdateArgs>(args: SelectSubset<T, CorporateResolutionUpdateArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CorporateResolutions.
     * @param {CorporateResolutionDeleteManyArgs} args - Arguments to filter CorporateResolutions to delete.
     * @example
     * // Delete a few CorporateResolutions
     * const { count } = await prisma.corporateResolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorporateResolutionDeleteManyArgs>(args?: SelectSubset<T, CorporateResolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CorporateResolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CorporateResolutions
     * const corporateResolution = await prisma.corporateResolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorporateResolutionUpdateManyArgs>(args: SelectSubset<T, CorporateResolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CorporateResolution.
     * @param {CorporateResolutionUpsertArgs} args - Arguments to update or create a CorporateResolution.
     * @example
     * // Update or create a CorporateResolution
     * const corporateResolution = await prisma.corporateResolution.upsert({
     *   create: {
     *     // ... data to create a CorporateResolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CorporateResolution we want to update
     *   }
     * })
     */
    upsert<T extends CorporateResolutionUpsertArgs>(args: SelectSubset<T, CorporateResolutionUpsertArgs<ExtArgs>>): Prisma__CorporateResolutionClient<$Result.GetResult<Prisma.$CorporateResolutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CorporateResolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionCountArgs} args - Arguments to filter CorporateResolutions to count.
     * @example
     * // Count the number of CorporateResolutions
     * const count = await prisma.corporateResolution.count({
     *   where: {
     *     // ... the filter for the CorporateResolutions we want to count
     *   }
     * })
    **/
    count<T extends CorporateResolutionCountArgs>(
      args?: Subset<T, CorporateResolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorporateResolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CorporateResolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorporateResolutionAggregateArgs>(args: Subset<T, CorporateResolutionAggregateArgs>): Prisma.PrismaPromise<GetCorporateResolutionAggregateType<T>>

    /**
     * Group by CorporateResolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorporateResolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorporateResolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorporateResolutionGroupByArgs['orderBy'] }
        : { orderBy?: CorporateResolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorporateResolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorporateResolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CorporateResolution model
   */
  readonly fields: CorporateResolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CorporateResolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorporateResolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CorporateResolution model
   */ 
  interface CorporateResolutionFieldRefs {
    readonly id: FieldRef<"CorporateResolution", 'Int'>
    readonly companyId: FieldRef<"CorporateResolution", 'Int'>
    readonly type: FieldRef<"CorporateResolution", 'String'>
    readonly title: FieldRef<"CorporateResolution", 'String'>
    readonly resolutionDate: FieldRef<"CorporateResolution", 'DateTime'>
    readonly body: FieldRef<"CorporateResolution", 'String'>
    readonly metadata: FieldRef<"CorporateResolution", 'String'>
    readonly createdAt: FieldRef<"CorporateResolution", 'DateTime'>
    readonly updatedAt: FieldRef<"CorporateResolution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CorporateResolution findUnique
   */
  export type CorporateResolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * Filter, which CorporateResolution to fetch.
     */
    where: CorporateResolutionWhereUniqueInput
  }

  /**
   * CorporateResolution findUniqueOrThrow
   */
  export type CorporateResolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * Filter, which CorporateResolution to fetch.
     */
    where: CorporateResolutionWhereUniqueInput
  }

  /**
   * CorporateResolution findFirst
   */
  export type CorporateResolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * Filter, which CorporateResolution to fetch.
     */
    where?: CorporateResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateResolutions to fetch.
     */
    orderBy?: CorporateResolutionOrderByWithRelationInput | CorporateResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateResolutions.
     */
    cursor?: CorporateResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateResolutions.
     */
    distinct?: CorporateResolutionScalarFieldEnum | CorporateResolutionScalarFieldEnum[]
  }

  /**
   * CorporateResolution findFirstOrThrow
   */
  export type CorporateResolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * Filter, which CorporateResolution to fetch.
     */
    where?: CorporateResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateResolutions to fetch.
     */
    orderBy?: CorporateResolutionOrderByWithRelationInput | CorporateResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CorporateResolutions.
     */
    cursor?: CorporateResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CorporateResolutions.
     */
    distinct?: CorporateResolutionScalarFieldEnum | CorporateResolutionScalarFieldEnum[]
  }

  /**
   * CorporateResolution findMany
   */
  export type CorporateResolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * Filter, which CorporateResolutions to fetch.
     */
    where?: CorporateResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CorporateResolutions to fetch.
     */
    orderBy?: CorporateResolutionOrderByWithRelationInput | CorporateResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CorporateResolutions.
     */
    cursor?: CorporateResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CorporateResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CorporateResolutions.
     */
    skip?: number
    distinct?: CorporateResolutionScalarFieldEnum | CorporateResolutionScalarFieldEnum[]
  }

  /**
   * CorporateResolution create
   */
  export type CorporateResolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a CorporateResolution.
     */
    data: XOR<CorporateResolutionCreateInput, CorporateResolutionUncheckedCreateInput>
  }

  /**
   * CorporateResolution createMany
   */
  export type CorporateResolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CorporateResolutions.
     */
    data: CorporateResolutionCreateManyInput | CorporateResolutionCreateManyInput[]
  }

  /**
   * CorporateResolution createManyAndReturn
   */
  export type CorporateResolutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CorporateResolutions.
     */
    data: CorporateResolutionCreateManyInput | CorporateResolutionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CorporateResolution update
   */
  export type CorporateResolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a CorporateResolution.
     */
    data: XOR<CorporateResolutionUpdateInput, CorporateResolutionUncheckedUpdateInput>
    /**
     * Choose, which CorporateResolution to update.
     */
    where: CorporateResolutionWhereUniqueInput
  }

  /**
   * CorporateResolution updateMany
   */
  export type CorporateResolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CorporateResolutions.
     */
    data: XOR<CorporateResolutionUpdateManyMutationInput, CorporateResolutionUncheckedUpdateManyInput>
    /**
     * Filter which CorporateResolutions to update
     */
    where?: CorporateResolutionWhereInput
  }

  /**
   * CorporateResolution upsert
   */
  export type CorporateResolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the CorporateResolution to update in case it exists.
     */
    where: CorporateResolutionWhereUniqueInput
    /**
     * In case the CorporateResolution found by the `where` argument doesn't exist, create a new CorporateResolution with this data.
     */
    create: XOR<CorporateResolutionCreateInput, CorporateResolutionUncheckedCreateInput>
    /**
     * In case the CorporateResolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorporateResolutionUpdateInput, CorporateResolutionUncheckedUpdateInput>
  }

  /**
   * CorporateResolution delete
   */
  export type CorporateResolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
    /**
     * Filter which CorporateResolution to delete.
     */
    where: CorporateResolutionWhereUniqueInput
  }

  /**
   * CorporateResolution deleteMany
   */
  export type CorporateResolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CorporateResolutions to delete
     */
    where?: CorporateResolutionWhereInput
  }

  /**
   * CorporateResolution without action
   */
  export type CorporateResolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CorporateResolution
     */
    select?: CorporateResolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorporateResolutionInclude<ExtArgs> | null
  }


  /**
   * Model PropertyUnit
   */

  export type AggregatePropertyUnit = {
    _count: PropertyUnitCountAggregateOutputType | null
    _avg: PropertyUnitAvgAggregateOutputType | null
    _sum: PropertyUnitSumAggregateOutputType | null
    _min: PropertyUnitMinAggregateOutputType | null
    _max: PropertyUnitMaxAggregateOutputType | null
  }

  export type PropertyUnitAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    squareFeet: number | null
    rentExpected: Decimal | null
  }

  export type PropertyUnitSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    squareFeet: number | null
    rentExpected: Decimal | null
  }

  export type PropertyUnitMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    label: string | null
    squareFeet: number | null
    rentExpected: Decimal | null
  }

  export type PropertyUnitMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    label: string | null
    squareFeet: number | null
    rentExpected: Decimal | null
  }

  export type PropertyUnitCountAggregateOutputType = {
    id: number
    propertyId: number
    label: number
    squareFeet: number
    rentExpected: number
    _all: number
  }


  export type PropertyUnitAvgAggregateInputType = {
    id?: true
    propertyId?: true
    squareFeet?: true
    rentExpected?: true
  }

  export type PropertyUnitSumAggregateInputType = {
    id?: true
    propertyId?: true
    squareFeet?: true
    rentExpected?: true
  }

  export type PropertyUnitMinAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    squareFeet?: true
    rentExpected?: true
  }

  export type PropertyUnitMaxAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    squareFeet?: true
    rentExpected?: true
  }

  export type PropertyUnitCountAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    squareFeet?: true
    rentExpected?: true
    _all?: true
  }

  export type PropertyUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyUnit to aggregate.
     */
    where?: PropertyUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
     */
    orderBy?: PropertyUnitOrderByWithRelationInput | PropertyUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyUnits
    **/
    _count?: true | PropertyUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyUnitMaxAggregateInputType
  }

  export type GetPropertyUnitAggregateType<T extends PropertyUnitAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyUnit[P]>
      : GetScalarType<T[P], AggregatePropertyUnit[P]>
  }




  export type PropertyUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyUnitWhereInput
    orderBy?: PropertyUnitOrderByWithAggregationInput | PropertyUnitOrderByWithAggregationInput[]
    by: PropertyUnitScalarFieldEnum[] | PropertyUnitScalarFieldEnum
    having?: PropertyUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyUnitCountAggregateInputType | true
    _avg?: PropertyUnitAvgAggregateInputType
    _sum?: PropertyUnitSumAggregateInputType
    _min?: PropertyUnitMinAggregateInputType
    _max?: PropertyUnitMaxAggregateInputType
  }

  export type PropertyUnitGroupByOutputType = {
    id: number
    propertyId: number
    label: string
    squareFeet: number | null
    rentExpected: Decimal | null
    _count: PropertyUnitCountAggregateOutputType | null
    _avg: PropertyUnitAvgAggregateOutputType | null
    _sum: PropertyUnitSumAggregateOutputType | null
    _min: PropertyUnitMinAggregateOutputType | null
    _max: PropertyUnitMaxAggregateOutputType | null
  }

  type GetPropertyUnitGroupByPayload<T extends PropertyUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyUnitGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyUnitGroupByOutputType[P]>
        }
      >
    >


  export type PropertyUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    label?: boolean
    squareFeet?: boolean
    rentExpected?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyUnit"]>

  export type PropertyUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    label?: boolean
    squareFeet?: boolean
    rentExpected?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyUnit"]>

  export type PropertyUnitSelectScalar = {
    id?: boolean
    propertyId?: boolean
    label?: boolean
    squareFeet?: boolean
    rentExpected?: boolean
  }

  export type PropertyUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyUnit"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      label: string
      squareFeet: number | null
      rentExpected: Prisma.Decimal | null
    }, ExtArgs["result"]["propertyUnit"]>
    composites: {}
  }

  type PropertyUnitGetPayload<S extends boolean | null | undefined | PropertyUnitDefaultArgs> = $Result.GetResult<Prisma.$PropertyUnitPayload, S>

  type PropertyUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropertyUnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertyUnitCountAggregateInputType | true
    }

  export interface PropertyUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyUnit'], meta: { name: 'PropertyUnit' } }
    /**
     * Find zero or one PropertyUnit that matches the filter.
     * @param {PropertyUnitFindUniqueArgs} args - Arguments to find a PropertyUnit
     * @example
     * // Get one PropertyUnit
     * const propertyUnit = await prisma.propertyUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyUnitFindUniqueArgs>(args: SelectSubset<T, PropertyUnitFindUniqueArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PropertyUnit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropertyUnitFindUniqueOrThrowArgs} args - Arguments to find a PropertyUnit
     * @example
     * // Get one PropertyUnit
     * const propertyUnit = await prisma.propertyUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PropertyUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitFindFirstArgs} args - Arguments to find a PropertyUnit
     * @example
     * // Get one PropertyUnit
     * const propertyUnit = await prisma.propertyUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyUnitFindFirstArgs>(args?: SelectSubset<T, PropertyUnitFindFirstArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PropertyUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitFindFirstOrThrowArgs} args - Arguments to find a PropertyUnit
     * @example
     * // Get one PropertyUnit
     * const propertyUnit = await prisma.propertyUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PropertyUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyUnits
     * const propertyUnits = await prisma.propertyUnit.findMany()
     * 
     * // Get first 10 PropertyUnits
     * const propertyUnits = await prisma.propertyUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyUnitWithIdOnly = await prisma.propertyUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyUnitFindManyArgs>(args?: SelectSubset<T, PropertyUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PropertyUnit.
     * @param {PropertyUnitCreateArgs} args - Arguments to create a PropertyUnit.
     * @example
     * // Create one PropertyUnit
     * const PropertyUnit = await prisma.propertyUnit.create({
     *   data: {
     *     // ... data to create a PropertyUnit
     *   }
     * })
     * 
     */
    create<T extends PropertyUnitCreateArgs>(args: SelectSubset<T, PropertyUnitCreateArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PropertyUnits.
     * @param {PropertyUnitCreateManyArgs} args - Arguments to create many PropertyUnits.
     * @example
     * // Create many PropertyUnits
     * const propertyUnit = await prisma.propertyUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyUnitCreateManyArgs>(args?: SelectSubset<T, PropertyUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyUnits and returns the data saved in the database.
     * @param {PropertyUnitCreateManyAndReturnArgs} args - Arguments to create many PropertyUnits.
     * @example
     * // Create many PropertyUnits
     * const propertyUnit = await prisma.propertyUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyUnits and only return the `id`
     * const propertyUnitWithIdOnly = await prisma.propertyUnit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PropertyUnit.
     * @param {PropertyUnitDeleteArgs} args - Arguments to delete one PropertyUnit.
     * @example
     * // Delete one PropertyUnit
     * const PropertyUnit = await prisma.propertyUnit.delete({
     *   where: {
     *     // ... filter to delete one PropertyUnit
     *   }
     * })
     * 
     */
    delete<T extends PropertyUnitDeleteArgs>(args: SelectSubset<T, PropertyUnitDeleteArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PropertyUnit.
     * @param {PropertyUnitUpdateArgs} args - Arguments to update one PropertyUnit.
     * @example
     * // Update one PropertyUnit
     * const propertyUnit = await prisma.propertyUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUnitUpdateArgs>(args: SelectSubset<T, PropertyUnitUpdateArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PropertyUnits.
     * @param {PropertyUnitDeleteManyArgs} args - Arguments to filter PropertyUnits to delete.
     * @example
     * // Delete a few PropertyUnits
     * const { count } = await prisma.propertyUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyUnitDeleteManyArgs>(args?: SelectSubset<T, PropertyUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyUnits
     * const propertyUnit = await prisma.propertyUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUnitUpdateManyArgs>(args: SelectSubset<T, PropertyUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyUnit.
     * @param {PropertyUnitUpsertArgs} args - Arguments to update or create a PropertyUnit.
     * @example
     * // Update or create a PropertyUnit
     * const propertyUnit = await prisma.propertyUnit.upsert({
     *   create: {
     *     // ... data to create a PropertyUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyUnit we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUnitUpsertArgs>(args: SelectSubset<T, PropertyUnitUpsertArgs<ExtArgs>>): Prisma__PropertyUnitClient<$Result.GetResult<Prisma.$PropertyUnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PropertyUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitCountArgs} args - Arguments to filter PropertyUnits to count.
     * @example
     * // Count the number of PropertyUnits
     * const count = await prisma.propertyUnit.count({
     *   where: {
     *     // ... the filter for the PropertyUnits we want to count
     *   }
     * })
    **/
    count<T extends PropertyUnitCountArgs>(
      args?: Subset<T, PropertyUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyUnitAggregateArgs>(args: Subset<T, PropertyUnitAggregateArgs>): Prisma.PrismaPromise<GetPropertyUnitAggregateType<T>>

    /**
     * Group by PropertyUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyUnitGroupByArgs['orderBy'] }
        : { orderBy?: PropertyUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyUnit model
   */
  readonly fields: PropertyUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyUnit model
   */ 
  interface PropertyUnitFieldRefs {
    readonly id: FieldRef<"PropertyUnit", 'Int'>
    readonly propertyId: FieldRef<"PropertyUnit", 'Int'>
    readonly label: FieldRef<"PropertyUnit", 'String'>
    readonly squareFeet: FieldRef<"PropertyUnit", 'Int'>
    readonly rentExpected: FieldRef<"PropertyUnit", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PropertyUnit findUnique
   */
  export type PropertyUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * Filter, which PropertyUnit to fetch.
     */
    where: PropertyUnitWhereUniqueInput
  }

  /**
   * PropertyUnit findUniqueOrThrow
   */
  export type PropertyUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * Filter, which PropertyUnit to fetch.
     */
    where: PropertyUnitWhereUniqueInput
  }

  /**
   * PropertyUnit findFirst
   */
  export type PropertyUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * Filter, which PropertyUnit to fetch.
     */
    where?: PropertyUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
     */
    orderBy?: PropertyUnitOrderByWithRelationInput | PropertyUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyUnits.
     */
    cursor?: PropertyUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyUnits.
     */
    distinct?: PropertyUnitScalarFieldEnum | PropertyUnitScalarFieldEnum[]
  }

  /**
   * PropertyUnit findFirstOrThrow
   */
  export type PropertyUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * Filter, which PropertyUnit to fetch.
     */
    where?: PropertyUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
     */
    orderBy?: PropertyUnitOrderByWithRelationInput | PropertyUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyUnits.
     */
    cursor?: PropertyUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyUnits.
     */
    distinct?: PropertyUnitScalarFieldEnum | PropertyUnitScalarFieldEnum[]
  }

  /**
   * PropertyUnit findMany
   */
  export type PropertyUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * Filter, which PropertyUnits to fetch.
     */
    where?: PropertyUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyUnits to fetch.
     */
    orderBy?: PropertyUnitOrderByWithRelationInput | PropertyUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyUnits.
     */
    cursor?: PropertyUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyUnits.
     */
    skip?: number
    distinct?: PropertyUnitScalarFieldEnum | PropertyUnitScalarFieldEnum[]
  }

  /**
   * PropertyUnit create
   */
  export type PropertyUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyUnit.
     */
    data: XOR<PropertyUnitCreateInput, PropertyUnitUncheckedCreateInput>
  }

  /**
   * PropertyUnit createMany
   */
  export type PropertyUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyUnits.
     */
    data: PropertyUnitCreateManyInput | PropertyUnitCreateManyInput[]
  }

  /**
   * PropertyUnit createManyAndReturn
   */
  export type PropertyUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PropertyUnits.
     */
    data: PropertyUnitCreateManyInput | PropertyUnitCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyUnit update
   */
  export type PropertyUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyUnit.
     */
    data: XOR<PropertyUnitUpdateInput, PropertyUnitUncheckedUpdateInput>
    /**
     * Choose, which PropertyUnit to update.
     */
    where: PropertyUnitWhereUniqueInput
  }

  /**
   * PropertyUnit updateMany
   */
  export type PropertyUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyUnits.
     */
    data: XOR<PropertyUnitUpdateManyMutationInput, PropertyUnitUncheckedUpdateManyInput>
    /**
     * Filter which PropertyUnits to update
     */
    where?: PropertyUnitWhereInput
  }

  /**
   * PropertyUnit upsert
   */
  export type PropertyUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyUnit to update in case it exists.
     */
    where: PropertyUnitWhereUniqueInput
    /**
     * In case the PropertyUnit found by the `where` argument doesn't exist, create a new PropertyUnit with this data.
     */
    create: XOR<PropertyUnitCreateInput, PropertyUnitUncheckedCreateInput>
    /**
     * In case the PropertyUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUnitUpdateInput, PropertyUnitUncheckedUpdateInput>
  }

  /**
   * PropertyUnit delete
   */
  export type PropertyUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
    /**
     * Filter which PropertyUnit to delete.
     */
    where: PropertyUnitWhereUniqueInput
  }

  /**
   * PropertyUnit deleteMany
   */
  export type PropertyUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyUnits to delete
     */
    where?: PropertyUnitWhereInput
  }

  /**
   * PropertyUnit without action
   */
  export type PropertyUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyUnit
     */
    select?: PropertyUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyUnitInclude<ExtArgs> | null
  }


  /**
   * Model Mortgage
   */

  export type AggregateMortgage = {
    _count: MortgageCountAggregateOutputType | null
    _avg: MortgageAvgAggregateOutputType | null
    _sum: MortgageSumAggregateOutputType | null
    _min: MortgageMinAggregateOutputType | null
    _max: MortgageMaxAggregateOutputType | null
  }

  export type MortgageAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    principal: Decimal | null
    rateAnnual: Decimal | null
    termMonths: number | null
    amortizationMonths: number | null
    paymentFrequency: number | null
    paymentAmount: Decimal | null
  }

  export type MortgageSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    principal: Decimal | null
    rateAnnual: Decimal | null
    termMonths: number | null
    amortizationMonths: number | null
    paymentFrequency: number | null
    paymentAmount: Decimal | null
  }

  export type MortgageMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    lender: string | null
    principal: Decimal | null
    rateAnnual: Decimal | null
    termMonths: number | null
    amortizationMonths: number | null
    startDate: Date | null
    paymentFrequency: number | null
    paymentAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MortgageMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    lender: string | null
    principal: Decimal | null
    rateAnnual: Decimal | null
    termMonths: number | null
    amortizationMonths: number | null
    startDate: Date | null
    paymentFrequency: number | null
    paymentAmount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MortgageCountAggregateOutputType = {
    id: number
    propertyId: number
    lender: number
    principal: number
    rateAnnual: number
    termMonths: number
    amortizationMonths: number
    startDate: number
    paymentFrequency: number
    paymentAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MortgageAvgAggregateInputType = {
    id?: true
    propertyId?: true
    principal?: true
    rateAnnual?: true
    termMonths?: true
    amortizationMonths?: true
    paymentFrequency?: true
    paymentAmount?: true
  }

  export type MortgageSumAggregateInputType = {
    id?: true
    propertyId?: true
    principal?: true
    rateAnnual?: true
    termMonths?: true
    amortizationMonths?: true
    paymentFrequency?: true
    paymentAmount?: true
  }

  export type MortgageMinAggregateInputType = {
    id?: true
    propertyId?: true
    lender?: true
    principal?: true
    rateAnnual?: true
    termMonths?: true
    amortizationMonths?: true
    startDate?: true
    paymentFrequency?: true
    paymentAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MortgageMaxAggregateInputType = {
    id?: true
    propertyId?: true
    lender?: true
    principal?: true
    rateAnnual?: true
    termMonths?: true
    amortizationMonths?: true
    startDate?: true
    paymentFrequency?: true
    paymentAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MortgageCountAggregateInputType = {
    id?: true
    propertyId?: true
    lender?: true
    principal?: true
    rateAnnual?: true
    termMonths?: true
    amortizationMonths?: true
    startDate?: true
    paymentFrequency?: true
    paymentAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MortgageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mortgage to aggregate.
     */
    where?: MortgageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mortgages to fetch.
     */
    orderBy?: MortgageOrderByWithRelationInput | MortgageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MortgageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mortgages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mortgages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mortgages
    **/
    _count?: true | MortgageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MortgageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MortgageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MortgageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MortgageMaxAggregateInputType
  }

  export type GetMortgageAggregateType<T extends MortgageAggregateArgs> = {
        [P in keyof T & keyof AggregateMortgage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMortgage[P]>
      : GetScalarType<T[P], AggregateMortgage[P]>
  }




  export type MortgageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MortgageWhereInput
    orderBy?: MortgageOrderByWithAggregationInput | MortgageOrderByWithAggregationInput[]
    by: MortgageScalarFieldEnum[] | MortgageScalarFieldEnum
    having?: MortgageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MortgageCountAggregateInputType | true
    _avg?: MortgageAvgAggregateInputType
    _sum?: MortgageSumAggregateInputType
    _min?: MortgageMinAggregateInputType
    _max?: MortgageMaxAggregateInputType
  }

  export type MortgageGroupByOutputType = {
    id: number
    propertyId: number
    lender: string
    principal: Decimal
    rateAnnual: Decimal
    termMonths: number
    amortizationMonths: number
    startDate: Date
    paymentFrequency: number
    paymentAmount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: MortgageCountAggregateOutputType | null
    _avg: MortgageAvgAggregateOutputType | null
    _sum: MortgageSumAggregateOutputType | null
    _min: MortgageMinAggregateOutputType | null
    _max: MortgageMaxAggregateOutputType | null
  }

  type GetMortgageGroupByPayload<T extends MortgageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MortgageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MortgageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MortgageGroupByOutputType[P]>
            : GetScalarType<T[P], MortgageGroupByOutputType[P]>
        }
      >
    >


  export type MortgageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    lender?: boolean
    principal?: boolean
    rateAnnual?: boolean
    termMonths?: boolean
    amortizationMonths?: boolean
    startDate?: boolean
    paymentFrequency?: boolean
    paymentAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    attachments?: boolean | Mortgage$attachmentsArgs<ExtArgs>
    _count?: boolean | MortgageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mortgage"]>

  export type MortgageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    lender?: boolean
    principal?: boolean
    rateAnnual?: boolean
    termMonths?: boolean
    amortizationMonths?: boolean
    startDate?: boolean
    paymentFrequency?: boolean
    paymentAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mortgage"]>

  export type MortgageSelectScalar = {
    id?: boolean
    propertyId?: boolean
    lender?: boolean
    principal?: boolean
    rateAnnual?: boolean
    termMonths?: boolean
    amortizationMonths?: boolean
    startDate?: boolean
    paymentFrequency?: boolean
    paymentAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MortgageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    attachments?: boolean | Mortgage$attachmentsArgs<ExtArgs>
    _count?: boolean | MortgageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MortgageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $MortgagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mortgage"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      lender: string
      principal: Prisma.Decimal
      rateAnnual: Prisma.Decimal
      termMonths: number
      amortizationMonths: number
      startDate: Date
      paymentFrequency: number
      paymentAmount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mortgage"]>
    composites: {}
  }

  type MortgageGetPayload<S extends boolean | null | undefined | MortgageDefaultArgs> = $Result.GetResult<Prisma.$MortgagePayload, S>

  type MortgageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MortgageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MortgageCountAggregateInputType | true
    }

  export interface MortgageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mortgage'], meta: { name: 'Mortgage' } }
    /**
     * Find zero or one Mortgage that matches the filter.
     * @param {MortgageFindUniqueArgs} args - Arguments to find a Mortgage
     * @example
     * // Get one Mortgage
     * const mortgage = await prisma.mortgage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MortgageFindUniqueArgs>(args: SelectSubset<T, MortgageFindUniqueArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mortgage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MortgageFindUniqueOrThrowArgs} args - Arguments to find a Mortgage
     * @example
     * // Get one Mortgage
     * const mortgage = await prisma.mortgage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MortgageFindUniqueOrThrowArgs>(args: SelectSubset<T, MortgageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mortgage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageFindFirstArgs} args - Arguments to find a Mortgage
     * @example
     * // Get one Mortgage
     * const mortgage = await prisma.mortgage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MortgageFindFirstArgs>(args?: SelectSubset<T, MortgageFindFirstArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mortgage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageFindFirstOrThrowArgs} args - Arguments to find a Mortgage
     * @example
     * // Get one Mortgage
     * const mortgage = await prisma.mortgage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MortgageFindFirstOrThrowArgs>(args?: SelectSubset<T, MortgageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mortgages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mortgages
     * const mortgages = await prisma.mortgage.findMany()
     * 
     * // Get first 10 Mortgages
     * const mortgages = await prisma.mortgage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mortgageWithIdOnly = await prisma.mortgage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MortgageFindManyArgs>(args?: SelectSubset<T, MortgageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mortgage.
     * @param {MortgageCreateArgs} args - Arguments to create a Mortgage.
     * @example
     * // Create one Mortgage
     * const Mortgage = await prisma.mortgage.create({
     *   data: {
     *     // ... data to create a Mortgage
     *   }
     * })
     * 
     */
    create<T extends MortgageCreateArgs>(args: SelectSubset<T, MortgageCreateArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mortgages.
     * @param {MortgageCreateManyArgs} args - Arguments to create many Mortgages.
     * @example
     * // Create many Mortgages
     * const mortgage = await prisma.mortgage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MortgageCreateManyArgs>(args?: SelectSubset<T, MortgageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mortgages and returns the data saved in the database.
     * @param {MortgageCreateManyAndReturnArgs} args - Arguments to create many Mortgages.
     * @example
     * // Create many Mortgages
     * const mortgage = await prisma.mortgage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mortgages and only return the `id`
     * const mortgageWithIdOnly = await prisma.mortgage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MortgageCreateManyAndReturnArgs>(args?: SelectSubset<T, MortgageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mortgage.
     * @param {MortgageDeleteArgs} args - Arguments to delete one Mortgage.
     * @example
     * // Delete one Mortgage
     * const Mortgage = await prisma.mortgage.delete({
     *   where: {
     *     // ... filter to delete one Mortgage
     *   }
     * })
     * 
     */
    delete<T extends MortgageDeleteArgs>(args: SelectSubset<T, MortgageDeleteArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mortgage.
     * @param {MortgageUpdateArgs} args - Arguments to update one Mortgage.
     * @example
     * // Update one Mortgage
     * const mortgage = await prisma.mortgage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MortgageUpdateArgs>(args: SelectSubset<T, MortgageUpdateArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mortgages.
     * @param {MortgageDeleteManyArgs} args - Arguments to filter Mortgages to delete.
     * @example
     * // Delete a few Mortgages
     * const { count } = await prisma.mortgage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MortgageDeleteManyArgs>(args?: SelectSubset<T, MortgageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mortgages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mortgages
     * const mortgage = await prisma.mortgage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MortgageUpdateManyArgs>(args: SelectSubset<T, MortgageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mortgage.
     * @param {MortgageUpsertArgs} args - Arguments to update or create a Mortgage.
     * @example
     * // Update or create a Mortgage
     * const mortgage = await prisma.mortgage.upsert({
     *   create: {
     *     // ... data to create a Mortgage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mortgage we want to update
     *   }
     * })
     */
    upsert<T extends MortgageUpsertArgs>(args: SelectSubset<T, MortgageUpsertArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mortgages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageCountArgs} args - Arguments to filter Mortgages to count.
     * @example
     * // Count the number of Mortgages
     * const count = await prisma.mortgage.count({
     *   where: {
     *     // ... the filter for the Mortgages we want to count
     *   }
     * })
    **/
    count<T extends MortgageCountArgs>(
      args?: Subset<T, MortgageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MortgageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mortgage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MortgageAggregateArgs>(args: Subset<T, MortgageAggregateArgs>): Prisma.PrismaPromise<GetMortgageAggregateType<T>>

    /**
     * Group by Mortgage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortgageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MortgageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MortgageGroupByArgs['orderBy'] }
        : { orderBy?: MortgageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MortgageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMortgageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mortgage model
   */
  readonly fields: MortgageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mortgage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MortgageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Mortgage$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Mortgage$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mortgage model
   */ 
  interface MortgageFieldRefs {
    readonly id: FieldRef<"Mortgage", 'Int'>
    readonly propertyId: FieldRef<"Mortgage", 'Int'>
    readonly lender: FieldRef<"Mortgage", 'String'>
    readonly principal: FieldRef<"Mortgage", 'Decimal'>
    readonly rateAnnual: FieldRef<"Mortgage", 'Decimal'>
    readonly termMonths: FieldRef<"Mortgage", 'Int'>
    readonly amortizationMonths: FieldRef<"Mortgage", 'Int'>
    readonly startDate: FieldRef<"Mortgage", 'DateTime'>
    readonly paymentFrequency: FieldRef<"Mortgage", 'Int'>
    readonly paymentAmount: FieldRef<"Mortgage", 'Decimal'>
    readonly createdAt: FieldRef<"Mortgage", 'DateTime'>
    readonly updatedAt: FieldRef<"Mortgage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mortgage findUnique
   */
  export type MortgageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * Filter, which Mortgage to fetch.
     */
    where: MortgageWhereUniqueInput
  }

  /**
   * Mortgage findUniqueOrThrow
   */
  export type MortgageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * Filter, which Mortgage to fetch.
     */
    where: MortgageWhereUniqueInput
  }

  /**
   * Mortgage findFirst
   */
  export type MortgageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * Filter, which Mortgage to fetch.
     */
    where?: MortgageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mortgages to fetch.
     */
    orderBy?: MortgageOrderByWithRelationInput | MortgageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mortgages.
     */
    cursor?: MortgageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mortgages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mortgages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mortgages.
     */
    distinct?: MortgageScalarFieldEnum | MortgageScalarFieldEnum[]
  }

  /**
   * Mortgage findFirstOrThrow
   */
  export type MortgageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * Filter, which Mortgage to fetch.
     */
    where?: MortgageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mortgages to fetch.
     */
    orderBy?: MortgageOrderByWithRelationInput | MortgageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mortgages.
     */
    cursor?: MortgageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mortgages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mortgages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mortgages.
     */
    distinct?: MortgageScalarFieldEnum | MortgageScalarFieldEnum[]
  }

  /**
   * Mortgage findMany
   */
  export type MortgageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * Filter, which Mortgages to fetch.
     */
    where?: MortgageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mortgages to fetch.
     */
    orderBy?: MortgageOrderByWithRelationInput | MortgageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mortgages.
     */
    cursor?: MortgageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mortgages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mortgages.
     */
    skip?: number
    distinct?: MortgageScalarFieldEnum | MortgageScalarFieldEnum[]
  }

  /**
   * Mortgage create
   */
  export type MortgageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * The data needed to create a Mortgage.
     */
    data: XOR<MortgageCreateInput, MortgageUncheckedCreateInput>
  }

  /**
   * Mortgage createMany
   */
  export type MortgageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mortgages.
     */
    data: MortgageCreateManyInput | MortgageCreateManyInput[]
  }

  /**
   * Mortgage createManyAndReturn
   */
  export type MortgageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mortgages.
     */
    data: MortgageCreateManyInput | MortgageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mortgage update
   */
  export type MortgageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * The data needed to update a Mortgage.
     */
    data: XOR<MortgageUpdateInput, MortgageUncheckedUpdateInput>
    /**
     * Choose, which Mortgage to update.
     */
    where: MortgageWhereUniqueInput
  }

  /**
   * Mortgage updateMany
   */
  export type MortgageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mortgages.
     */
    data: XOR<MortgageUpdateManyMutationInput, MortgageUncheckedUpdateManyInput>
    /**
     * Filter which Mortgages to update
     */
    where?: MortgageWhereInput
  }

  /**
   * Mortgage upsert
   */
  export type MortgageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * The filter to search for the Mortgage to update in case it exists.
     */
    where: MortgageWhereUniqueInput
    /**
     * In case the Mortgage found by the `where` argument doesn't exist, create a new Mortgage with this data.
     */
    create: XOR<MortgageCreateInput, MortgageUncheckedCreateInput>
    /**
     * In case the Mortgage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MortgageUpdateInput, MortgageUncheckedUpdateInput>
  }

  /**
   * Mortgage delete
   */
  export type MortgageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    /**
     * Filter which Mortgage to delete.
     */
    where: MortgageWhereUniqueInput
  }

  /**
   * Mortgage deleteMany
   */
  export type MortgageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mortgages to delete
     */
    where?: MortgageWhereInput
  }

  /**
   * Mortgage.attachments
   */
  export type Mortgage$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Mortgage without action
   */
  export type MortgageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
  }


  /**
   * Model Revenue
   */

  export type AggregateRevenue = {
    _count: RevenueCountAggregateOutputType | null
    _avg: RevenueAvgAggregateOutputType | null
    _sum: RevenueSumAggregateOutputType | null
    _min: RevenueMinAggregateOutputType | null
    _max: RevenueMaxAggregateOutputType | null
  }

  export type RevenueAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    amount: Decimal | null
  }

  export type RevenueSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    amount: Decimal | null
  }

  export type RevenueMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    label: string | null
    amount: Decimal | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    label: string | null
    amount: Decimal | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RevenueCountAggregateOutputType = {
    id: number
    propertyId: number
    label: number
    amount: number
    frequency: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RevenueAvgAggregateInputType = {
    id?: true
    propertyId?: true
    amount?: true
  }

  export type RevenueSumAggregateInputType = {
    id?: true
    propertyId?: true
    amount?: true
  }

  export type RevenueMinAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueMaxAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RevenueCountAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RevenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Revenue to aggregate.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Revenues
    **/
    _count?: true | RevenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueMaxAggregateInputType
  }

  export type GetRevenueAggregateType<T extends RevenueAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenue[P]>
      : GetScalarType<T[P], AggregateRevenue[P]>
  }




  export type RevenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueWhereInput
    orderBy?: RevenueOrderByWithAggregationInput | RevenueOrderByWithAggregationInput[]
    by: RevenueScalarFieldEnum[] | RevenueScalarFieldEnum
    having?: RevenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueCountAggregateInputType | true
    _avg?: RevenueAvgAggregateInputType
    _sum?: RevenueSumAggregateInputType
    _min?: RevenueMinAggregateInputType
    _max?: RevenueMaxAggregateInputType
  }

  export type RevenueGroupByOutputType = {
    id: number
    propertyId: number
    label: string
    amount: Decimal
    frequency: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RevenueCountAggregateOutputType | null
    _avg: RevenueAvgAggregateOutputType | null
    _sum: RevenueSumAggregateOutputType | null
    _min: RevenueMinAggregateOutputType | null
    _max: RevenueMaxAggregateOutputType | null
  }

  type GetRevenueGroupByPayload<T extends RevenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueGroupByOutputType[P]>
        }
      >
    >


  export type RevenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    label?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenue"]>

  export type RevenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    label?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenue"]>

  export type RevenueSelectScalar = {
    id?: boolean
    propertyId?: boolean
    label?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RevenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type RevenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $RevenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Revenue"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      label: string
      amount: Prisma.Decimal
      frequency: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["revenue"]>
    composites: {}
  }

  type RevenueGetPayload<S extends boolean | null | undefined | RevenueDefaultArgs> = $Result.GetResult<Prisma.$RevenuePayload, S>

  type RevenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevenueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevenueCountAggregateInputType | true
    }

  export interface RevenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Revenue'], meta: { name: 'Revenue' } }
    /**
     * Find zero or one Revenue that matches the filter.
     * @param {RevenueFindUniqueArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueFindUniqueArgs>(args: SelectSubset<T, RevenueFindUniqueArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Revenue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevenueFindUniqueOrThrowArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Revenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueFindFirstArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueFindFirstArgs>(args?: SelectSubset<T, RevenueFindFirstArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Revenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueFindFirstOrThrowArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Revenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Revenues
     * const revenues = await prisma.revenue.findMany()
     * 
     * // Get first 10 Revenues
     * const revenues = await prisma.revenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueWithIdOnly = await prisma.revenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueFindManyArgs>(args?: SelectSubset<T, RevenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Revenue.
     * @param {RevenueCreateArgs} args - Arguments to create a Revenue.
     * @example
     * // Create one Revenue
     * const Revenue = await prisma.revenue.create({
     *   data: {
     *     // ... data to create a Revenue
     *   }
     * })
     * 
     */
    create<T extends RevenueCreateArgs>(args: SelectSubset<T, RevenueCreateArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Revenues.
     * @param {RevenueCreateManyArgs} args - Arguments to create many Revenues.
     * @example
     * // Create many Revenues
     * const revenue = await prisma.revenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueCreateManyArgs>(args?: SelectSubset<T, RevenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Revenues and returns the data saved in the database.
     * @param {RevenueCreateManyAndReturnArgs} args - Arguments to create many Revenues.
     * @example
     * // Create many Revenues
     * const revenue = await prisma.revenue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Revenues and only return the `id`
     * const revenueWithIdOnly = await prisma.revenue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Revenue.
     * @param {RevenueDeleteArgs} args - Arguments to delete one Revenue.
     * @example
     * // Delete one Revenue
     * const Revenue = await prisma.revenue.delete({
     *   where: {
     *     // ... filter to delete one Revenue
     *   }
     * })
     * 
     */
    delete<T extends RevenueDeleteArgs>(args: SelectSubset<T, RevenueDeleteArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Revenue.
     * @param {RevenueUpdateArgs} args - Arguments to update one Revenue.
     * @example
     * // Update one Revenue
     * const revenue = await prisma.revenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueUpdateArgs>(args: SelectSubset<T, RevenueUpdateArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Revenues.
     * @param {RevenueDeleteManyArgs} args - Arguments to filter Revenues to delete.
     * @example
     * // Delete a few Revenues
     * const { count } = await prisma.revenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueDeleteManyArgs>(args?: SelectSubset<T, RevenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Revenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Revenues
     * const revenue = await prisma.revenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueUpdateManyArgs>(args: SelectSubset<T, RevenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Revenue.
     * @param {RevenueUpsertArgs} args - Arguments to update or create a Revenue.
     * @example
     * // Update or create a Revenue
     * const revenue = await prisma.revenue.upsert({
     *   create: {
     *     // ... data to create a Revenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Revenue we want to update
     *   }
     * })
     */
    upsert<T extends RevenueUpsertArgs>(args: SelectSubset<T, RevenueUpsertArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Revenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueCountArgs} args - Arguments to filter Revenues to count.
     * @example
     * // Count the number of Revenues
     * const count = await prisma.revenue.count({
     *   where: {
     *     // ... the filter for the Revenues we want to count
     *   }
     * })
    **/
    count<T extends RevenueCountArgs>(
      args?: Subset<T, RevenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Revenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueAggregateArgs>(args: Subset<T, RevenueAggregateArgs>): Prisma.PrismaPromise<GetRevenueAggregateType<T>>

    /**
     * Group by Revenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueGroupByArgs['orderBy'] }
        : { orderBy?: RevenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Revenue model
   */
  readonly fields: RevenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Revenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Revenue model
   */ 
  interface RevenueFieldRefs {
    readonly id: FieldRef<"Revenue", 'Int'>
    readonly propertyId: FieldRef<"Revenue", 'Int'>
    readonly label: FieldRef<"Revenue", 'String'>
    readonly amount: FieldRef<"Revenue", 'Decimal'>
    readonly frequency: FieldRef<"Revenue", 'String'>
    readonly startDate: FieldRef<"Revenue", 'DateTime'>
    readonly endDate: FieldRef<"Revenue", 'DateTime'>
    readonly createdAt: FieldRef<"Revenue", 'DateTime'>
    readonly updatedAt: FieldRef<"Revenue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Revenue findUnique
   */
  export type RevenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue findUniqueOrThrow
   */
  export type RevenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue findFirst
   */
  export type RevenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Revenues.
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Revenues.
     */
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Revenue findFirstOrThrow
   */
  export type RevenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Revenues.
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Revenues.
     */
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Revenue findMany
   */
  export type RevenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * Filter, which Revenues to fetch.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Revenues.
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Revenue create
   */
  export type RevenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Revenue.
     */
    data: XOR<RevenueCreateInput, RevenueUncheckedCreateInput>
  }

  /**
   * Revenue createMany
   */
  export type RevenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Revenues.
     */
    data: RevenueCreateManyInput | RevenueCreateManyInput[]
  }

  /**
   * Revenue createManyAndReturn
   */
  export type RevenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Revenues.
     */
    data: RevenueCreateManyInput | RevenueCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Revenue update
   */
  export type RevenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Revenue.
     */
    data: XOR<RevenueUpdateInput, RevenueUncheckedUpdateInput>
    /**
     * Choose, which Revenue to update.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue updateMany
   */
  export type RevenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Revenues.
     */
    data: XOR<RevenueUpdateManyMutationInput, RevenueUncheckedUpdateManyInput>
    /**
     * Filter which Revenues to update
     */
    where?: RevenueWhereInput
  }

  /**
   * Revenue upsert
   */
  export type RevenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Revenue to update in case it exists.
     */
    where: RevenueWhereUniqueInput
    /**
     * In case the Revenue found by the `where` argument doesn't exist, create a new Revenue with this data.
     */
    create: XOR<RevenueCreateInput, RevenueUncheckedCreateInput>
    /**
     * In case the Revenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueUpdateInput, RevenueUncheckedUpdateInput>
  }

  /**
   * Revenue delete
   */
  export type RevenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
    /**
     * Filter which Revenue to delete.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue deleteMany
   */
  export type RevenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Revenues to delete
     */
    where?: RevenueWhereInput
  }

  /**
   * Revenue without action
   */
  export type RevenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    amount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    amount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    label: string | null
    category: string | null
    amount: Decimal | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    label: string | null
    category: string | null
    amount: Decimal | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    propertyId: number
    label: number
    category: number
    amount: number
    frequency: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    propertyId?: true
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    propertyId?: true
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    category?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    category?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    propertyId?: true
    label?: true
    category?: true
    amount?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: number
    propertyId: number
    label: string
    category: string
    amount: Decimal
    frequency: string
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    label?: boolean
    category?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    label?: boolean
    category?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    propertyId?: boolean
    label?: boolean
    category?: boolean
    amount?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      label: string
      category: string
      amount: Prisma.Decimal
      frequency: string
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'Int'>
    readonly propertyId: FieldRef<"Expense", 'Int'>
    readonly label: FieldRef<"Expense", 'String'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly frequency: FieldRef<"Expense", 'String'>
    readonly startDate: FieldRef<"Expense", 'DateTime'>
    readonly endDate: FieldRef<"Expense", 'DateTime'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    amount: Decimal | null
    gst: Decimal | null
    qst: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    amount: Decimal | null
    gst: Decimal | null
    qst: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    invoiceDate: Date | null
    supplier: string | null
    amount: Decimal | null
    category: string | null
    gst: Decimal | null
    qst: Decimal | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    invoiceDate: Date | null
    supplier: string | null
    amount: Decimal | null
    category: string | null
    gst: Decimal | null
    qst: Decimal | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    propertyId: number
    invoiceDate: number
    supplier: number
    amount: number
    category: number
    gst: number
    qst: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    propertyId?: true
    amount?: true
    gst?: true
    qst?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    propertyId?: true
    amount?: true
    gst?: true
    qst?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    propertyId?: true
    invoiceDate?: true
    supplier?: true
    amount?: true
    category?: true
    gst?: true
    qst?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    propertyId?: true
    invoiceDate?: true
    supplier?: true
    amount?: true
    category?: true
    gst?: true
    qst?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    propertyId?: true
    invoiceDate?: true
    supplier?: true
    amount?: true
    category?: true
    gst?: true
    qst?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    propertyId: number
    invoiceDate: Date
    supplier: string
    amount: Decimal
    category: string
    gst: Decimal | null
    qst: Decimal | null
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    invoiceDate?: boolean
    supplier?: boolean
    amount?: boolean
    category?: boolean
    gst?: boolean
    qst?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    invoiceDate?: boolean
    supplier?: boolean
    amount?: boolean
    category?: boolean
    gst?: boolean
    qst?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    propertyId?: boolean
    invoiceDate?: boolean
    supplier?: boolean
    amount?: boolean
    category?: boolean
    gst?: boolean
    qst?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      invoiceDate: Date
      supplier: string
      amount: Prisma.Decimal
      category: string
      gst: Prisma.Decimal | null
      qst: Prisma.Decimal | null
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly propertyId: FieldRef<"Invoice", 'Int'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly supplier: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly category: FieldRef<"Invoice", 'String'>
    readonly gst: FieldRef<"Invoice", 'Decimal'>
    readonly qst: FieldRef<"Invoice", 'Decimal'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    label: string | null
    amount: Decimal | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    label: string | null
    amount: Decimal | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    label: number
    amount: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    label?: true
    amount?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    label?: true
    amount?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    label?: true
    amount?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    label: string
    amount: Decimal
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    label?: boolean
    amount?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    label?: boolean
    amount?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    label?: boolean
    amount?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      label: string
      amount: Prisma.Decimal
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'Int'>
    readonly label: FieldRef<"InvoiceItem", 'String'>
    readonly amount: FieldRef<"InvoiceItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model DepreciationSetting
   */

  export type AggregateDepreciationSetting = {
    _count: DepreciationSettingCountAggregateOutputType | null
    _avg: DepreciationSettingAvgAggregateOutputType | null
    _sum: DepreciationSettingSumAggregateOutputType | null
    _min: DepreciationSettingMinAggregateOutputType | null
    _max: DepreciationSettingMaxAggregateOutputType | null
  }

  export type DepreciationSettingAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    ccaRate: Decimal | null
    openingUcc: Decimal | null
    additions: Decimal | null
    dispositions: Decimal | null
  }

  export type DepreciationSettingSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    ccaRate: Decimal | null
    openingUcc: Decimal | null
    additions: Decimal | null
    dispositions: Decimal | null
  }

  export type DepreciationSettingMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    classCode: string | null
    ccaRate: Decimal | null
    openingUcc: Decimal | null
    additions: Decimal | null
    dispositions: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepreciationSettingMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    classCode: string | null
    ccaRate: Decimal | null
    openingUcc: Decimal | null
    additions: Decimal | null
    dispositions: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepreciationSettingCountAggregateOutputType = {
    id: number
    propertyId: number
    classCode: number
    ccaRate: number
    openingUcc: number
    additions: number
    dispositions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepreciationSettingAvgAggregateInputType = {
    id?: true
    propertyId?: true
    ccaRate?: true
    openingUcc?: true
    additions?: true
    dispositions?: true
  }

  export type DepreciationSettingSumAggregateInputType = {
    id?: true
    propertyId?: true
    ccaRate?: true
    openingUcc?: true
    additions?: true
    dispositions?: true
  }

  export type DepreciationSettingMinAggregateInputType = {
    id?: true
    propertyId?: true
    classCode?: true
    ccaRate?: true
    openingUcc?: true
    additions?: true
    dispositions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepreciationSettingMaxAggregateInputType = {
    id?: true
    propertyId?: true
    classCode?: true
    ccaRate?: true
    openingUcc?: true
    additions?: true
    dispositions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepreciationSettingCountAggregateInputType = {
    id?: true
    propertyId?: true
    classCode?: true
    ccaRate?: true
    openingUcc?: true
    additions?: true
    dispositions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepreciationSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepreciationSetting to aggregate.
     */
    where?: DepreciationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationSettings to fetch.
     */
    orderBy?: DepreciationSettingOrderByWithRelationInput | DepreciationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepreciationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepreciationSettings
    **/
    _count?: true | DepreciationSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepreciationSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepreciationSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepreciationSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepreciationSettingMaxAggregateInputType
  }

  export type GetDepreciationSettingAggregateType<T extends DepreciationSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateDepreciationSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepreciationSetting[P]>
      : GetScalarType<T[P], AggregateDepreciationSetting[P]>
  }




  export type DepreciationSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepreciationSettingWhereInput
    orderBy?: DepreciationSettingOrderByWithAggregationInput | DepreciationSettingOrderByWithAggregationInput[]
    by: DepreciationSettingScalarFieldEnum[] | DepreciationSettingScalarFieldEnum
    having?: DepreciationSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepreciationSettingCountAggregateInputType | true
    _avg?: DepreciationSettingAvgAggregateInputType
    _sum?: DepreciationSettingSumAggregateInputType
    _min?: DepreciationSettingMinAggregateInputType
    _max?: DepreciationSettingMaxAggregateInputType
  }

  export type DepreciationSettingGroupByOutputType = {
    id: number
    propertyId: number
    classCode: string
    ccaRate: Decimal
    openingUcc: Decimal
    additions: Decimal
    dispositions: Decimal
    createdAt: Date
    updatedAt: Date
    _count: DepreciationSettingCountAggregateOutputType | null
    _avg: DepreciationSettingAvgAggregateOutputType | null
    _sum: DepreciationSettingSumAggregateOutputType | null
    _min: DepreciationSettingMinAggregateOutputType | null
    _max: DepreciationSettingMaxAggregateOutputType | null
  }

  type GetDepreciationSettingGroupByPayload<T extends DepreciationSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepreciationSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepreciationSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepreciationSettingGroupByOutputType[P]>
            : GetScalarType<T[P], DepreciationSettingGroupByOutputType[P]>
        }
      >
    >


  export type DepreciationSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    classCode?: boolean
    ccaRate?: boolean
    openingUcc?: boolean
    additions?: boolean
    dispositions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["depreciationSetting"]>

  export type DepreciationSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    classCode?: boolean
    ccaRate?: boolean
    openingUcc?: boolean
    additions?: boolean
    dispositions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["depreciationSetting"]>

  export type DepreciationSettingSelectScalar = {
    id?: boolean
    propertyId?: boolean
    classCode?: boolean
    ccaRate?: boolean
    openingUcc?: boolean
    additions?: boolean
    dispositions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepreciationSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type DepreciationSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $DepreciationSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepreciationSetting"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      classCode: string
      ccaRate: Prisma.Decimal
      openingUcc: Prisma.Decimal
      additions: Prisma.Decimal
      dispositions: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["depreciationSetting"]>
    composites: {}
  }

  type DepreciationSettingGetPayload<S extends boolean | null | undefined | DepreciationSettingDefaultArgs> = $Result.GetResult<Prisma.$DepreciationSettingPayload, S>

  type DepreciationSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepreciationSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepreciationSettingCountAggregateInputType | true
    }

  export interface DepreciationSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepreciationSetting'], meta: { name: 'DepreciationSetting' } }
    /**
     * Find zero or one DepreciationSetting that matches the filter.
     * @param {DepreciationSettingFindUniqueArgs} args - Arguments to find a DepreciationSetting
     * @example
     * // Get one DepreciationSetting
     * const depreciationSetting = await prisma.depreciationSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepreciationSettingFindUniqueArgs>(args: SelectSubset<T, DepreciationSettingFindUniqueArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DepreciationSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepreciationSettingFindUniqueOrThrowArgs} args - Arguments to find a DepreciationSetting
     * @example
     * // Get one DepreciationSetting
     * const depreciationSetting = await prisma.depreciationSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepreciationSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, DepreciationSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DepreciationSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingFindFirstArgs} args - Arguments to find a DepreciationSetting
     * @example
     * // Get one DepreciationSetting
     * const depreciationSetting = await prisma.depreciationSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepreciationSettingFindFirstArgs>(args?: SelectSubset<T, DepreciationSettingFindFirstArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DepreciationSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingFindFirstOrThrowArgs} args - Arguments to find a DepreciationSetting
     * @example
     * // Get one DepreciationSetting
     * const depreciationSetting = await prisma.depreciationSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepreciationSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, DepreciationSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DepreciationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepreciationSettings
     * const depreciationSettings = await prisma.depreciationSetting.findMany()
     * 
     * // Get first 10 DepreciationSettings
     * const depreciationSettings = await prisma.depreciationSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depreciationSettingWithIdOnly = await prisma.depreciationSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepreciationSettingFindManyArgs>(args?: SelectSubset<T, DepreciationSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DepreciationSetting.
     * @param {DepreciationSettingCreateArgs} args - Arguments to create a DepreciationSetting.
     * @example
     * // Create one DepreciationSetting
     * const DepreciationSetting = await prisma.depreciationSetting.create({
     *   data: {
     *     // ... data to create a DepreciationSetting
     *   }
     * })
     * 
     */
    create<T extends DepreciationSettingCreateArgs>(args: SelectSubset<T, DepreciationSettingCreateArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DepreciationSettings.
     * @param {DepreciationSettingCreateManyArgs} args - Arguments to create many DepreciationSettings.
     * @example
     * // Create many DepreciationSettings
     * const depreciationSetting = await prisma.depreciationSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepreciationSettingCreateManyArgs>(args?: SelectSubset<T, DepreciationSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepreciationSettings and returns the data saved in the database.
     * @param {DepreciationSettingCreateManyAndReturnArgs} args - Arguments to create many DepreciationSettings.
     * @example
     * // Create many DepreciationSettings
     * const depreciationSetting = await prisma.depreciationSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepreciationSettings and only return the `id`
     * const depreciationSettingWithIdOnly = await prisma.depreciationSetting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepreciationSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, DepreciationSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DepreciationSetting.
     * @param {DepreciationSettingDeleteArgs} args - Arguments to delete one DepreciationSetting.
     * @example
     * // Delete one DepreciationSetting
     * const DepreciationSetting = await prisma.depreciationSetting.delete({
     *   where: {
     *     // ... filter to delete one DepreciationSetting
     *   }
     * })
     * 
     */
    delete<T extends DepreciationSettingDeleteArgs>(args: SelectSubset<T, DepreciationSettingDeleteArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DepreciationSetting.
     * @param {DepreciationSettingUpdateArgs} args - Arguments to update one DepreciationSetting.
     * @example
     * // Update one DepreciationSetting
     * const depreciationSetting = await prisma.depreciationSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepreciationSettingUpdateArgs>(args: SelectSubset<T, DepreciationSettingUpdateArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DepreciationSettings.
     * @param {DepreciationSettingDeleteManyArgs} args - Arguments to filter DepreciationSettings to delete.
     * @example
     * // Delete a few DepreciationSettings
     * const { count } = await prisma.depreciationSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepreciationSettingDeleteManyArgs>(args?: SelectSubset<T, DepreciationSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepreciationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepreciationSettings
     * const depreciationSetting = await prisma.depreciationSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepreciationSettingUpdateManyArgs>(args: SelectSubset<T, DepreciationSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepreciationSetting.
     * @param {DepreciationSettingUpsertArgs} args - Arguments to update or create a DepreciationSetting.
     * @example
     * // Update or create a DepreciationSetting
     * const depreciationSetting = await prisma.depreciationSetting.upsert({
     *   create: {
     *     // ... data to create a DepreciationSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepreciationSetting we want to update
     *   }
     * })
     */
    upsert<T extends DepreciationSettingUpsertArgs>(args: SelectSubset<T, DepreciationSettingUpsertArgs<ExtArgs>>): Prisma__DepreciationSettingClient<$Result.GetResult<Prisma.$DepreciationSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DepreciationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingCountArgs} args - Arguments to filter DepreciationSettings to count.
     * @example
     * // Count the number of DepreciationSettings
     * const count = await prisma.depreciationSetting.count({
     *   where: {
     *     // ... the filter for the DepreciationSettings we want to count
     *   }
     * })
    **/
    count<T extends DepreciationSettingCountArgs>(
      args?: Subset<T, DepreciationSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepreciationSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepreciationSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepreciationSettingAggregateArgs>(args: Subset<T, DepreciationSettingAggregateArgs>): Prisma.PrismaPromise<GetDepreciationSettingAggregateType<T>>

    /**
     * Group by DepreciationSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepreciationSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepreciationSettingGroupByArgs['orderBy'] }
        : { orderBy?: DepreciationSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepreciationSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepreciationSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepreciationSetting model
   */
  readonly fields: DepreciationSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepreciationSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepreciationSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepreciationSetting model
   */ 
  interface DepreciationSettingFieldRefs {
    readonly id: FieldRef<"DepreciationSetting", 'Int'>
    readonly propertyId: FieldRef<"DepreciationSetting", 'Int'>
    readonly classCode: FieldRef<"DepreciationSetting", 'String'>
    readonly ccaRate: FieldRef<"DepreciationSetting", 'Decimal'>
    readonly openingUcc: FieldRef<"DepreciationSetting", 'Decimal'>
    readonly additions: FieldRef<"DepreciationSetting", 'Decimal'>
    readonly dispositions: FieldRef<"DepreciationSetting", 'Decimal'>
    readonly createdAt: FieldRef<"DepreciationSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"DepreciationSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepreciationSetting findUnique
   */
  export type DepreciationSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationSetting to fetch.
     */
    where: DepreciationSettingWhereUniqueInput
  }

  /**
   * DepreciationSetting findUniqueOrThrow
   */
  export type DepreciationSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationSetting to fetch.
     */
    where: DepreciationSettingWhereUniqueInput
  }

  /**
   * DepreciationSetting findFirst
   */
  export type DepreciationSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationSetting to fetch.
     */
    where?: DepreciationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationSettings to fetch.
     */
    orderBy?: DepreciationSettingOrderByWithRelationInput | DepreciationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepreciationSettings.
     */
    cursor?: DepreciationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepreciationSettings.
     */
    distinct?: DepreciationSettingScalarFieldEnum | DepreciationSettingScalarFieldEnum[]
  }

  /**
   * DepreciationSetting findFirstOrThrow
   */
  export type DepreciationSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationSetting to fetch.
     */
    where?: DepreciationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationSettings to fetch.
     */
    orderBy?: DepreciationSettingOrderByWithRelationInput | DepreciationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepreciationSettings.
     */
    cursor?: DepreciationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepreciationSettings.
     */
    distinct?: DepreciationSettingScalarFieldEnum | DepreciationSettingScalarFieldEnum[]
  }

  /**
   * DepreciationSetting findMany
   */
  export type DepreciationSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationSettings to fetch.
     */
    where?: DepreciationSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationSettings to fetch.
     */
    orderBy?: DepreciationSettingOrderByWithRelationInput | DepreciationSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepreciationSettings.
     */
    cursor?: DepreciationSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationSettings.
     */
    skip?: number
    distinct?: DepreciationSettingScalarFieldEnum | DepreciationSettingScalarFieldEnum[]
  }

  /**
   * DepreciationSetting create
   */
  export type DepreciationSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a DepreciationSetting.
     */
    data: XOR<DepreciationSettingCreateInput, DepreciationSettingUncheckedCreateInput>
  }

  /**
   * DepreciationSetting createMany
   */
  export type DepreciationSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepreciationSettings.
     */
    data: DepreciationSettingCreateManyInput | DepreciationSettingCreateManyInput[]
  }

  /**
   * DepreciationSetting createManyAndReturn
   */
  export type DepreciationSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DepreciationSettings.
     */
    data: DepreciationSettingCreateManyInput | DepreciationSettingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepreciationSetting update
   */
  export type DepreciationSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a DepreciationSetting.
     */
    data: XOR<DepreciationSettingUpdateInput, DepreciationSettingUncheckedUpdateInput>
    /**
     * Choose, which DepreciationSetting to update.
     */
    where: DepreciationSettingWhereUniqueInput
  }

  /**
   * DepreciationSetting updateMany
   */
  export type DepreciationSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepreciationSettings.
     */
    data: XOR<DepreciationSettingUpdateManyMutationInput, DepreciationSettingUncheckedUpdateManyInput>
    /**
     * Filter which DepreciationSettings to update
     */
    where?: DepreciationSettingWhereInput
  }

  /**
   * DepreciationSetting upsert
   */
  export type DepreciationSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the DepreciationSetting to update in case it exists.
     */
    where: DepreciationSettingWhereUniqueInput
    /**
     * In case the DepreciationSetting found by the `where` argument doesn't exist, create a new DepreciationSetting with this data.
     */
    create: XOR<DepreciationSettingCreateInput, DepreciationSettingUncheckedCreateInput>
    /**
     * In case the DepreciationSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepreciationSettingUpdateInput, DepreciationSettingUncheckedUpdateInput>
  }

  /**
   * DepreciationSetting delete
   */
  export type DepreciationSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
    /**
     * Filter which DepreciationSetting to delete.
     */
    where: DepreciationSettingWhereUniqueInput
  }

  /**
   * DepreciationSetting deleteMany
   */
  export type DepreciationSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepreciationSettings to delete
     */
    where?: DepreciationSettingWhereInput
  }

  /**
   * DepreciationSetting without action
   */
  export type DepreciationSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationSetting
     */
    select?: DepreciationSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationSettingInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    companyId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    companyId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    companyId: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    companyId: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    companyId: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
  }

  export type UserRoleSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
  }

  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    companyId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    companyId: number | null
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    company?: boolean | UserRole$companyArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    company?: boolean | UserRole$companyArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    companyId?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    company?: boolean | UserRole$companyArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    company?: boolean | UserRole$companyArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roleId: number
      companyId: number | null
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    company<T extends UserRole$companyArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'Int'>
    readonly userId: FieldRef<"UserRole", 'Int'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly companyId: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole.company
   */
  export type UserRole$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    id: number | null
    propertyId: number | null
    mortgageId: number | null
    size: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    id: number | null
    propertyId: number | null
    mortgageId: number | null
    size: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: number | null
    propertyId: number | null
    mortgageId: number | null
    title: string | null
    filename: string | null
    contentType: string | null
    size: number | null
    storagePath: string | null
    checksum: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: number | null
    propertyId: number | null
    mortgageId: number | null
    title: string | null
    filename: string | null
    contentType: string | null
    size: number | null
    storagePath: string | null
    checksum: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    propertyId: number
    mortgageId: number
    title: number
    filename: number
    contentType: number
    size: number
    storagePath: number
    checksum: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    id?: true
    propertyId?: true
    mortgageId?: true
    size?: true
  }

  export type AttachmentSumAggregateInputType = {
    id?: true
    propertyId?: true
    mortgageId?: true
    size?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    propertyId?: true
    mortgageId?: true
    title?: true
    filename?: true
    contentType?: true
    size?: true
    storagePath?: true
    checksum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    propertyId?: true
    mortgageId?: true
    title?: true
    filename?: true
    contentType?: true
    size?: true
    storagePath?: true
    checksum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    propertyId?: true
    mortgageId?: true
    title?: true
    filename?: true
    contentType?: true
    size?: true
    storagePath?: true
    checksum?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: number
    propertyId: number
    mortgageId: number | null
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    mortgageId?: boolean
    title?: boolean
    filename?: boolean
    contentType?: boolean
    size?: boolean
    storagePath?: boolean
    checksum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    mortgage?: boolean | Attachment$mortgageArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    mortgageId?: boolean
    title?: boolean
    filename?: boolean
    contentType?: boolean
    size?: boolean
    storagePath?: boolean
    checksum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    mortgage?: boolean | Attachment$mortgageArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    propertyId?: boolean
    mortgageId?: boolean
    title?: boolean
    filename?: boolean
    contentType?: boolean
    size?: boolean
    storagePath?: boolean
    checksum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    mortgage?: boolean | Attachment$mortgageArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    mortgage?: boolean | Attachment$mortgageArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      mortgage: Prisma.$MortgagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      propertyId: number
      mortgageId: number | null
      title: string
      filename: string
      contentType: string
      size: number
      storagePath: string
      checksum: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mortgage<T extends Attachment$mortgageArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$mortgageArgs<ExtArgs>>): Prisma__MortgageClient<$Result.GetResult<Prisma.$MortgagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'Int'>
    readonly propertyId: FieldRef<"Attachment", 'Int'>
    readonly mortgageId: FieldRef<"Attachment", 'Int'>
    readonly title: FieldRef<"Attachment", 'String'>
    readonly filename: FieldRef<"Attachment", 'String'>
    readonly contentType: FieldRef<"Attachment", 'String'>
    readonly size: FieldRef<"Attachment", 'Int'>
    readonly storagePath: FieldRef<"Attachment", 'String'>
    readonly checksum: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
    readonly updatedAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment.mortgage
   */
  export type Attachment$mortgageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mortgage
     */
    select?: MortgageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MortgageInclude<ExtArgs> | null
    where?: MortgageWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    name: 'name',
    address: 'address',
    acquisitionDate: 'acquisitionDate',
    purchasePrice: 'purchasePrice',
    currentValue: 'currentValue',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    neq: 'neq',
    fiscalYearEnd: 'fiscalYearEnd',
    province: 'province',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ShareholderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    displayName: 'displayName',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShareholderScalarFieldEnum = (typeof ShareholderScalarFieldEnum)[keyof typeof ShareholderScalarFieldEnum]


  export const CompanyShareholderScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    shareholderId: 'shareholderId',
    role: 'role',
    votingPercent: 'votingPercent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyShareholderScalarFieldEnum = (typeof CompanyShareholderScalarFieldEnum)[keyof typeof CompanyShareholderScalarFieldEnum]


  export const ShareClassScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    code: 'code',
    description: 'description',
    hasVotingRights: 'hasVotingRights',
    participatesInGrowth: 'participatesInGrowth',
    dividendPolicy: 'dividendPolicy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShareClassScalarFieldEnum = (typeof ShareClassScalarFieldEnum)[keyof typeof ShareClassScalarFieldEnum]


  export const ShareTransactionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    shareClassId: 'shareClassId',
    shareholderId: 'shareholderId',
    type: 'type',
    transactionDate: 'transactionDate',
    quantity: 'quantity',
    pricePerShare: 'pricePerShare',
    considerationPaid: 'considerationPaid',
    fairMarketValue: 'fairMarketValue',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShareTransactionScalarFieldEnum = (typeof ShareTransactionScalarFieldEnum)[keyof typeof ShareTransactionScalarFieldEnum]


  export const CorporateStatementScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    statementType: 'statementType',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    isAudited: 'isAudited',
    totalAssets: 'totalAssets',
    totalLiabilities: 'totalLiabilities',
    totalEquity: 'totalEquity',
    totalRevenue: 'totalRevenue',
    totalExpenses: 'totalExpenses',
    netIncome: 'netIncome',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorporateStatementScalarFieldEnum = (typeof CorporateStatementScalarFieldEnum)[keyof typeof CorporateStatementScalarFieldEnum]


  export const CorporateStatementLineScalarFieldEnum: {
    id: 'id',
    statementId: 'statementId',
    category: 'category',
    label: 'label',
    amount: 'amount',
    orderIndex: 'orderIndex',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorporateStatementLineScalarFieldEnum = (typeof CorporateStatementLineScalarFieldEnum)[keyof typeof CorporateStatementLineScalarFieldEnum]


  export const CorporateResolutionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    type: 'type',
    title: 'title',
    resolutionDate: 'resolutionDate',
    body: 'body',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorporateResolutionScalarFieldEnum = (typeof CorporateResolutionScalarFieldEnum)[keyof typeof CorporateResolutionScalarFieldEnum]


  export const PropertyUnitScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    label: 'label',
    squareFeet: 'squareFeet',
    rentExpected: 'rentExpected'
  };

  export type PropertyUnitScalarFieldEnum = (typeof PropertyUnitScalarFieldEnum)[keyof typeof PropertyUnitScalarFieldEnum]


  export const MortgageScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    lender: 'lender',
    principal: 'principal',
    rateAnnual: 'rateAnnual',
    termMonths: 'termMonths',
    amortizationMonths: 'amortizationMonths',
    startDate: 'startDate',
    paymentFrequency: 'paymentFrequency',
    paymentAmount: 'paymentAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MortgageScalarFieldEnum = (typeof MortgageScalarFieldEnum)[keyof typeof MortgageScalarFieldEnum]


  export const RevenueScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    label: 'label',
    amount: 'amount',
    frequency: 'frequency',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RevenueScalarFieldEnum = (typeof RevenueScalarFieldEnum)[keyof typeof RevenueScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    label: 'label',
    category: 'category',
    amount: 'amount',
    frequency: 'frequency',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    invoiceDate: 'invoiceDate',
    supplier: 'supplier',
    amount: 'amount',
    category: 'category',
    gst: 'gst',
    qst: 'qst',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    label: 'label',
    amount: 'amount'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const DepreciationSettingScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    classCode: 'classCode',
    ccaRate: 'ccaRate',
    openingUcc: 'openingUcc',
    additions: 'additions',
    dispositions: 'dispositions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepreciationSettingScalarFieldEnum = (typeof DepreciationSettingScalarFieldEnum)[keyof typeof DepreciationSettingScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    companyId: 'companyId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    mortgageId: 'mortgageId',
    title: 'title',
    filename: 'filename',
    contentType: 'contentType',
    size: 'size',
    storagePath: 'storagePath',
    checksum: 'checksum',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    properties?: PropertyListRelationFilter
    companies?: CompanyListRelationFilter
    shareholders?: ShareholderListRelationFilter
    roles?: UserRoleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
    companies?: CompanyOrderByRelationAggregateInput
    shareholders?: ShareholderOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    properties?: PropertyListRelationFilter
    companies?: CompanyListRelationFilter
    shareholders?: ShareholderListRelationFilter
    roles?: UserRoleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: IntFilter<"Property"> | number
    userId?: IntFilter<"Property"> | number
    companyId?: IntNullableFilter<"Property"> | number | null
    name?: StringFilter<"Property"> | string
    address?: StringNullableFilter<"Property"> | string | null
    acquisitionDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    purchasePrice?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    units?: PropertyUnitListRelationFilter
    mortgages?: MortgageListRelationFilter
    revenues?: RevenueListRelationFilter
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    depreciationInfo?: XOR<DepreciationSettingNullableRelationFilter, DepreciationSettingWhereInput> | null
    attachments?: AttachmentListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    acquisitionDate?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    currentValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    units?: PropertyUnitOrderByRelationAggregateInput
    mortgages?: MortgageOrderByRelationAggregateInput
    revenues?: RevenueOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    depreciationInfo?: DepreciationSettingOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    userId?: IntFilter<"Property"> | number
    companyId?: IntNullableFilter<"Property"> | number | null
    name?: StringFilter<"Property"> | string
    address?: StringNullableFilter<"Property"> | string | null
    acquisitionDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    purchasePrice?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    units?: PropertyUnitListRelationFilter
    mortgages?: MortgageListRelationFilter
    revenues?: RevenueListRelationFilter
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    depreciationInfo?: XOR<DepreciationSettingNullableRelationFilter, DepreciationSettingWhereInput> | null
    attachments?: AttachmentListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    acquisitionDate?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    currentValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Property"> | number
    userId?: IntWithAggregatesFilter<"Property"> | number
    companyId?: IntNullableWithAggregatesFilter<"Property"> | number | null
    name?: StringWithAggregatesFilter<"Property"> | string
    address?: StringNullableWithAggregatesFilter<"Property"> | string | null
    acquisitionDate?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    purchasePrice?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Property"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    userId?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    neq?: StringNullableFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableFilter<"Company"> | Date | string | null
    province?: StringNullableFilter<"Company"> | string | null
    notes?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
    shareholderLinks?: CompanyShareholderListRelationFilter
    shareClasses?: ShareClassListRelationFilter
    shareTransactions?: ShareTransactionListRelationFilter
    statements?: CorporateStatementListRelationFilter
    resolutions?: CorporateResolutionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    neq?: SortOrderInput | SortOrder
    fiscalYearEnd?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
    shareholderLinks?: CompanyShareholderOrderByRelationAggregateInput
    shareClasses?: ShareClassOrderByRelationAggregateInput
    shareTransactions?: ShareTransactionOrderByRelationAggregateInput
    statements?: CorporateStatementOrderByRelationAggregateInput
    resolutions?: CorporateResolutionOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    userId?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    neq?: StringNullableFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableFilter<"Company"> | Date | string | null
    province?: StringNullableFilter<"Company"> | string | null
    notes?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
    shareholderLinks?: CompanyShareholderListRelationFilter
    shareClasses?: ShareClassListRelationFilter
    shareTransactions?: ShareTransactionListRelationFilter
    statements?: CorporateStatementListRelationFilter
    resolutions?: CorporateResolutionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    neq?: SortOrderInput | SortOrder
    fiscalYearEnd?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    userId?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
    neq?: StringNullableWithAggregatesFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    province?: StringNullableWithAggregatesFilter<"Company"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ShareholderWhereInput = {
    AND?: ShareholderWhereInput | ShareholderWhereInput[]
    OR?: ShareholderWhereInput[]
    NOT?: ShareholderWhereInput | ShareholderWhereInput[]
    id?: IntFilter<"Shareholder"> | number
    userId?: IntFilter<"Shareholder"> | number
    type?: StringFilter<"Shareholder"> | string
    displayName?: StringFilter<"Shareholder"> | string
    contactEmail?: StringNullableFilter<"Shareholder"> | string | null
    contactPhone?: StringNullableFilter<"Shareholder"> | string | null
    notes?: StringNullableFilter<"Shareholder"> | string | null
    createdAt?: DateTimeFilter<"Shareholder"> | Date | string
    updatedAt?: DateTimeFilter<"Shareholder"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    companies?: CompanyShareholderListRelationFilter
    shareTransactions?: ShareTransactionListRelationFilter
  }

  export type ShareholderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    companies?: CompanyShareholderOrderByRelationAggregateInput
    shareTransactions?: ShareTransactionOrderByRelationAggregateInput
  }

  export type ShareholderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShareholderWhereInput | ShareholderWhereInput[]
    OR?: ShareholderWhereInput[]
    NOT?: ShareholderWhereInput | ShareholderWhereInput[]
    userId?: IntFilter<"Shareholder"> | number
    type?: StringFilter<"Shareholder"> | string
    displayName?: StringFilter<"Shareholder"> | string
    contactEmail?: StringNullableFilter<"Shareholder"> | string | null
    contactPhone?: StringNullableFilter<"Shareholder"> | string | null
    notes?: StringNullableFilter<"Shareholder"> | string | null
    createdAt?: DateTimeFilter<"Shareholder"> | Date | string
    updatedAt?: DateTimeFilter<"Shareholder"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    companies?: CompanyShareholderListRelationFilter
    shareTransactions?: ShareTransactionListRelationFilter
  }, "id">

  export type ShareholderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShareholderCountOrderByAggregateInput
    _avg?: ShareholderAvgOrderByAggregateInput
    _max?: ShareholderMaxOrderByAggregateInput
    _min?: ShareholderMinOrderByAggregateInput
    _sum?: ShareholderSumOrderByAggregateInput
  }

  export type ShareholderScalarWhereWithAggregatesInput = {
    AND?: ShareholderScalarWhereWithAggregatesInput | ShareholderScalarWhereWithAggregatesInput[]
    OR?: ShareholderScalarWhereWithAggregatesInput[]
    NOT?: ShareholderScalarWhereWithAggregatesInput | ShareholderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shareholder"> | number
    userId?: IntWithAggregatesFilter<"Shareholder"> | number
    type?: StringWithAggregatesFilter<"Shareholder"> | string
    displayName?: StringWithAggregatesFilter<"Shareholder"> | string
    contactEmail?: StringNullableWithAggregatesFilter<"Shareholder"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Shareholder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Shareholder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shareholder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shareholder"> | Date | string
  }

  export type CompanyShareholderWhereInput = {
    AND?: CompanyShareholderWhereInput | CompanyShareholderWhereInput[]
    OR?: CompanyShareholderWhereInput[]
    NOT?: CompanyShareholderWhereInput | CompanyShareholderWhereInput[]
    id?: IntFilter<"CompanyShareholder"> | number
    companyId?: IntFilter<"CompanyShareholder"> | number
    shareholderId?: IntFilter<"CompanyShareholder"> | number
    role?: StringNullableFilter<"CompanyShareholder"> | string | null
    votingPercent?: DecimalNullableFilter<"CompanyShareholder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CompanyShareholder"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyShareholder"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    shareholder?: XOR<ShareholderRelationFilter, ShareholderWhereInput>
  }

  export type CompanyShareholderOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    role?: SortOrderInput | SortOrder
    votingPercent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    shareholder?: ShareholderOrderByWithRelationInput
  }

  export type CompanyShareholderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyShareholderWhereInput | CompanyShareholderWhereInput[]
    OR?: CompanyShareholderWhereInput[]
    NOT?: CompanyShareholderWhereInput | CompanyShareholderWhereInput[]
    companyId?: IntFilter<"CompanyShareholder"> | number
    shareholderId?: IntFilter<"CompanyShareholder"> | number
    role?: StringNullableFilter<"CompanyShareholder"> | string | null
    votingPercent?: DecimalNullableFilter<"CompanyShareholder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CompanyShareholder"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyShareholder"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    shareholder?: XOR<ShareholderRelationFilter, ShareholderWhereInput>
  }, "id">

  export type CompanyShareholderOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    role?: SortOrderInput | SortOrder
    votingPercent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyShareholderCountOrderByAggregateInput
    _avg?: CompanyShareholderAvgOrderByAggregateInput
    _max?: CompanyShareholderMaxOrderByAggregateInput
    _min?: CompanyShareholderMinOrderByAggregateInput
    _sum?: CompanyShareholderSumOrderByAggregateInput
  }

  export type CompanyShareholderScalarWhereWithAggregatesInput = {
    AND?: CompanyShareholderScalarWhereWithAggregatesInput | CompanyShareholderScalarWhereWithAggregatesInput[]
    OR?: CompanyShareholderScalarWhereWithAggregatesInput[]
    NOT?: CompanyShareholderScalarWhereWithAggregatesInput | CompanyShareholderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyShareholder"> | number
    companyId?: IntWithAggregatesFilter<"CompanyShareholder"> | number
    shareholderId?: IntWithAggregatesFilter<"CompanyShareholder"> | number
    role?: StringNullableWithAggregatesFilter<"CompanyShareholder"> | string | null
    votingPercent?: DecimalNullableWithAggregatesFilter<"CompanyShareholder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyShareholder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyShareholder"> | Date | string
  }

  export type ShareClassWhereInput = {
    AND?: ShareClassWhereInput | ShareClassWhereInput[]
    OR?: ShareClassWhereInput[]
    NOT?: ShareClassWhereInput | ShareClassWhereInput[]
    id?: IntFilter<"ShareClass"> | number
    companyId?: IntFilter<"ShareClass"> | number
    code?: StringFilter<"ShareClass"> | string
    description?: StringNullableFilter<"ShareClass"> | string | null
    hasVotingRights?: BoolFilter<"ShareClass"> | boolean
    participatesInGrowth?: BoolFilter<"ShareClass"> | boolean
    dividendPolicy?: StringNullableFilter<"ShareClass"> | string | null
    createdAt?: DateTimeFilter<"ShareClass"> | Date | string
    updatedAt?: DateTimeFilter<"ShareClass"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: ShareTransactionListRelationFilter
  }

  export type ShareClassOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    hasVotingRights?: SortOrder
    participatesInGrowth?: SortOrder
    dividendPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    transactions?: ShareTransactionOrderByRelationAggregateInput
  }

  export type ShareClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShareClassWhereInput | ShareClassWhereInput[]
    OR?: ShareClassWhereInput[]
    NOT?: ShareClassWhereInput | ShareClassWhereInput[]
    companyId?: IntFilter<"ShareClass"> | number
    code?: StringFilter<"ShareClass"> | string
    description?: StringNullableFilter<"ShareClass"> | string | null
    hasVotingRights?: BoolFilter<"ShareClass"> | boolean
    participatesInGrowth?: BoolFilter<"ShareClass"> | boolean
    dividendPolicy?: StringNullableFilter<"ShareClass"> | string | null
    createdAt?: DateTimeFilter<"ShareClass"> | Date | string
    updatedAt?: DateTimeFilter<"ShareClass"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    transactions?: ShareTransactionListRelationFilter
  }, "id">

  export type ShareClassOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    hasVotingRights?: SortOrder
    participatesInGrowth?: SortOrder
    dividendPolicy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShareClassCountOrderByAggregateInput
    _avg?: ShareClassAvgOrderByAggregateInput
    _max?: ShareClassMaxOrderByAggregateInput
    _min?: ShareClassMinOrderByAggregateInput
    _sum?: ShareClassSumOrderByAggregateInput
  }

  export type ShareClassScalarWhereWithAggregatesInput = {
    AND?: ShareClassScalarWhereWithAggregatesInput | ShareClassScalarWhereWithAggregatesInput[]
    OR?: ShareClassScalarWhereWithAggregatesInput[]
    NOT?: ShareClassScalarWhereWithAggregatesInput | ShareClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShareClass"> | number
    companyId?: IntWithAggregatesFilter<"ShareClass"> | number
    code?: StringWithAggregatesFilter<"ShareClass"> | string
    description?: StringNullableWithAggregatesFilter<"ShareClass"> | string | null
    hasVotingRights?: BoolWithAggregatesFilter<"ShareClass"> | boolean
    participatesInGrowth?: BoolWithAggregatesFilter<"ShareClass"> | boolean
    dividendPolicy?: StringNullableWithAggregatesFilter<"ShareClass"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShareClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShareClass"> | Date | string
  }

  export type ShareTransactionWhereInput = {
    AND?: ShareTransactionWhereInput | ShareTransactionWhereInput[]
    OR?: ShareTransactionWhereInput[]
    NOT?: ShareTransactionWhereInput | ShareTransactionWhereInput[]
    id?: IntFilter<"ShareTransaction"> | number
    companyId?: IntFilter<"ShareTransaction"> | number
    shareClassId?: IntFilter<"ShareTransaction"> | number
    shareholderId?: IntFilter<"ShareTransaction"> | number
    type?: StringFilter<"ShareTransaction"> | string
    transactionDate?: DateTimeFilter<"ShareTransaction"> | Date | string
    quantity?: DecimalFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string
    pricePerShare?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"ShareTransaction"> | string | null
    createdAt?: DateTimeFilter<"ShareTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"ShareTransaction"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    shareClass?: XOR<ShareClassRelationFilter, ShareClassWhereInput>
    shareholder?: XOR<ShareholderRelationFilter, ShareholderWhereInput>
  }

  export type ShareTransactionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    type?: SortOrder
    transactionDate?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrderInput | SortOrder
    considerationPaid?: SortOrderInput | SortOrder
    fairMarketValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    shareClass?: ShareClassOrderByWithRelationInput
    shareholder?: ShareholderOrderByWithRelationInput
  }

  export type ShareTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShareTransactionWhereInput | ShareTransactionWhereInput[]
    OR?: ShareTransactionWhereInput[]
    NOT?: ShareTransactionWhereInput | ShareTransactionWhereInput[]
    companyId?: IntFilter<"ShareTransaction"> | number
    shareClassId?: IntFilter<"ShareTransaction"> | number
    shareholderId?: IntFilter<"ShareTransaction"> | number
    type?: StringFilter<"ShareTransaction"> | string
    transactionDate?: DateTimeFilter<"ShareTransaction"> | Date | string
    quantity?: DecimalFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string
    pricePerShare?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"ShareTransaction"> | string | null
    createdAt?: DateTimeFilter<"ShareTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"ShareTransaction"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    shareClass?: XOR<ShareClassRelationFilter, ShareClassWhereInput>
    shareholder?: XOR<ShareholderRelationFilter, ShareholderWhereInput>
  }, "id">

  export type ShareTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    type?: SortOrder
    transactionDate?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrderInput | SortOrder
    considerationPaid?: SortOrderInput | SortOrder
    fairMarketValue?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShareTransactionCountOrderByAggregateInput
    _avg?: ShareTransactionAvgOrderByAggregateInput
    _max?: ShareTransactionMaxOrderByAggregateInput
    _min?: ShareTransactionMinOrderByAggregateInput
    _sum?: ShareTransactionSumOrderByAggregateInput
  }

  export type ShareTransactionScalarWhereWithAggregatesInput = {
    AND?: ShareTransactionScalarWhereWithAggregatesInput | ShareTransactionScalarWhereWithAggregatesInput[]
    OR?: ShareTransactionScalarWhereWithAggregatesInput[]
    NOT?: ShareTransactionScalarWhereWithAggregatesInput | ShareTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShareTransaction"> | number
    companyId?: IntWithAggregatesFilter<"ShareTransaction"> | number
    shareClassId?: IntWithAggregatesFilter<"ShareTransaction"> | number
    shareholderId?: IntWithAggregatesFilter<"ShareTransaction"> | number
    type?: StringWithAggregatesFilter<"ShareTransaction"> | string
    transactionDate?: DateTimeWithAggregatesFilter<"ShareTransaction"> | Date | string
    quantity?: DecimalWithAggregatesFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string
    pricePerShare?: DecimalNullableWithAggregatesFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: DecimalNullableWithAggregatesFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: DecimalNullableWithAggregatesFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"ShareTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShareTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShareTransaction"> | Date | string
  }

  export type CorporateStatementWhereInput = {
    AND?: CorporateStatementWhereInput | CorporateStatementWhereInput[]
    OR?: CorporateStatementWhereInput[]
    NOT?: CorporateStatementWhereInput | CorporateStatementWhereInput[]
    id?: IntFilter<"CorporateStatement"> | number
    companyId?: IntFilter<"CorporateStatement"> | number
    statementType?: StringFilter<"CorporateStatement"> | string
    periodStart?: DateTimeFilter<"CorporateStatement"> | Date | string
    periodEnd?: DateTimeFilter<"CorporateStatement"> | Date | string
    isAudited?: BoolFilter<"CorporateStatement"> | boolean
    totalAssets?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    metadata?: StringNullableFilter<"CorporateStatement"> | string | null
    createdAt?: DateTimeFilter<"CorporateStatement"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateStatement"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    lines?: CorporateStatementLineListRelationFilter
  }

  export type CorporateStatementOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    statementType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    isAudited?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    lines?: CorporateStatementLineOrderByRelationAggregateInput
  }

  export type CorporateStatementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorporateStatementWhereInput | CorporateStatementWhereInput[]
    OR?: CorporateStatementWhereInput[]
    NOT?: CorporateStatementWhereInput | CorporateStatementWhereInput[]
    companyId?: IntFilter<"CorporateStatement"> | number
    statementType?: StringFilter<"CorporateStatement"> | string
    periodStart?: DateTimeFilter<"CorporateStatement"> | Date | string
    periodEnd?: DateTimeFilter<"CorporateStatement"> | Date | string
    isAudited?: BoolFilter<"CorporateStatement"> | boolean
    totalAssets?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    metadata?: StringNullableFilter<"CorporateStatement"> | string | null
    createdAt?: DateTimeFilter<"CorporateStatement"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateStatement"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    lines?: CorporateStatementLineListRelationFilter
  }, "id">

  export type CorporateStatementOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    statementType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    isAudited?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorporateStatementCountOrderByAggregateInput
    _avg?: CorporateStatementAvgOrderByAggregateInput
    _max?: CorporateStatementMaxOrderByAggregateInput
    _min?: CorporateStatementMinOrderByAggregateInput
    _sum?: CorporateStatementSumOrderByAggregateInput
  }

  export type CorporateStatementScalarWhereWithAggregatesInput = {
    AND?: CorporateStatementScalarWhereWithAggregatesInput | CorporateStatementScalarWhereWithAggregatesInput[]
    OR?: CorporateStatementScalarWhereWithAggregatesInput[]
    NOT?: CorporateStatementScalarWhereWithAggregatesInput | CorporateStatementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CorporateStatement"> | number
    companyId?: IntWithAggregatesFilter<"CorporateStatement"> | number
    statementType?: StringWithAggregatesFilter<"CorporateStatement"> | string
    periodStart?: DateTimeWithAggregatesFilter<"CorporateStatement"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"CorporateStatement"> | Date | string
    isAudited?: BoolWithAggregatesFilter<"CorporateStatement"> | boolean
    totalAssets?: DecimalWithAggregatesFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalWithAggregatesFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalWithAggregatesFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalWithAggregatesFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalWithAggregatesFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalWithAggregatesFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    metadata?: StringNullableWithAggregatesFilter<"CorporateStatement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CorporateStatement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorporateStatement"> | Date | string
  }

  export type CorporateStatementLineWhereInput = {
    AND?: CorporateStatementLineWhereInput | CorporateStatementLineWhereInput[]
    OR?: CorporateStatementLineWhereInput[]
    NOT?: CorporateStatementLineWhereInput | CorporateStatementLineWhereInput[]
    id?: IntFilter<"CorporateStatementLine"> | number
    statementId?: IntFilter<"CorporateStatementLine"> | number
    category?: StringFilter<"CorporateStatementLine"> | string
    label?: StringFilter<"CorporateStatementLine"> | string
    amount?: DecimalFilter<"CorporateStatementLine"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFilter<"CorporateStatementLine"> | number
    metadata?: StringNullableFilter<"CorporateStatementLine"> | string | null
    createdAt?: DateTimeFilter<"CorporateStatementLine"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateStatementLine"> | Date | string
    statement?: XOR<CorporateStatementRelationFilter, CorporateStatementWhereInput>
  }

  export type CorporateStatementLineOrderByWithRelationInput = {
    id?: SortOrder
    statementId?: SortOrder
    category?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    statement?: CorporateStatementOrderByWithRelationInput
  }

  export type CorporateStatementLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorporateStatementLineWhereInput | CorporateStatementLineWhereInput[]
    OR?: CorporateStatementLineWhereInput[]
    NOT?: CorporateStatementLineWhereInput | CorporateStatementLineWhereInput[]
    statementId?: IntFilter<"CorporateStatementLine"> | number
    category?: StringFilter<"CorporateStatementLine"> | string
    label?: StringFilter<"CorporateStatementLine"> | string
    amount?: DecimalFilter<"CorporateStatementLine"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFilter<"CorporateStatementLine"> | number
    metadata?: StringNullableFilter<"CorporateStatementLine"> | string | null
    createdAt?: DateTimeFilter<"CorporateStatementLine"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateStatementLine"> | Date | string
    statement?: XOR<CorporateStatementRelationFilter, CorporateStatementWhereInput>
  }, "id">

  export type CorporateStatementLineOrderByWithAggregationInput = {
    id?: SortOrder
    statementId?: SortOrder
    category?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorporateStatementLineCountOrderByAggregateInput
    _avg?: CorporateStatementLineAvgOrderByAggregateInput
    _max?: CorporateStatementLineMaxOrderByAggregateInput
    _min?: CorporateStatementLineMinOrderByAggregateInput
    _sum?: CorporateStatementLineSumOrderByAggregateInput
  }

  export type CorporateStatementLineScalarWhereWithAggregatesInput = {
    AND?: CorporateStatementLineScalarWhereWithAggregatesInput | CorporateStatementLineScalarWhereWithAggregatesInput[]
    OR?: CorporateStatementLineScalarWhereWithAggregatesInput[]
    NOT?: CorporateStatementLineScalarWhereWithAggregatesInput | CorporateStatementLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CorporateStatementLine"> | number
    statementId?: IntWithAggregatesFilter<"CorporateStatementLine"> | number
    category?: StringWithAggregatesFilter<"CorporateStatementLine"> | string
    label?: StringWithAggregatesFilter<"CorporateStatementLine"> | string
    amount?: DecimalWithAggregatesFilter<"CorporateStatementLine"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntWithAggregatesFilter<"CorporateStatementLine"> | number
    metadata?: StringNullableWithAggregatesFilter<"CorporateStatementLine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CorporateStatementLine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorporateStatementLine"> | Date | string
  }

  export type CorporateResolutionWhereInput = {
    AND?: CorporateResolutionWhereInput | CorporateResolutionWhereInput[]
    OR?: CorporateResolutionWhereInput[]
    NOT?: CorporateResolutionWhereInput | CorporateResolutionWhereInput[]
    id?: IntFilter<"CorporateResolution"> | number
    companyId?: IntFilter<"CorporateResolution"> | number
    type?: StringFilter<"CorporateResolution"> | string
    title?: StringFilter<"CorporateResolution"> | string
    resolutionDate?: DateTimeFilter<"CorporateResolution"> | Date | string
    body?: StringNullableFilter<"CorporateResolution"> | string | null
    metadata?: StringNullableFilter<"CorporateResolution"> | string | null
    createdAt?: DateTimeFilter<"CorporateResolution"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateResolution"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type CorporateResolutionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    resolutionDate?: SortOrder
    body?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type CorporateResolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CorporateResolutionWhereInput | CorporateResolutionWhereInput[]
    OR?: CorporateResolutionWhereInput[]
    NOT?: CorporateResolutionWhereInput | CorporateResolutionWhereInput[]
    companyId?: IntFilter<"CorporateResolution"> | number
    type?: StringFilter<"CorporateResolution"> | string
    title?: StringFilter<"CorporateResolution"> | string
    resolutionDate?: DateTimeFilter<"CorporateResolution"> | Date | string
    body?: StringNullableFilter<"CorporateResolution"> | string | null
    metadata?: StringNullableFilter<"CorporateResolution"> | string | null
    createdAt?: DateTimeFilter<"CorporateResolution"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateResolution"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type CorporateResolutionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    resolutionDate?: SortOrder
    body?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorporateResolutionCountOrderByAggregateInput
    _avg?: CorporateResolutionAvgOrderByAggregateInput
    _max?: CorporateResolutionMaxOrderByAggregateInput
    _min?: CorporateResolutionMinOrderByAggregateInput
    _sum?: CorporateResolutionSumOrderByAggregateInput
  }

  export type CorporateResolutionScalarWhereWithAggregatesInput = {
    AND?: CorporateResolutionScalarWhereWithAggregatesInput | CorporateResolutionScalarWhereWithAggregatesInput[]
    OR?: CorporateResolutionScalarWhereWithAggregatesInput[]
    NOT?: CorporateResolutionScalarWhereWithAggregatesInput | CorporateResolutionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CorporateResolution"> | number
    companyId?: IntWithAggregatesFilter<"CorporateResolution"> | number
    type?: StringWithAggregatesFilter<"CorporateResolution"> | string
    title?: StringWithAggregatesFilter<"CorporateResolution"> | string
    resolutionDate?: DateTimeWithAggregatesFilter<"CorporateResolution"> | Date | string
    body?: StringNullableWithAggregatesFilter<"CorporateResolution"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"CorporateResolution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CorporateResolution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CorporateResolution"> | Date | string
  }

  export type PropertyUnitWhereInput = {
    AND?: PropertyUnitWhereInput | PropertyUnitWhereInput[]
    OR?: PropertyUnitWhereInput[]
    NOT?: PropertyUnitWhereInput | PropertyUnitWhereInput[]
    id?: IntFilter<"PropertyUnit"> | number
    propertyId?: IntFilter<"PropertyUnit"> | number
    label?: StringFilter<"PropertyUnit"> | string
    squareFeet?: IntNullableFilter<"PropertyUnit"> | number | null
    rentExpected?: DecimalNullableFilter<"PropertyUnit"> | Decimal | DecimalJsLike | number | string | null
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }

  export type PropertyUnitOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    squareFeet?: SortOrderInput | SortOrder
    rentExpected?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropertyUnitWhereInput | PropertyUnitWhereInput[]
    OR?: PropertyUnitWhereInput[]
    NOT?: PropertyUnitWhereInput | PropertyUnitWhereInput[]
    propertyId?: IntFilter<"PropertyUnit"> | number
    label?: StringFilter<"PropertyUnit"> | string
    squareFeet?: IntNullableFilter<"PropertyUnit"> | number | null
    rentExpected?: DecimalNullableFilter<"PropertyUnit"> | Decimal | DecimalJsLike | number | string | null
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyUnitOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    squareFeet?: SortOrderInput | SortOrder
    rentExpected?: SortOrderInput | SortOrder
    _count?: PropertyUnitCountOrderByAggregateInput
    _avg?: PropertyUnitAvgOrderByAggregateInput
    _max?: PropertyUnitMaxOrderByAggregateInput
    _min?: PropertyUnitMinOrderByAggregateInput
    _sum?: PropertyUnitSumOrderByAggregateInput
  }

  export type PropertyUnitScalarWhereWithAggregatesInput = {
    AND?: PropertyUnitScalarWhereWithAggregatesInput | PropertyUnitScalarWhereWithAggregatesInput[]
    OR?: PropertyUnitScalarWhereWithAggregatesInput[]
    NOT?: PropertyUnitScalarWhereWithAggregatesInput | PropertyUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PropertyUnit"> | number
    propertyId?: IntWithAggregatesFilter<"PropertyUnit"> | number
    label?: StringWithAggregatesFilter<"PropertyUnit"> | string
    squareFeet?: IntNullableWithAggregatesFilter<"PropertyUnit"> | number | null
    rentExpected?: DecimalNullableWithAggregatesFilter<"PropertyUnit"> | Decimal | DecimalJsLike | number | string | null
  }

  export type MortgageWhereInput = {
    AND?: MortgageWhereInput | MortgageWhereInput[]
    OR?: MortgageWhereInput[]
    NOT?: MortgageWhereInput | MortgageWhereInput[]
    id?: IntFilter<"Mortgage"> | number
    propertyId?: IntFilter<"Mortgage"> | number
    lender?: StringFilter<"Mortgage"> | string
    principal?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntFilter<"Mortgage"> | number
    amortizationMonths?: IntFilter<"Mortgage"> | number
    startDate?: DateTimeFilter<"Mortgage"> | Date | string
    paymentFrequency?: IntFilter<"Mortgage"> | number
    paymentAmount?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Mortgage"> | Date | string
    updatedAt?: DateTimeFilter<"Mortgage"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    attachments?: AttachmentListRelationFilter
  }

  export type MortgageOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    lender?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    startDate?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type MortgageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MortgageWhereInput | MortgageWhereInput[]
    OR?: MortgageWhereInput[]
    NOT?: MortgageWhereInput | MortgageWhereInput[]
    propertyId?: IntFilter<"Mortgage"> | number
    lender?: StringFilter<"Mortgage"> | string
    principal?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntFilter<"Mortgage"> | number
    amortizationMonths?: IntFilter<"Mortgage"> | number
    startDate?: DateTimeFilter<"Mortgage"> | Date | string
    paymentFrequency?: IntFilter<"Mortgage"> | number
    paymentAmount?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Mortgage"> | Date | string
    updatedAt?: DateTimeFilter<"Mortgage"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    attachments?: AttachmentListRelationFilter
  }, "id">

  export type MortgageOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    lender?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    startDate?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MortgageCountOrderByAggregateInput
    _avg?: MortgageAvgOrderByAggregateInput
    _max?: MortgageMaxOrderByAggregateInput
    _min?: MortgageMinOrderByAggregateInput
    _sum?: MortgageSumOrderByAggregateInput
  }

  export type MortgageScalarWhereWithAggregatesInput = {
    AND?: MortgageScalarWhereWithAggregatesInput | MortgageScalarWhereWithAggregatesInput[]
    OR?: MortgageScalarWhereWithAggregatesInput[]
    NOT?: MortgageScalarWhereWithAggregatesInput | MortgageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mortgage"> | number
    propertyId?: IntWithAggregatesFilter<"Mortgage"> | number
    lender?: StringWithAggregatesFilter<"Mortgage"> | string
    principal?: DecimalWithAggregatesFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalWithAggregatesFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntWithAggregatesFilter<"Mortgage"> | number
    amortizationMonths?: IntWithAggregatesFilter<"Mortgage"> | number
    startDate?: DateTimeWithAggregatesFilter<"Mortgage"> | Date | string
    paymentFrequency?: IntWithAggregatesFilter<"Mortgage"> | number
    paymentAmount?: DecimalWithAggregatesFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Mortgage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mortgage"> | Date | string
  }

  export type RevenueWhereInput = {
    AND?: RevenueWhereInput | RevenueWhereInput[]
    OR?: RevenueWhereInput[]
    NOT?: RevenueWhereInput | RevenueWhereInput[]
    id?: IntFilter<"Revenue"> | number
    propertyId?: IntFilter<"Revenue"> | number
    label?: StringFilter<"Revenue"> | string
    amount?: DecimalFilter<"Revenue"> | Decimal | DecimalJsLike | number | string
    frequency?: StringFilter<"Revenue"> | string
    startDate?: DateTimeFilter<"Revenue"> | Date | string
    endDate?: DateTimeNullableFilter<"Revenue"> | Date | string | null
    createdAt?: DateTimeFilter<"Revenue"> | Date | string
    updatedAt?: DateTimeFilter<"Revenue"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }

  export type RevenueOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type RevenueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RevenueWhereInput | RevenueWhereInput[]
    OR?: RevenueWhereInput[]
    NOT?: RevenueWhereInput | RevenueWhereInput[]
    propertyId?: IntFilter<"Revenue"> | number
    label?: StringFilter<"Revenue"> | string
    amount?: DecimalFilter<"Revenue"> | Decimal | DecimalJsLike | number | string
    frequency?: StringFilter<"Revenue"> | string
    startDate?: DateTimeFilter<"Revenue"> | Date | string
    endDate?: DateTimeNullableFilter<"Revenue"> | Date | string | null
    createdAt?: DateTimeFilter<"Revenue"> | Date | string
    updatedAt?: DateTimeFilter<"Revenue"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }, "id">

  export type RevenueOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RevenueCountOrderByAggregateInput
    _avg?: RevenueAvgOrderByAggregateInput
    _max?: RevenueMaxOrderByAggregateInput
    _min?: RevenueMinOrderByAggregateInput
    _sum?: RevenueSumOrderByAggregateInput
  }

  export type RevenueScalarWhereWithAggregatesInput = {
    AND?: RevenueScalarWhereWithAggregatesInput | RevenueScalarWhereWithAggregatesInput[]
    OR?: RevenueScalarWhereWithAggregatesInput[]
    NOT?: RevenueScalarWhereWithAggregatesInput | RevenueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Revenue"> | number
    propertyId?: IntWithAggregatesFilter<"Revenue"> | number
    label?: StringWithAggregatesFilter<"Revenue"> | string
    amount?: DecimalWithAggregatesFilter<"Revenue"> | Decimal | DecimalJsLike | number | string
    frequency?: StringWithAggregatesFilter<"Revenue"> | string
    startDate?: DateTimeWithAggregatesFilter<"Revenue"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Revenue"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Revenue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Revenue"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: IntFilter<"Expense"> | number
    propertyId?: IntFilter<"Expense"> | number
    label?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    frequency?: StringFilter<"Expense"> | string
    startDate?: DateTimeFilter<"Expense"> | Date | string
    endDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    propertyId?: IntFilter<"Expense"> | number
    label?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    frequency?: StringFilter<"Expense"> | string
    startDate?: DateTimeFilter<"Expense"> | Date | string
    endDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expense"> | number
    propertyId?: IntWithAggregatesFilter<"Expense"> | number
    label?: StringWithAggregatesFilter<"Expense"> | string
    category?: StringWithAggregatesFilter<"Expense"> | string
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    frequency?: StringWithAggregatesFilter<"Expense"> | string
    startDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    propertyId?: IntFilter<"Invoice"> | number
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    supplier?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"Invoice"> | string
    gst?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    qst?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    items?: InvoiceItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    invoiceDate?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    gst?: SortOrderInput | SortOrder
    qst?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    propertyId?: IntFilter<"Invoice"> | number
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    supplier?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"Invoice"> | string
    gst?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    qst?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    items?: InvoiceItemListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    invoiceDate?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    gst?: SortOrderInput | SortOrder
    qst?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    propertyId?: IntWithAggregatesFilter<"Invoice"> | number
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    supplier?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    category?: StringWithAggregatesFilter<"Invoice"> | string
    gst?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    qst?: DecimalNullableWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    label?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: IntFilter<"InvoiceItem"> | number
    label?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"InvoiceItem"> | number
    label?: StringWithAggregatesFilter<"InvoiceItem"> | string
    amount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type DepreciationSettingWhereInput = {
    AND?: DepreciationSettingWhereInput | DepreciationSettingWhereInput[]
    OR?: DepreciationSettingWhereInput[]
    NOT?: DepreciationSettingWhereInput | DepreciationSettingWhereInput[]
    id?: IntFilter<"DepreciationSetting"> | number
    propertyId?: IntFilter<"DepreciationSetting"> | number
    classCode?: StringFilter<"DepreciationSetting"> | string
    ccaRate?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    additions?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"DepreciationSetting"> | Date | string
    updatedAt?: DateTimeFilter<"DepreciationSetting"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }

  export type DepreciationSettingOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    classCode?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type DepreciationSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    propertyId?: number
    AND?: DepreciationSettingWhereInput | DepreciationSettingWhereInput[]
    OR?: DepreciationSettingWhereInput[]
    NOT?: DepreciationSettingWhereInput | DepreciationSettingWhereInput[]
    classCode?: StringFilter<"DepreciationSetting"> | string
    ccaRate?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    additions?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"DepreciationSetting"> | Date | string
    updatedAt?: DateTimeFilter<"DepreciationSetting"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
  }, "id" | "propertyId">

  export type DepreciationSettingOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    classCode?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepreciationSettingCountOrderByAggregateInput
    _avg?: DepreciationSettingAvgOrderByAggregateInput
    _max?: DepreciationSettingMaxOrderByAggregateInput
    _min?: DepreciationSettingMinOrderByAggregateInput
    _sum?: DepreciationSettingSumOrderByAggregateInput
  }

  export type DepreciationSettingScalarWhereWithAggregatesInput = {
    AND?: DepreciationSettingScalarWhereWithAggregatesInput | DepreciationSettingScalarWhereWithAggregatesInput[]
    OR?: DepreciationSettingScalarWhereWithAggregatesInput[]
    NOT?: DepreciationSettingScalarWhereWithAggregatesInput | DepreciationSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DepreciationSetting"> | number
    propertyId?: IntWithAggregatesFilter<"DepreciationSetting"> | number
    classCode?: StringWithAggregatesFilter<"DepreciationSetting"> | string
    ccaRate?: DecimalWithAggregatesFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalWithAggregatesFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    additions?: DecimalWithAggregatesFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalWithAggregatesFilter<"DepreciationSetting"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"DepreciationSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepreciationSetting"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: IntFilter<"UserRole"> | number
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    companyId?: IntNullableFilter<"UserRole"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_roleId_companyId?: UserRoleUserId_roleId_companyIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    companyId?: IntNullableFilter<"UserRole"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    company?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
  }, "id" | "userId_roleId_companyId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRole"> | number
    userId?: IntWithAggregatesFilter<"UserRole"> | number
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    companyId?: IntNullableWithAggregatesFilter<"UserRole"> | number | null
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: IntFilter<"Attachment"> | number
    propertyId?: IntFilter<"Attachment"> | number
    mortgageId?: IntNullableFilter<"Attachment"> | number | null
    title?: StringFilter<"Attachment"> | string
    filename?: StringFilter<"Attachment"> | string
    contentType?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    storagePath?: StringFilter<"Attachment"> | string
    checksum?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    mortgage?: XOR<MortgageNullableRelationFilter, MortgageWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrderInput | SortOrder
    title?: SortOrder
    filename?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    storagePath?: SortOrder
    checksum?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    mortgage?: MortgageOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    propertyId?: IntFilter<"Attachment"> | number
    mortgageId?: IntNullableFilter<"Attachment"> | number | null
    title?: StringFilter<"Attachment"> | string
    filename?: StringFilter<"Attachment"> | string
    contentType?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    storagePath?: StringFilter<"Attachment"> | string
    checksum?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
    property?: XOR<PropertyRelationFilter, PropertyWhereInput>
    mortgage?: XOR<MortgageNullableRelationFilter, MortgageWhereInput> | null
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrderInput | SortOrder
    title?: SortOrder
    filename?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    storagePath?: SortOrder
    checksum?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attachment"> | number
    propertyId?: IntWithAggregatesFilter<"Attachment"> | number
    mortgageId?: IntNullableWithAggregatesFilter<"Attachment"> | number | null
    title?: StringWithAggregatesFilter<"Attachment"> | string
    filename?: StringWithAggregatesFilter<"Attachment"> | string
    contentType?: StringWithAggregatesFilter<"Attachment"> | string
    size?: IntWithAggregatesFilter<"Attachment"> | number
    storagePath?: StringWithAggregatesFilter<"Attachment"> | string
    checksum?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutUserInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    shareholders?: ShareholderCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutUserNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderCreateInput = {
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShareholdersInput
    companies?: CompanyShareholderCreateNestedManyWithoutShareholderInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderUncheckedCreateInput = {
    id?: number
    userId: number
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyShareholderUncheckedCreateNestedManyWithoutShareholderInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShareholdersNestedInput
    companies?: CompanyShareholderUpdateManyWithoutShareholderNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutShareholderNestedInput
  }

  export type ShareholderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyShareholderUncheckedUpdateManyWithoutShareholderNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutShareholderNestedInput
  }

  export type ShareholderCreateManyInput = {
    id?: number
    userId: number
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareholderUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyShareholderCreateInput = {
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareholderLinksInput
    shareholder: ShareholderCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyShareholderUncheckedCreateInput = {
    id?: number
    companyId: number
    shareholderId: number
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyShareholderUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareholderLinksNestedInput
    shareholder?: ShareholderUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyShareholderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyShareholderCreateManyInput = {
    id?: number
    companyId: number
    shareholderId: number
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyShareholderUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyShareholderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareClassCreateInput = {
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareClassesInput
    transactions?: ShareTransactionCreateNestedManyWithoutShareClassInput
  }

  export type ShareClassUncheckedCreateInput = {
    id?: number
    companyId: number
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: ShareTransactionUncheckedCreateNestedManyWithoutShareClassInput
  }

  export type ShareClassUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareClassesNestedInput
    transactions?: ShareTransactionUpdateManyWithoutShareClassNestedInput
  }

  export type ShareClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: ShareTransactionUncheckedUpdateManyWithoutShareClassNestedInput
  }

  export type ShareClassCreateManyInput = {
    id?: number
    companyId: number
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareClassUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionCreateInput = {
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareTransactionsInput
    shareClass: ShareClassCreateNestedOneWithoutTransactionsInput
    shareholder: ShareholderCreateNestedOneWithoutShareTransactionsInput
  }

  export type ShareTransactionUncheckedCreateInput = {
    id?: number
    companyId: number
    shareClassId: number
    shareholderId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareTransactionsNestedInput
    shareClass?: ShareClassUpdateOneRequiredWithoutTransactionsNestedInput
    shareholder?: ShareholderUpdateOneRequiredWithoutShareTransactionsNestedInput
  }

  export type ShareTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareClassId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionCreateManyInput = {
    id?: number
    companyId: number
    shareClassId: number
    shareholderId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareClassId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementCreateInput = {
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStatementsInput
    lines?: CorporateStatementLineCreateNestedManyWithoutStatementInput
  }

  export type CorporateStatementUncheckedCreateInput = {
    id?: number
    companyId: number
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: CorporateStatementLineUncheckedCreateNestedManyWithoutStatementInput
  }

  export type CorporateStatementUpdateInput = {
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStatementsNestedInput
    lines?: CorporateStatementLineUpdateManyWithoutStatementNestedInput
  }

  export type CorporateStatementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CorporateStatementLineUncheckedUpdateManyWithoutStatementNestedInput
  }

  export type CorporateStatementCreateManyInput = {
    id?: number
    companyId: number
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementUpdateManyMutationInput = {
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementLineCreateInput = {
    category: string
    label: string
    amount: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statement: CorporateStatementCreateNestedOneWithoutLinesInput
  }

  export type CorporateStatementLineUncheckedCreateInput = {
    id?: number
    statementId: number
    category: string
    label: string
    amount: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementLineUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statement?: CorporateStatementUpdateOneRequiredWithoutLinesNestedInput
  }

  export type CorporateStatementLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statementId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementLineCreateManyInput = {
    id?: number
    statementId: number
    category: string
    label: string
    amount: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementLineUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statementId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateResolutionCreateInput = {
    type: string
    title: string
    resolutionDate: Date | string
    body?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutResolutionsInput
  }

  export type CorporateResolutionUncheckedCreateInput = {
    id?: number
    companyId: number
    type: string
    title: string
    resolutionDate: Date | string
    body?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateResolutionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutResolutionsNestedInput
  }

  export type CorporateResolutionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateResolutionCreateManyInput = {
    id?: number
    companyId: number
    type: string
    title: string
    resolutionDate: Date | string
    body?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateResolutionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateResolutionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUnitCreateInput = {
    label: string
    squareFeet?: number | null
    rentExpected?: Decimal | DecimalJsLike | number | string | null
    property: PropertyCreateNestedOneWithoutUnitsInput
  }

  export type PropertyUnitUncheckedCreateInput = {
    id?: number
    propertyId: number
    label: string
    squareFeet?: number | null
    rentExpected?: Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    property?: PropertyUpdateOneRequiredWithoutUnitsNestedInput
  }

  export type PropertyUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitCreateManyInput = {
    id?: number
    propertyId: number
    label: string
    squareFeet?: number | null
    rentExpected?: Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type MortgageCreateInput = {
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutMortgagesInput
    attachments?: AttachmentCreateNestedManyWithoutMortgageInput
  }

  export type MortgageUncheckedCreateInput = {
    id?: number
    propertyId: number
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMortgageInput
  }

  export type MortgageUpdateInput = {
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutMortgagesNestedInput
    attachments?: AttachmentUpdateManyWithoutMortgageNestedInput
  }

  export type MortgageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutMortgageNestedInput
  }

  export type MortgageCreateManyInput = {
    id?: number
    propertyId: number
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MortgageUpdateManyMutationInput = {
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MortgageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueCreateInput = {
    label: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRevenuesInput
  }

  export type RevenueUncheckedCreateInput = {
    id?: number
    propertyId: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRevenuesNestedInput
  }

  export type RevenueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueCreateManyInput = {
    id?: number
    propertyId: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    label: string
    category: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: number
    propertyId: number
    label: string
    category: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: number
    propertyId: number
    label: string
    category: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    propertyId: number
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    propertyId: number
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    label: string
    amount: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DepreciationSettingCreateInput = {
    classCode: string
    ccaRate: Decimal | DecimalJsLike | number | string
    openingUcc: Decimal | DecimalJsLike | number | string
    additions: Decimal | DecimalJsLike | number | string
    dispositions: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutDepreciationInfoInput
  }

  export type DepreciationSettingUncheckedCreateInput = {
    id?: number
    propertyId: number
    classCode: string
    ccaRate: Decimal | DecimalJsLike | number | string
    openingUcc: Decimal | DecimalJsLike | number | string
    additions: Decimal | DecimalJsLike | number | string
    dispositions: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationSettingUpdateInput = {
    classCode?: StringFieldUpdateOperationsInput | string
    ccaRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    additions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutDepreciationInfoNestedInput
  }

  export type DepreciationSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    classCode?: StringFieldUpdateOperationsInput | string
    ccaRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    additions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationSettingCreateManyInput = {
    id?: number
    propertyId: number
    classCode: string
    ccaRate: Decimal | DecimalJsLike | number | string
    openingUcc: Decimal | DecimalJsLike | number | string
    additions: Decimal | DecimalJsLike | number | string
    dispositions: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationSettingUpdateManyMutationInput = {
    classCode?: StringFieldUpdateOperationsInput | string
    ccaRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    additions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    classCode?: StringFieldUpdateOperationsInput | string
    ccaRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    additions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
    company?: CompanyCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
    companyId?: number | null
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    company?: CompanyUpdateOneWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleCreateManyInput = {
    id?: number
    userId: number
    roleId: number
    companyId?: number | null
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttachmentCreateInput = {
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutAttachmentsInput
    mortgage?: MortgageCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: number
    propertyId: number
    mortgageId?: number | null
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutAttachmentsNestedInput
    mortgage?: MortgageUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    mortgageId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: number
    propertyId: number
    mortgageId?: number | null
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    mortgageId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type ShareholderListRelationFilter = {
    every?: ShareholderWhereInput
    some?: ShareholderWhereInput
    none?: ShareholderWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareholderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type PropertyUnitListRelationFilter = {
    every?: PropertyUnitWhereInput
    some?: PropertyUnitWhereInput
    none?: PropertyUnitWhereInput
  }

  export type MortgageListRelationFilter = {
    every?: MortgageWhereInput
    some?: MortgageWhereInput
    none?: MortgageWhereInput
  }

  export type RevenueListRelationFilter = {
    every?: RevenueWhereInput
    some?: RevenueWhereInput
    none?: RevenueWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type DepreciationSettingNullableRelationFilter = {
    is?: DepreciationSettingWhereInput | null
    isNot?: DepreciationSettingWhereInput | null
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PropertyUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MortgageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    acquisitionDate?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    acquisitionDate?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    acquisitionDate?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    purchasePrice?: SortOrder
    currentValue?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CompanyShareholderListRelationFilter = {
    every?: CompanyShareholderWhereInput
    some?: CompanyShareholderWhereInput
    none?: CompanyShareholderWhereInput
  }

  export type ShareClassListRelationFilter = {
    every?: ShareClassWhereInput
    some?: ShareClassWhereInput
    none?: ShareClassWhereInput
  }

  export type ShareTransactionListRelationFilter = {
    every?: ShareTransactionWhereInput
    some?: ShareTransactionWhereInput
    none?: ShareTransactionWhereInput
  }

  export type CorporateStatementListRelationFilter = {
    every?: CorporateStatementWhereInput
    some?: CorporateStatementWhereInput
    none?: CorporateStatementWhereInput
  }

  export type CorporateResolutionListRelationFilter = {
    every?: CorporateResolutionWhereInput
    some?: CorporateResolutionWhereInput
    none?: CorporateResolutionWhereInput
  }

  export type CompanyShareholderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CorporateStatementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CorporateResolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    neq?: SortOrder
    fiscalYearEnd?: SortOrder
    province?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    neq?: SortOrder
    fiscalYearEnd?: SortOrder
    province?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    neq?: SortOrder
    fiscalYearEnd?: SortOrder
    province?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ShareholderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareholderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ShareholderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareholderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareholderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type ShareholderRelationFilter = {
    is?: ShareholderWhereInput
    isNot?: ShareholderWhereInput
  }

  export type CompanyShareholderCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    role?: SortOrder
    votingPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyShareholderAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    votingPercent?: SortOrder
  }

  export type CompanyShareholderMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    role?: SortOrder
    votingPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyShareholderMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    role?: SortOrder
    votingPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyShareholderSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareholderId?: SortOrder
    votingPercent?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ShareClassCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    hasVotingRights?: SortOrder
    participatesInGrowth?: SortOrder
    dividendPolicy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareClassAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type ShareClassMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    hasVotingRights?: SortOrder
    participatesInGrowth?: SortOrder
    dividendPolicy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareClassMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    hasVotingRights?: SortOrder
    participatesInGrowth?: SortOrder
    dividendPolicy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareClassSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ShareClassRelationFilter = {
    is?: ShareClassWhereInput
    isNot?: ShareClassWhereInput
  }

  export type ShareTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    type?: SortOrder
    transactionDate?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrder
    considerationPaid?: SortOrder
    fairMarketValue?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrder
    considerationPaid?: SortOrder
    fairMarketValue?: SortOrder
  }

  export type ShareTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    type?: SortOrder
    transactionDate?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrder
    considerationPaid?: SortOrder
    fairMarketValue?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    type?: SortOrder
    transactionDate?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrder
    considerationPaid?: SortOrder
    fairMarketValue?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShareTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    shareClassId?: SortOrder
    shareholderId?: SortOrder
    quantity?: SortOrder
    pricePerShare?: SortOrder
    considerationPaid?: SortOrder
    fairMarketValue?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CorporateStatementLineListRelationFilter = {
    every?: CorporateStatementLineWhereInput
    some?: CorporateStatementLineWhereInput
    none?: CorporateStatementLineWhereInput
  }

  export type CorporateStatementLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CorporateStatementCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    statementType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    isAudited?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateStatementAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
  }

  export type CorporateStatementMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    statementType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    isAudited?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateStatementMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    statementType?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    isAudited?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateStatementSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    totalAssets?: SortOrder
    totalLiabilities?: SortOrder
    totalEquity?: SortOrder
    totalRevenue?: SortOrder
    totalExpenses?: SortOrder
    netIncome?: SortOrder
  }

  export type CorporateStatementRelationFilter = {
    is?: CorporateStatementWhereInput
    isNot?: CorporateStatementWhereInput
  }

  export type CorporateStatementLineCountOrderByAggregateInput = {
    id?: SortOrder
    statementId?: SortOrder
    category?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateStatementLineAvgOrderByAggregateInput = {
    id?: SortOrder
    statementId?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
  }

  export type CorporateStatementLineMaxOrderByAggregateInput = {
    id?: SortOrder
    statementId?: SortOrder
    category?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateStatementLineMinOrderByAggregateInput = {
    id?: SortOrder
    statementId?: SortOrder
    category?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateStatementLineSumOrderByAggregateInput = {
    id?: SortOrder
    statementId?: SortOrder
    amount?: SortOrder
    orderIndex?: SortOrder
  }

  export type CorporateResolutionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    resolutionDate?: SortOrder
    body?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateResolutionAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type CorporateResolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    resolutionDate?: SortOrder
    body?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateResolutionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    resolutionDate?: SortOrder
    body?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorporateResolutionSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type PropertyRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type PropertyUnitCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    squareFeet?: SortOrder
    rentExpected?: SortOrder
  }

  export type PropertyUnitAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    squareFeet?: SortOrder
    rentExpected?: SortOrder
  }

  export type PropertyUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    squareFeet?: SortOrder
    rentExpected?: SortOrder
  }

  export type PropertyUnitMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    squareFeet?: SortOrder
    rentExpected?: SortOrder
  }

  export type PropertyUnitSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    squareFeet?: SortOrder
    rentExpected?: SortOrder
  }

  export type MortgageCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    lender?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    startDate?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MortgageAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
  }

  export type MortgageMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    lender?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    startDate?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MortgageMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    lender?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    startDate?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MortgageSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    principal?: SortOrder
    rateAnnual?: SortOrder
    termMonths?: SortOrder
    amortizationMonths?: SortOrder
    paymentFrequency?: SortOrder
    paymentAmount?: SortOrder
  }

  export type RevenueCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
  }

  export type RevenueMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RevenueSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    label?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    invoiceDate?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    gst?: SortOrder
    qst?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    gst?: SortOrder
    qst?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    invoiceDate?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    gst?: SortOrder
    qst?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    invoiceDate?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    gst?: SortOrder
    qst?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    gst?: SortOrder
    qst?: SortOrder
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    label?: SortOrder
    amount?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type DepreciationSettingCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    classCode?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
  }

  export type DepreciationSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    classCode?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationSettingMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    classCode?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationSettingSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ccaRate?: SortOrder
    openingUcc?: SortOrder
    additions?: SortOrder
    dispositions?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserId_roleId_companyIdCompoundUniqueInput = {
    userId: number
    roleId: number
    companyId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    companyId?: SortOrder
  }

  export type MortgageNullableRelationFilter = {
    is?: MortgageWhereInput | null
    isNot?: MortgageWhereInput | null
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrder
    title?: SortOrder
    filename?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    storagePath?: SortOrder
    checksum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrder
    size?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrder
    title?: SortOrder
    filename?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    storagePath?: SortOrder
    checksum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrder
    title?: SortOrder
    filename?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    storagePath?: SortOrder
    checksum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    mortgageId?: SortOrder
    size?: SortOrder
  }

  export type PropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type CompanyCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type ShareholderCreateNestedManyWithoutUserInput = {
    create?: XOR<ShareholderCreateWithoutUserInput, ShareholderUncheckedCreateWithoutUserInput> | ShareholderCreateWithoutUserInput[] | ShareholderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutUserInput | ShareholderCreateOrConnectWithoutUserInput[]
    createMany?: ShareholderCreateManyUserInputEnvelope
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type ShareholderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShareholderCreateWithoutUserInput, ShareholderUncheckedCreateWithoutUserInput> | ShareholderCreateWithoutUserInput[] | ShareholderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutUserInput | ShareholderCreateOrConnectWithoutUserInput[]
    createMany?: ShareholderCreateManyUserInputEnvelope
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type CompanyUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutUserInput | CompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutUserInput | CompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutUserInput | CompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type ShareholderUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShareholderCreateWithoutUserInput, ShareholderUncheckedCreateWithoutUserInput> | ShareholderCreateWithoutUserInput[] | ShareholderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutUserInput | ShareholderCreateOrConnectWithoutUserInput[]
    upsert?: ShareholderUpsertWithWhereUniqueWithoutUserInput | ShareholderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShareholderCreateManyUserInputEnvelope
    set?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    disconnect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    delete?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    update?: ShareholderUpdateWithWhereUniqueWithoutUserInput | ShareholderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShareholderUpdateManyWithWhereWithoutUserInput | ShareholderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput> | CompanyCreateWithoutUserInput[] | CompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput | CompanyCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutUserInput | CompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyCreateManyUserInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutUserInput | CompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutUserInput | CompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type ShareholderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShareholderCreateWithoutUserInput, ShareholderUncheckedCreateWithoutUserInput> | ShareholderCreateWithoutUserInput[] | ShareholderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShareholderCreateOrConnectWithoutUserInput | ShareholderCreateOrConnectWithoutUserInput[]
    upsert?: ShareholderUpsertWithWhereUniqueWithoutUserInput | ShareholderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShareholderCreateManyUserInputEnvelope
    set?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    disconnect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    delete?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    connect?: ShareholderWhereUniqueInput | ShareholderWhereUniqueInput[]
    update?: ShareholderUpdateWithWhereUniqueWithoutUserInput | ShareholderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShareholderUpdateManyWithWhereWithoutUserInput | ShareholderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<CompanyCreateWithoutPropertiesInput, CompanyUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPropertiesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PropertyUnitCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyUnitCreateWithoutPropertyInput, PropertyUnitUncheckedCreateWithoutPropertyInput> | PropertyUnitCreateWithoutPropertyInput[] | PropertyUnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyUnitCreateOrConnectWithoutPropertyInput | PropertyUnitCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyUnitCreateManyPropertyInputEnvelope
    connect?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
  }

  export type MortgageCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MortgageCreateWithoutPropertyInput, MortgageUncheckedCreateWithoutPropertyInput> | MortgageCreateWithoutPropertyInput[] | MortgageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MortgageCreateOrConnectWithoutPropertyInput | MortgageCreateOrConnectWithoutPropertyInput[]
    createMany?: MortgageCreateManyPropertyInputEnvelope
    connect?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
  }

  export type RevenueCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RevenueCreateWithoutPropertyInput, RevenueUncheckedCreateWithoutPropertyInput> | RevenueCreateWithoutPropertyInput[] | RevenueUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RevenueCreateOrConnectWithoutPropertyInput | RevenueCreateOrConnectWithoutPropertyInput[]
    createMany?: RevenueCreateManyPropertyInputEnvelope
    connect?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InvoiceCreateWithoutPropertyInput, InvoiceUncheckedCreateWithoutPropertyInput> | InvoiceCreateWithoutPropertyInput[] | InvoiceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPropertyInput | InvoiceCreateOrConnectWithoutPropertyInput[]
    createMany?: InvoiceCreateManyPropertyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DepreciationSettingCreateNestedOneWithoutPropertyInput = {
    create?: XOR<DepreciationSettingCreateWithoutPropertyInput, DepreciationSettingUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: DepreciationSettingCreateOrConnectWithoutPropertyInput
    connect?: DepreciationSettingWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutPropertyInput = {
    create?: XOR<AttachmentCreateWithoutPropertyInput, AttachmentUncheckedCreateWithoutPropertyInput> | AttachmentCreateWithoutPropertyInput[] | AttachmentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPropertyInput | AttachmentCreateOrConnectWithoutPropertyInput[]
    createMany?: AttachmentCreateManyPropertyInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyUnitCreateWithoutPropertyInput, PropertyUnitUncheckedCreateWithoutPropertyInput> | PropertyUnitCreateWithoutPropertyInput[] | PropertyUnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyUnitCreateOrConnectWithoutPropertyInput | PropertyUnitCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyUnitCreateManyPropertyInputEnvelope
    connect?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
  }

  export type MortgageUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MortgageCreateWithoutPropertyInput, MortgageUncheckedCreateWithoutPropertyInput> | MortgageCreateWithoutPropertyInput[] | MortgageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MortgageCreateOrConnectWithoutPropertyInput | MortgageCreateOrConnectWithoutPropertyInput[]
    createMany?: MortgageCreateManyPropertyInputEnvelope
    connect?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
  }

  export type RevenueUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RevenueCreateWithoutPropertyInput, RevenueUncheckedCreateWithoutPropertyInput> | RevenueCreateWithoutPropertyInput[] | RevenueUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RevenueCreateOrConnectWithoutPropertyInput | RevenueCreateOrConnectWithoutPropertyInput[]
    createMany?: RevenueCreateManyPropertyInputEnvelope
    connect?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InvoiceCreateWithoutPropertyInput, InvoiceUncheckedCreateWithoutPropertyInput> | InvoiceCreateWithoutPropertyInput[] | InvoiceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPropertyInput | InvoiceCreateOrConnectWithoutPropertyInput[]
    createMany?: InvoiceCreateManyPropertyInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput = {
    create?: XOR<DepreciationSettingCreateWithoutPropertyInput, DepreciationSettingUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: DepreciationSettingCreateOrConnectWithoutPropertyInput
    connect?: DepreciationSettingWhereUniqueInput
  }

  export type AttachmentUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<AttachmentCreateWithoutPropertyInput, AttachmentUncheckedCreateWithoutPropertyInput> | AttachmentCreateWithoutPropertyInput[] | AttachmentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPropertyInput | AttachmentCreateOrConnectWithoutPropertyInput[]
    createMany?: AttachmentCreateManyPropertyInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    upsert?: UserUpsertWithoutPropertiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertiesInput, UserUpdateWithoutPropertiesInput>, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type CompanyUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<CompanyCreateWithoutPropertiesInput, CompanyUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPropertiesInput
    upsert?: CompanyUpsertWithoutPropertiesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPropertiesInput, CompanyUpdateWithoutPropertiesInput>, CompanyUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyUnitUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyUnitCreateWithoutPropertyInput, PropertyUnitUncheckedCreateWithoutPropertyInput> | PropertyUnitCreateWithoutPropertyInput[] | PropertyUnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyUnitCreateOrConnectWithoutPropertyInput | PropertyUnitCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyUnitUpsertWithWhereUniqueWithoutPropertyInput | PropertyUnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyUnitCreateManyPropertyInputEnvelope
    set?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    disconnect?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    delete?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    connect?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    update?: PropertyUnitUpdateWithWhereUniqueWithoutPropertyInput | PropertyUnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyUnitUpdateManyWithWhereWithoutPropertyInput | PropertyUnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyUnitScalarWhereInput | PropertyUnitScalarWhereInput[]
  }

  export type MortgageUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MortgageCreateWithoutPropertyInput, MortgageUncheckedCreateWithoutPropertyInput> | MortgageCreateWithoutPropertyInput[] | MortgageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MortgageCreateOrConnectWithoutPropertyInput | MortgageCreateOrConnectWithoutPropertyInput[]
    upsert?: MortgageUpsertWithWhereUniqueWithoutPropertyInput | MortgageUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MortgageCreateManyPropertyInputEnvelope
    set?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    disconnect?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    delete?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    connect?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    update?: MortgageUpdateWithWhereUniqueWithoutPropertyInput | MortgageUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MortgageUpdateManyWithWhereWithoutPropertyInput | MortgageUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MortgageScalarWhereInput | MortgageScalarWhereInput[]
  }

  export type RevenueUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RevenueCreateWithoutPropertyInput, RevenueUncheckedCreateWithoutPropertyInput> | RevenueCreateWithoutPropertyInput[] | RevenueUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RevenueCreateOrConnectWithoutPropertyInput | RevenueCreateOrConnectWithoutPropertyInput[]
    upsert?: RevenueUpsertWithWhereUniqueWithoutPropertyInput | RevenueUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RevenueCreateManyPropertyInputEnvelope
    set?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    disconnect?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    delete?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    connect?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    update?: RevenueUpdateWithWhereUniqueWithoutPropertyInput | RevenueUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RevenueUpdateManyWithWhereWithoutPropertyInput | RevenueUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RevenueScalarWhereInput | RevenueScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutPropertyInput | ExpenseUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutPropertyInput | ExpenseUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutPropertyInput | ExpenseUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InvoiceCreateWithoutPropertyInput, InvoiceUncheckedCreateWithoutPropertyInput> | InvoiceCreateWithoutPropertyInput[] | InvoiceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPropertyInput | InvoiceCreateOrConnectWithoutPropertyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPropertyInput | InvoiceUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InvoiceCreateManyPropertyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPropertyInput | InvoiceUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPropertyInput | InvoiceUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DepreciationSettingUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<DepreciationSettingCreateWithoutPropertyInput, DepreciationSettingUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: DepreciationSettingCreateOrConnectWithoutPropertyInput
    upsert?: DepreciationSettingUpsertWithoutPropertyInput
    disconnect?: DepreciationSettingWhereInput | boolean
    delete?: DepreciationSettingWhereInput | boolean
    connect?: DepreciationSettingWhereUniqueInput
    update?: XOR<XOR<DepreciationSettingUpdateToOneWithWhereWithoutPropertyInput, DepreciationSettingUpdateWithoutPropertyInput>, DepreciationSettingUncheckedUpdateWithoutPropertyInput>
  }

  export type AttachmentUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<AttachmentCreateWithoutPropertyInput, AttachmentUncheckedCreateWithoutPropertyInput> | AttachmentCreateWithoutPropertyInput[] | AttachmentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPropertyInput | AttachmentCreateOrConnectWithoutPropertyInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutPropertyInput | AttachmentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: AttachmentCreateManyPropertyInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutPropertyInput | AttachmentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutPropertyInput | AttachmentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyUnitCreateWithoutPropertyInput, PropertyUnitUncheckedCreateWithoutPropertyInput> | PropertyUnitCreateWithoutPropertyInput[] | PropertyUnitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyUnitCreateOrConnectWithoutPropertyInput | PropertyUnitCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyUnitUpsertWithWhereUniqueWithoutPropertyInput | PropertyUnitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyUnitCreateManyPropertyInputEnvelope
    set?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    disconnect?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    delete?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    connect?: PropertyUnitWhereUniqueInput | PropertyUnitWhereUniqueInput[]
    update?: PropertyUnitUpdateWithWhereUniqueWithoutPropertyInput | PropertyUnitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyUnitUpdateManyWithWhereWithoutPropertyInput | PropertyUnitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyUnitScalarWhereInput | PropertyUnitScalarWhereInput[]
  }

  export type MortgageUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MortgageCreateWithoutPropertyInput, MortgageUncheckedCreateWithoutPropertyInput> | MortgageCreateWithoutPropertyInput[] | MortgageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MortgageCreateOrConnectWithoutPropertyInput | MortgageCreateOrConnectWithoutPropertyInput[]
    upsert?: MortgageUpsertWithWhereUniqueWithoutPropertyInput | MortgageUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MortgageCreateManyPropertyInputEnvelope
    set?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    disconnect?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    delete?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    connect?: MortgageWhereUniqueInput | MortgageWhereUniqueInput[]
    update?: MortgageUpdateWithWhereUniqueWithoutPropertyInput | MortgageUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MortgageUpdateManyWithWhereWithoutPropertyInput | MortgageUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MortgageScalarWhereInput | MortgageScalarWhereInput[]
  }

  export type RevenueUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RevenueCreateWithoutPropertyInput, RevenueUncheckedCreateWithoutPropertyInput> | RevenueCreateWithoutPropertyInput[] | RevenueUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RevenueCreateOrConnectWithoutPropertyInput | RevenueCreateOrConnectWithoutPropertyInput[]
    upsert?: RevenueUpsertWithWhereUniqueWithoutPropertyInput | RevenueUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RevenueCreateManyPropertyInputEnvelope
    set?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    disconnect?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    delete?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    connect?: RevenueWhereUniqueInput | RevenueWhereUniqueInput[]
    update?: RevenueUpdateWithWhereUniqueWithoutPropertyInput | RevenueUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RevenueUpdateManyWithWhereWithoutPropertyInput | RevenueUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RevenueScalarWhereInput | RevenueScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput> | ExpenseCreateWithoutPropertyInput[] | ExpenseUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutPropertyInput | ExpenseCreateOrConnectWithoutPropertyInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutPropertyInput | ExpenseUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ExpenseCreateManyPropertyInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutPropertyInput | ExpenseUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutPropertyInput | ExpenseUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InvoiceCreateWithoutPropertyInput, InvoiceUncheckedCreateWithoutPropertyInput> | InvoiceCreateWithoutPropertyInput[] | InvoiceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPropertyInput | InvoiceCreateOrConnectWithoutPropertyInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPropertyInput | InvoiceUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InvoiceCreateManyPropertyInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPropertyInput | InvoiceUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPropertyInput | InvoiceUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<DepreciationSettingCreateWithoutPropertyInput, DepreciationSettingUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: DepreciationSettingCreateOrConnectWithoutPropertyInput
    upsert?: DepreciationSettingUpsertWithoutPropertyInput
    disconnect?: DepreciationSettingWhereInput | boolean
    delete?: DepreciationSettingWhereInput | boolean
    connect?: DepreciationSettingWhereUniqueInput
    update?: XOR<XOR<DepreciationSettingUpdateToOneWithWhereWithoutPropertyInput, DepreciationSettingUpdateWithoutPropertyInput>, DepreciationSettingUncheckedUpdateWithoutPropertyInput>
  }

  export type AttachmentUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<AttachmentCreateWithoutPropertyInput, AttachmentUncheckedCreateWithoutPropertyInput> | AttachmentCreateWithoutPropertyInput[] | AttachmentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPropertyInput | AttachmentCreateOrConnectWithoutPropertyInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutPropertyInput | AttachmentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: AttachmentCreateManyPropertyInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutPropertyInput | AttachmentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutPropertyInput | AttachmentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PropertyCreateWithoutCompanyInput, PropertyUncheckedCreateWithoutCompanyInput> | PropertyCreateWithoutCompanyInput[] | PropertyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCompanyInput | PropertyCreateOrConnectWithoutCompanyInput[]
    createMany?: PropertyCreateManyCompanyInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type CompanyShareholderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyShareholderCreateWithoutCompanyInput, CompanyShareholderUncheckedCreateWithoutCompanyInput> | CompanyShareholderCreateWithoutCompanyInput[] | CompanyShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutCompanyInput | CompanyShareholderCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyShareholderCreateManyCompanyInputEnvelope
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
  }

  export type ShareClassCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShareClassCreateWithoutCompanyInput, ShareClassUncheckedCreateWithoutCompanyInput> | ShareClassCreateWithoutCompanyInput[] | ShareClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareClassCreateOrConnectWithoutCompanyInput | ShareClassCreateOrConnectWithoutCompanyInput[]
    createMany?: ShareClassCreateManyCompanyInputEnvelope
    connect?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
  }

  export type ShareTransactionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShareTransactionCreateWithoutCompanyInput, ShareTransactionUncheckedCreateWithoutCompanyInput> | ShareTransactionCreateWithoutCompanyInput[] | ShareTransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutCompanyInput | ShareTransactionCreateOrConnectWithoutCompanyInput[]
    createMany?: ShareTransactionCreateManyCompanyInputEnvelope
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
  }

  export type CorporateStatementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CorporateStatementCreateWithoutCompanyInput, CorporateStatementUncheckedCreateWithoutCompanyInput> | CorporateStatementCreateWithoutCompanyInput[] | CorporateStatementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateStatementCreateOrConnectWithoutCompanyInput | CorporateStatementCreateOrConnectWithoutCompanyInput[]
    createMany?: CorporateStatementCreateManyCompanyInputEnvelope
    connect?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
  }

  export type CorporateResolutionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CorporateResolutionCreateWithoutCompanyInput, CorporateResolutionUncheckedCreateWithoutCompanyInput> | CorporateResolutionCreateWithoutCompanyInput[] | CorporateResolutionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateResolutionCreateOrConnectWithoutCompanyInput | CorporateResolutionCreateOrConnectWithoutCompanyInput[]
    createMany?: CorporateResolutionCreateManyCompanyInputEnvelope
    connect?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PropertyCreateWithoutCompanyInput, PropertyUncheckedCreateWithoutCompanyInput> | PropertyCreateWithoutCompanyInput[] | PropertyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCompanyInput | PropertyCreateOrConnectWithoutCompanyInput[]
    createMany?: PropertyCreateManyCompanyInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyShareholderCreateWithoutCompanyInput, CompanyShareholderUncheckedCreateWithoutCompanyInput> | CompanyShareholderCreateWithoutCompanyInput[] | CompanyShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutCompanyInput | CompanyShareholderCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyShareholderCreateManyCompanyInputEnvelope
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
  }

  export type ShareClassUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShareClassCreateWithoutCompanyInput, ShareClassUncheckedCreateWithoutCompanyInput> | ShareClassCreateWithoutCompanyInput[] | ShareClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareClassCreateOrConnectWithoutCompanyInput | ShareClassCreateOrConnectWithoutCompanyInput[]
    createMany?: ShareClassCreateManyCompanyInputEnvelope
    connect?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
  }

  export type ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ShareTransactionCreateWithoutCompanyInput, ShareTransactionUncheckedCreateWithoutCompanyInput> | ShareTransactionCreateWithoutCompanyInput[] | ShareTransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutCompanyInput | ShareTransactionCreateOrConnectWithoutCompanyInput[]
    createMany?: ShareTransactionCreateManyCompanyInputEnvelope
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
  }

  export type CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CorporateStatementCreateWithoutCompanyInput, CorporateStatementUncheckedCreateWithoutCompanyInput> | CorporateStatementCreateWithoutCompanyInput[] | CorporateStatementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateStatementCreateOrConnectWithoutCompanyInput | CorporateStatementCreateOrConnectWithoutCompanyInput[]
    createMany?: CorporateStatementCreateManyCompanyInputEnvelope
    connect?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
  }

  export type CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CorporateResolutionCreateWithoutCompanyInput, CorporateResolutionUncheckedCreateWithoutCompanyInput> | CorporateResolutionCreateWithoutCompanyInput[] | CorporateResolutionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateResolutionCreateOrConnectWithoutCompanyInput | CorporateResolutionCreateOrConnectWithoutCompanyInput[]
    createMany?: CorporateResolutionCreateManyCompanyInputEnvelope
    connect?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    upsert?: UserUpsertWithoutCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompaniesInput, UserUpdateWithoutCompaniesInput>, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type PropertyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PropertyCreateWithoutCompanyInput, PropertyUncheckedCreateWithoutCompanyInput> | PropertyCreateWithoutCompanyInput[] | PropertyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCompanyInput | PropertyCreateOrConnectWithoutCompanyInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCompanyInput | PropertyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PropertyCreateManyCompanyInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCompanyInput | PropertyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCompanyInput | PropertyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type CompanyShareholderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyShareholderCreateWithoutCompanyInput, CompanyShareholderUncheckedCreateWithoutCompanyInput> | CompanyShareholderCreateWithoutCompanyInput[] | CompanyShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutCompanyInput | CompanyShareholderCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyShareholderUpsertWithWhereUniqueWithoutCompanyInput | CompanyShareholderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyShareholderCreateManyCompanyInputEnvelope
    set?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    disconnect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    delete?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    update?: CompanyShareholderUpdateWithWhereUniqueWithoutCompanyInput | CompanyShareholderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyShareholderUpdateManyWithWhereWithoutCompanyInput | CompanyShareholderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyShareholderScalarWhereInput | CompanyShareholderScalarWhereInput[]
  }

  export type ShareClassUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShareClassCreateWithoutCompanyInput, ShareClassUncheckedCreateWithoutCompanyInput> | ShareClassCreateWithoutCompanyInput[] | ShareClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareClassCreateOrConnectWithoutCompanyInput | ShareClassCreateOrConnectWithoutCompanyInput[]
    upsert?: ShareClassUpsertWithWhereUniqueWithoutCompanyInput | ShareClassUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShareClassCreateManyCompanyInputEnvelope
    set?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    disconnect?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    delete?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    connect?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    update?: ShareClassUpdateWithWhereUniqueWithoutCompanyInput | ShareClassUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShareClassUpdateManyWithWhereWithoutCompanyInput | ShareClassUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShareClassScalarWhereInput | ShareClassScalarWhereInput[]
  }

  export type ShareTransactionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShareTransactionCreateWithoutCompanyInput, ShareTransactionUncheckedCreateWithoutCompanyInput> | ShareTransactionCreateWithoutCompanyInput[] | ShareTransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutCompanyInput | ShareTransactionCreateOrConnectWithoutCompanyInput[]
    upsert?: ShareTransactionUpsertWithWhereUniqueWithoutCompanyInput | ShareTransactionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShareTransactionCreateManyCompanyInputEnvelope
    set?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    disconnect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    delete?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    update?: ShareTransactionUpdateWithWhereUniqueWithoutCompanyInput | ShareTransactionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShareTransactionUpdateManyWithWhereWithoutCompanyInput | ShareTransactionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
  }

  export type CorporateStatementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CorporateStatementCreateWithoutCompanyInput, CorporateStatementUncheckedCreateWithoutCompanyInput> | CorporateStatementCreateWithoutCompanyInput[] | CorporateStatementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateStatementCreateOrConnectWithoutCompanyInput | CorporateStatementCreateOrConnectWithoutCompanyInput[]
    upsert?: CorporateStatementUpsertWithWhereUniqueWithoutCompanyInput | CorporateStatementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CorporateStatementCreateManyCompanyInputEnvelope
    set?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    disconnect?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    delete?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    connect?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    update?: CorporateStatementUpdateWithWhereUniqueWithoutCompanyInput | CorporateStatementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CorporateStatementUpdateManyWithWhereWithoutCompanyInput | CorporateStatementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CorporateStatementScalarWhereInput | CorporateStatementScalarWhereInput[]
  }

  export type CorporateResolutionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CorporateResolutionCreateWithoutCompanyInput, CorporateResolutionUncheckedCreateWithoutCompanyInput> | CorporateResolutionCreateWithoutCompanyInput[] | CorporateResolutionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateResolutionCreateOrConnectWithoutCompanyInput | CorporateResolutionCreateOrConnectWithoutCompanyInput[]
    upsert?: CorporateResolutionUpsertWithWhereUniqueWithoutCompanyInput | CorporateResolutionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CorporateResolutionCreateManyCompanyInputEnvelope
    set?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    disconnect?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    delete?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    connect?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    update?: CorporateResolutionUpdateWithWhereUniqueWithoutCompanyInput | CorporateResolutionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CorporateResolutionUpdateManyWithWhereWithoutCompanyInput | CorporateResolutionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CorporateResolutionScalarWhereInput | CorporateResolutionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutCompanyInput | UserRoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutCompanyInput | UserRoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutCompanyInput | UserRoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PropertyCreateWithoutCompanyInput, PropertyUncheckedCreateWithoutCompanyInput> | PropertyCreateWithoutCompanyInput[] | PropertyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutCompanyInput | PropertyCreateOrConnectWithoutCompanyInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutCompanyInput | PropertyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PropertyCreateManyCompanyInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutCompanyInput | PropertyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutCompanyInput | PropertyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyShareholderCreateWithoutCompanyInput, CompanyShareholderUncheckedCreateWithoutCompanyInput> | CompanyShareholderCreateWithoutCompanyInput[] | CompanyShareholderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutCompanyInput | CompanyShareholderCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyShareholderUpsertWithWhereUniqueWithoutCompanyInput | CompanyShareholderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyShareholderCreateManyCompanyInputEnvelope
    set?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    disconnect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    delete?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    update?: CompanyShareholderUpdateWithWhereUniqueWithoutCompanyInput | CompanyShareholderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyShareholderUpdateManyWithWhereWithoutCompanyInput | CompanyShareholderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyShareholderScalarWhereInput | CompanyShareholderScalarWhereInput[]
  }

  export type ShareClassUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShareClassCreateWithoutCompanyInput, ShareClassUncheckedCreateWithoutCompanyInput> | ShareClassCreateWithoutCompanyInput[] | ShareClassUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareClassCreateOrConnectWithoutCompanyInput | ShareClassCreateOrConnectWithoutCompanyInput[]
    upsert?: ShareClassUpsertWithWhereUniqueWithoutCompanyInput | ShareClassUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShareClassCreateManyCompanyInputEnvelope
    set?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    disconnect?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    delete?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    connect?: ShareClassWhereUniqueInput | ShareClassWhereUniqueInput[]
    update?: ShareClassUpdateWithWhereUniqueWithoutCompanyInput | ShareClassUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShareClassUpdateManyWithWhereWithoutCompanyInput | ShareClassUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShareClassScalarWhereInput | ShareClassScalarWhereInput[]
  }

  export type ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ShareTransactionCreateWithoutCompanyInput, ShareTransactionUncheckedCreateWithoutCompanyInput> | ShareTransactionCreateWithoutCompanyInput[] | ShareTransactionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutCompanyInput | ShareTransactionCreateOrConnectWithoutCompanyInput[]
    upsert?: ShareTransactionUpsertWithWhereUniqueWithoutCompanyInput | ShareTransactionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ShareTransactionCreateManyCompanyInputEnvelope
    set?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    disconnect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    delete?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    update?: ShareTransactionUpdateWithWhereUniqueWithoutCompanyInput | ShareTransactionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ShareTransactionUpdateManyWithWhereWithoutCompanyInput | ShareTransactionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
  }

  export type CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CorporateStatementCreateWithoutCompanyInput, CorporateStatementUncheckedCreateWithoutCompanyInput> | CorporateStatementCreateWithoutCompanyInput[] | CorporateStatementUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateStatementCreateOrConnectWithoutCompanyInput | CorporateStatementCreateOrConnectWithoutCompanyInput[]
    upsert?: CorporateStatementUpsertWithWhereUniqueWithoutCompanyInput | CorporateStatementUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CorporateStatementCreateManyCompanyInputEnvelope
    set?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    disconnect?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    delete?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    connect?: CorporateStatementWhereUniqueInput | CorporateStatementWhereUniqueInput[]
    update?: CorporateStatementUpdateWithWhereUniqueWithoutCompanyInput | CorporateStatementUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CorporateStatementUpdateManyWithWhereWithoutCompanyInput | CorporateStatementUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CorporateStatementScalarWhereInput | CorporateStatementScalarWhereInput[]
  }

  export type CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CorporateResolutionCreateWithoutCompanyInput, CorporateResolutionUncheckedCreateWithoutCompanyInput> | CorporateResolutionCreateWithoutCompanyInput[] | CorporateResolutionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CorporateResolutionCreateOrConnectWithoutCompanyInput | CorporateResolutionCreateOrConnectWithoutCompanyInput[]
    upsert?: CorporateResolutionUpsertWithWhereUniqueWithoutCompanyInput | CorporateResolutionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CorporateResolutionCreateManyCompanyInputEnvelope
    set?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    disconnect?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    delete?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    connect?: CorporateResolutionWhereUniqueInput | CorporateResolutionWhereUniqueInput[]
    update?: CorporateResolutionUpdateWithWhereUniqueWithoutCompanyInput | CorporateResolutionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CorporateResolutionUpdateManyWithWhereWithoutCompanyInput | CorporateResolutionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CorporateResolutionScalarWhereInput | CorporateResolutionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput> | UserRoleCreateWithoutCompanyInput[] | UserRoleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutCompanyInput | UserRoleCreateOrConnectWithoutCompanyInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutCompanyInput | UserRoleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserRoleCreateManyCompanyInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutCompanyInput | UserRoleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutCompanyInput | UserRoleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutShareholdersInput = {
    create?: XOR<UserCreateWithoutShareholdersInput, UserUncheckedCreateWithoutShareholdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutShareholdersInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyShareholderCreateNestedManyWithoutShareholderInput = {
    create?: XOR<CompanyShareholderCreateWithoutShareholderInput, CompanyShareholderUncheckedCreateWithoutShareholderInput> | CompanyShareholderCreateWithoutShareholderInput[] | CompanyShareholderUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutShareholderInput | CompanyShareholderCreateOrConnectWithoutShareholderInput[]
    createMany?: CompanyShareholderCreateManyShareholderInputEnvelope
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
  }

  export type ShareTransactionCreateNestedManyWithoutShareholderInput = {
    create?: XOR<ShareTransactionCreateWithoutShareholderInput, ShareTransactionUncheckedCreateWithoutShareholderInput> | ShareTransactionCreateWithoutShareholderInput[] | ShareTransactionUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareholderInput | ShareTransactionCreateOrConnectWithoutShareholderInput[]
    createMany?: ShareTransactionCreateManyShareholderInputEnvelope
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
  }

  export type CompanyShareholderUncheckedCreateNestedManyWithoutShareholderInput = {
    create?: XOR<CompanyShareholderCreateWithoutShareholderInput, CompanyShareholderUncheckedCreateWithoutShareholderInput> | CompanyShareholderCreateWithoutShareholderInput[] | CompanyShareholderUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutShareholderInput | CompanyShareholderCreateOrConnectWithoutShareholderInput[]
    createMany?: CompanyShareholderCreateManyShareholderInputEnvelope
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
  }

  export type ShareTransactionUncheckedCreateNestedManyWithoutShareholderInput = {
    create?: XOR<ShareTransactionCreateWithoutShareholderInput, ShareTransactionUncheckedCreateWithoutShareholderInput> | ShareTransactionCreateWithoutShareholderInput[] | ShareTransactionUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareholderInput | ShareTransactionCreateOrConnectWithoutShareholderInput[]
    createMany?: ShareTransactionCreateManyShareholderInputEnvelope
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutShareholdersNestedInput = {
    create?: XOR<UserCreateWithoutShareholdersInput, UserUncheckedCreateWithoutShareholdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutShareholdersInput
    upsert?: UserUpsertWithoutShareholdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShareholdersInput, UserUpdateWithoutShareholdersInput>, UserUncheckedUpdateWithoutShareholdersInput>
  }

  export type CompanyShareholderUpdateManyWithoutShareholderNestedInput = {
    create?: XOR<CompanyShareholderCreateWithoutShareholderInput, CompanyShareholderUncheckedCreateWithoutShareholderInput> | CompanyShareholderCreateWithoutShareholderInput[] | CompanyShareholderUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutShareholderInput | CompanyShareholderCreateOrConnectWithoutShareholderInput[]
    upsert?: CompanyShareholderUpsertWithWhereUniqueWithoutShareholderInput | CompanyShareholderUpsertWithWhereUniqueWithoutShareholderInput[]
    createMany?: CompanyShareholderCreateManyShareholderInputEnvelope
    set?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    disconnect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    delete?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    update?: CompanyShareholderUpdateWithWhereUniqueWithoutShareholderInput | CompanyShareholderUpdateWithWhereUniqueWithoutShareholderInput[]
    updateMany?: CompanyShareholderUpdateManyWithWhereWithoutShareholderInput | CompanyShareholderUpdateManyWithWhereWithoutShareholderInput[]
    deleteMany?: CompanyShareholderScalarWhereInput | CompanyShareholderScalarWhereInput[]
  }

  export type ShareTransactionUpdateManyWithoutShareholderNestedInput = {
    create?: XOR<ShareTransactionCreateWithoutShareholderInput, ShareTransactionUncheckedCreateWithoutShareholderInput> | ShareTransactionCreateWithoutShareholderInput[] | ShareTransactionUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareholderInput | ShareTransactionCreateOrConnectWithoutShareholderInput[]
    upsert?: ShareTransactionUpsertWithWhereUniqueWithoutShareholderInput | ShareTransactionUpsertWithWhereUniqueWithoutShareholderInput[]
    createMany?: ShareTransactionCreateManyShareholderInputEnvelope
    set?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    disconnect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    delete?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    update?: ShareTransactionUpdateWithWhereUniqueWithoutShareholderInput | ShareTransactionUpdateWithWhereUniqueWithoutShareholderInput[]
    updateMany?: ShareTransactionUpdateManyWithWhereWithoutShareholderInput | ShareTransactionUpdateManyWithWhereWithoutShareholderInput[]
    deleteMany?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
  }

  export type CompanyShareholderUncheckedUpdateManyWithoutShareholderNestedInput = {
    create?: XOR<CompanyShareholderCreateWithoutShareholderInput, CompanyShareholderUncheckedCreateWithoutShareholderInput> | CompanyShareholderCreateWithoutShareholderInput[] | CompanyShareholderUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: CompanyShareholderCreateOrConnectWithoutShareholderInput | CompanyShareholderCreateOrConnectWithoutShareholderInput[]
    upsert?: CompanyShareholderUpsertWithWhereUniqueWithoutShareholderInput | CompanyShareholderUpsertWithWhereUniqueWithoutShareholderInput[]
    createMany?: CompanyShareholderCreateManyShareholderInputEnvelope
    set?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    disconnect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    delete?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    connect?: CompanyShareholderWhereUniqueInput | CompanyShareholderWhereUniqueInput[]
    update?: CompanyShareholderUpdateWithWhereUniqueWithoutShareholderInput | CompanyShareholderUpdateWithWhereUniqueWithoutShareholderInput[]
    updateMany?: CompanyShareholderUpdateManyWithWhereWithoutShareholderInput | CompanyShareholderUpdateManyWithWhereWithoutShareholderInput[]
    deleteMany?: CompanyShareholderScalarWhereInput | CompanyShareholderScalarWhereInput[]
  }

  export type ShareTransactionUncheckedUpdateManyWithoutShareholderNestedInput = {
    create?: XOR<ShareTransactionCreateWithoutShareholderInput, ShareTransactionUncheckedCreateWithoutShareholderInput> | ShareTransactionCreateWithoutShareholderInput[] | ShareTransactionUncheckedCreateWithoutShareholderInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareholderInput | ShareTransactionCreateOrConnectWithoutShareholderInput[]
    upsert?: ShareTransactionUpsertWithWhereUniqueWithoutShareholderInput | ShareTransactionUpsertWithWhereUniqueWithoutShareholderInput[]
    createMany?: ShareTransactionCreateManyShareholderInputEnvelope
    set?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    disconnect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    delete?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    update?: ShareTransactionUpdateWithWhereUniqueWithoutShareholderInput | ShareTransactionUpdateWithWhereUniqueWithoutShareholderInput[]
    updateMany?: ShareTransactionUpdateManyWithWhereWithoutShareholderInput | ShareTransactionUpdateManyWithWhereWithoutShareholderInput[]
    deleteMany?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutShareholderLinksInput = {
    create?: XOR<CompanyCreateWithoutShareholderLinksInput, CompanyUncheckedCreateWithoutShareholderLinksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareholderLinksInput
    connect?: CompanyWhereUniqueInput
  }

  export type ShareholderCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<ShareholderCreateWithoutCompaniesInput, ShareholderUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: ShareholderCreateOrConnectWithoutCompaniesInput
    connect?: ShareholderWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutShareholderLinksNestedInput = {
    create?: XOR<CompanyCreateWithoutShareholderLinksInput, CompanyUncheckedCreateWithoutShareholderLinksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareholderLinksInput
    upsert?: CompanyUpsertWithoutShareholderLinksInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutShareholderLinksInput, CompanyUpdateWithoutShareholderLinksInput>, CompanyUncheckedUpdateWithoutShareholderLinksInput>
  }

  export type ShareholderUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<ShareholderCreateWithoutCompaniesInput, ShareholderUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: ShareholderCreateOrConnectWithoutCompaniesInput
    upsert?: ShareholderUpsertWithoutCompaniesInput
    connect?: ShareholderWhereUniqueInput
    update?: XOR<XOR<ShareholderUpdateToOneWithWhereWithoutCompaniesInput, ShareholderUpdateWithoutCompaniesInput>, ShareholderUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompanyCreateNestedOneWithoutShareClassesInput = {
    create?: XOR<CompanyCreateWithoutShareClassesInput, CompanyUncheckedCreateWithoutShareClassesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareClassesInput
    connect?: CompanyWhereUniqueInput
  }

  export type ShareTransactionCreateNestedManyWithoutShareClassInput = {
    create?: XOR<ShareTransactionCreateWithoutShareClassInput, ShareTransactionUncheckedCreateWithoutShareClassInput> | ShareTransactionCreateWithoutShareClassInput[] | ShareTransactionUncheckedCreateWithoutShareClassInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareClassInput | ShareTransactionCreateOrConnectWithoutShareClassInput[]
    createMany?: ShareTransactionCreateManyShareClassInputEnvelope
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
  }

  export type ShareTransactionUncheckedCreateNestedManyWithoutShareClassInput = {
    create?: XOR<ShareTransactionCreateWithoutShareClassInput, ShareTransactionUncheckedCreateWithoutShareClassInput> | ShareTransactionCreateWithoutShareClassInput[] | ShareTransactionUncheckedCreateWithoutShareClassInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareClassInput | ShareTransactionCreateOrConnectWithoutShareClassInput[]
    createMany?: ShareTransactionCreateManyShareClassInputEnvelope
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CompanyUpdateOneRequiredWithoutShareClassesNestedInput = {
    create?: XOR<CompanyCreateWithoutShareClassesInput, CompanyUncheckedCreateWithoutShareClassesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareClassesInput
    upsert?: CompanyUpsertWithoutShareClassesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutShareClassesInput, CompanyUpdateWithoutShareClassesInput>, CompanyUncheckedUpdateWithoutShareClassesInput>
  }

  export type ShareTransactionUpdateManyWithoutShareClassNestedInput = {
    create?: XOR<ShareTransactionCreateWithoutShareClassInput, ShareTransactionUncheckedCreateWithoutShareClassInput> | ShareTransactionCreateWithoutShareClassInput[] | ShareTransactionUncheckedCreateWithoutShareClassInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareClassInput | ShareTransactionCreateOrConnectWithoutShareClassInput[]
    upsert?: ShareTransactionUpsertWithWhereUniqueWithoutShareClassInput | ShareTransactionUpsertWithWhereUniqueWithoutShareClassInput[]
    createMany?: ShareTransactionCreateManyShareClassInputEnvelope
    set?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    disconnect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    delete?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    update?: ShareTransactionUpdateWithWhereUniqueWithoutShareClassInput | ShareTransactionUpdateWithWhereUniqueWithoutShareClassInput[]
    updateMany?: ShareTransactionUpdateManyWithWhereWithoutShareClassInput | ShareTransactionUpdateManyWithWhereWithoutShareClassInput[]
    deleteMany?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
  }

  export type ShareTransactionUncheckedUpdateManyWithoutShareClassNestedInput = {
    create?: XOR<ShareTransactionCreateWithoutShareClassInput, ShareTransactionUncheckedCreateWithoutShareClassInput> | ShareTransactionCreateWithoutShareClassInput[] | ShareTransactionUncheckedCreateWithoutShareClassInput[]
    connectOrCreate?: ShareTransactionCreateOrConnectWithoutShareClassInput | ShareTransactionCreateOrConnectWithoutShareClassInput[]
    upsert?: ShareTransactionUpsertWithWhereUniqueWithoutShareClassInput | ShareTransactionUpsertWithWhereUniqueWithoutShareClassInput[]
    createMany?: ShareTransactionCreateManyShareClassInputEnvelope
    set?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    disconnect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    delete?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    connect?: ShareTransactionWhereUniqueInput | ShareTransactionWhereUniqueInput[]
    update?: ShareTransactionUpdateWithWhereUniqueWithoutShareClassInput | ShareTransactionUpdateWithWhereUniqueWithoutShareClassInput[]
    updateMany?: ShareTransactionUpdateManyWithWhereWithoutShareClassInput | ShareTransactionUpdateManyWithWhereWithoutShareClassInput[]
    deleteMany?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutShareTransactionsInput = {
    create?: XOR<CompanyCreateWithoutShareTransactionsInput, CompanyUncheckedCreateWithoutShareTransactionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareTransactionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ShareClassCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ShareClassCreateWithoutTransactionsInput, ShareClassUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ShareClassCreateOrConnectWithoutTransactionsInput
    connect?: ShareClassWhereUniqueInput
  }

  export type ShareholderCreateNestedOneWithoutShareTransactionsInput = {
    create?: XOR<ShareholderCreateWithoutShareTransactionsInput, ShareholderUncheckedCreateWithoutShareTransactionsInput>
    connectOrCreate?: ShareholderCreateOrConnectWithoutShareTransactionsInput
    connect?: ShareholderWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CompanyUpdateOneRequiredWithoutShareTransactionsNestedInput = {
    create?: XOR<CompanyCreateWithoutShareTransactionsInput, CompanyUncheckedCreateWithoutShareTransactionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutShareTransactionsInput
    upsert?: CompanyUpsertWithoutShareTransactionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutShareTransactionsInput, CompanyUpdateWithoutShareTransactionsInput>, CompanyUncheckedUpdateWithoutShareTransactionsInput>
  }

  export type ShareClassUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<ShareClassCreateWithoutTransactionsInput, ShareClassUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ShareClassCreateOrConnectWithoutTransactionsInput
    upsert?: ShareClassUpsertWithoutTransactionsInput
    connect?: ShareClassWhereUniqueInput
    update?: XOR<XOR<ShareClassUpdateToOneWithWhereWithoutTransactionsInput, ShareClassUpdateWithoutTransactionsInput>, ShareClassUncheckedUpdateWithoutTransactionsInput>
  }

  export type ShareholderUpdateOneRequiredWithoutShareTransactionsNestedInput = {
    create?: XOR<ShareholderCreateWithoutShareTransactionsInput, ShareholderUncheckedCreateWithoutShareTransactionsInput>
    connectOrCreate?: ShareholderCreateOrConnectWithoutShareTransactionsInput
    upsert?: ShareholderUpsertWithoutShareTransactionsInput
    connect?: ShareholderWhereUniqueInput
    update?: XOR<XOR<ShareholderUpdateToOneWithWhereWithoutShareTransactionsInput, ShareholderUpdateWithoutShareTransactionsInput>, ShareholderUncheckedUpdateWithoutShareTransactionsInput>
  }

  export type CompanyCreateNestedOneWithoutStatementsInput = {
    create?: XOR<CompanyCreateWithoutStatementsInput, CompanyUncheckedCreateWithoutStatementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStatementsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CorporateStatementLineCreateNestedManyWithoutStatementInput = {
    create?: XOR<CorporateStatementLineCreateWithoutStatementInput, CorporateStatementLineUncheckedCreateWithoutStatementInput> | CorporateStatementLineCreateWithoutStatementInput[] | CorporateStatementLineUncheckedCreateWithoutStatementInput[]
    connectOrCreate?: CorporateStatementLineCreateOrConnectWithoutStatementInput | CorporateStatementLineCreateOrConnectWithoutStatementInput[]
    createMany?: CorporateStatementLineCreateManyStatementInputEnvelope
    connect?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
  }

  export type CorporateStatementLineUncheckedCreateNestedManyWithoutStatementInput = {
    create?: XOR<CorporateStatementLineCreateWithoutStatementInput, CorporateStatementLineUncheckedCreateWithoutStatementInput> | CorporateStatementLineCreateWithoutStatementInput[] | CorporateStatementLineUncheckedCreateWithoutStatementInput[]
    connectOrCreate?: CorporateStatementLineCreateOrConnectWithoutStatementInput | CorporateStatementLineCreateOrConnectWithoutStatementInput[]
    createMany?: CorporateStatementLineCreateManyStatementInputEnvelope
    connect?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutStatementsNestedInput = {
    create?: XOR<CompanyCreateWithoutStatementsInput, CompanyUncheckedCreateWithoutStatementsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutStatementsInput
    upsert?: CompanyUpsertWithoutStatementsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutStatementsInput, CompanyUpdateWithoutStatementsInput>, CompanyUncheckedUpdateWithoutStatementsInput>
  }

  export type CorporateStatementLineUpdateManyWithoutStatementNestedInput = {
    create?: XOR<CorporateStatementLineCreateWithoutStatementInput, CorporateStatementLineUncheckedCreateWithoutStatementInput> | CorporateStatementLineCreateWithoutStatementInput[] | CorporateStatementLineUncheckedCreateWithoutStatementInput[]
    connectOrCreate?: CorporateStatementLineCreateOrConnectWithoutStatementInput | CorporateStatementLineCreateOrConnectWithoutStatementInput[]
    upsert?: CorporateStatementLineUpsertWithWhereUniqueWithoutStatementInput | CorporateStatementLineUpsertWithWhereUniqueWithoutStatementInput[]
    createMany?: CorporateStatementLineCreateManyStatementInputEnvelope
    set?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    disconnect?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    delete?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    connect?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    update?: CorporateStatementLineUpdateWithWhereUniqueWithoutStatementInput | CorporateStatementLineUpdateWithWhereUniqueWithoutStatementInput[]
    updateMany?: CorporateStatementLineUpdateManyWithWhereWithoutStatementInput | CorporateStatementLineUpdateManyWithWhereWithoutStatementInput[]
    deleteMany?: CorporateStatementLineScalarWhereInput | CorporateStatementLineScalarWhereInput[]
  }

  export type CorporateStatementLineUncheckedUpdateManyWithoutStatementNestedInput = {
    create?: XOR<CorporateStatementLineCreateWithoutStatementInput, CorporateStatementLineUncheckedCreateWithoutStatementInput> | CorporateStatementLineCreateWithoutStatementInput[] | CorporateStatementLineUncheckedCreateWithoutStatementInput[]
    connectOrCreate?: CorporateStatementLineCreateOrConnectWithoutStatementInput | CorporateStatementLineCreateOrConnectWithoutStatementInput[]
    upsert?: CorporateStatementLineUpsertWithWhereUniqueWithoutStatementInput | CorporateStatementLineUpsertWithWhereUniqueWithoutStatementInput[]
    createMany?: CorporateStatementLineCreateManyStatementInputEnvelope
    set?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    disconnect?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    delete?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    connect?: CorporateStatementLineWhereUniqueInput | CorporateStatementLineWhereUniqueInput[]
    update?: CorporateStatementLineUpdateWithWhereUniqueWithoutStatementInput | CorporateStatementLineUpdateWithWhereUniqueWithoutStatementInput[]
    updateMany?: CorporateStatementLineUpdateManyWithWhereWithoutStatementInput | CorporateStatementLineUpdateManyWithWhereWithoutStatementInput[]
    deleteMany?: CorporateStatementLineScalarWhereInput | CorporateStatementLineScalarWhereInput[]
  }

  export type CorporateStatementCreateNestedOneWithoutLinesInput = {
    create?: XOR<CorporateStatementCreateWithoutLinesInput, CorporateStatementUncheckedCreateWithoutLinesInput>
    connectOrCreate?: CorporateStatementCreateOrConnectWithoutLinesInput
    connect?: CorporateStatementWhereUniqueInput
  }

  export type CorporateStatementUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<CorporateStatementCreateWithoutLinesInput, CorporateStatementUncheckedCreateWithoutLinesInput>
    connectOrCreate?: CorporateStatementCreateOrConnectWithoutLinesInput
    upsert?: CorporateStatementUpsertWithoutLinesInput
    connect?: CorporateStatementWhereUniqueInput
    update?: XOR<XOR<CorporateStatementUpdateToOneWithWhereWithoutLinesInput, CorporateStatementUpdateWithoutLinesInput>, CorporateStatementUncheckedUpdateWithoutLinesInput>
  }

  export type CompanyCreateNestedOneWithoutResolutionsInput = {
    create?: XOR<CompanyCreateWithoutResolutionsInput, CompanyUncheckedCreateWithoutResolutionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutResolutionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutResolutionsNestedInput = {
    create?: XOR<CompanyCreateWithoutResolutionsInput, CompanyUncheckedCreateWithoutResolutionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutResolutionsInput
    upsert?: CompanyUpsertWithoutResolutionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutResolutionsInput, CompanyUpdateWithoutResolutionsInput>, CompanyUncheckedUpdateWithoutResolutionsInput>
  }

  export type PropertyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutUnitsInput
    upsert?: PropertyUpsertWithoutUnitsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutUnitsInput, PropertyUpdateWithoutUnitsInput>, PropertyUncheckedUpdateWithoutUnitsInput>
  }

  export type PropertyCreateNestedOneWithoutMortgagesInput = {
    create?: XOR<PropertyCreateWithoutMortgagesInput, PropertyUncheckedCreateWithoutMortgagesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMortgagesInput
    connect?: PropertyWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutMortgageInput = {
    create?: XOR<AttachmentCreateWithoutMortgageInput, AttachmentUncheckedCreateWithoutMortgageInput> | AttachmentCreateWithoutMortgageInput[] | AttachmentUncheckedCreateWithoutMortgageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMortgageInput | AttachmentCreateOrConnectWithoutMortgageInput[]
    createMany?: AttachmentCreateManyMortgageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutMortgageInput = {
    create?: XOR<AttachmentCreateWithoutMortgageInput, AttachmentUncheckedCreateWithoutMortgageInput> | AttachmentCreateWithoutMortgageInput[] | AttachmentUncheckedCreateWithoutMortgageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMortgageInput | AttachmentCreateOrConnectWithoutMortgageInput[]
    createMany?: AttachmentCreateManyMortgageInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutMortgagesNestedInput = {
    create?: XOR<PropertyCreateWithoutMortgagesInput, PropertyUncheckedCreateWithoutMortgagesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMortgagesInput
    upsert?: PropertyUpsertWithoutMortgagesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutMortgagesInput, PropertyUpdateWithoutMortgagesInput>, PropertyUncheckedUpdateWithoutMortgagesInput>
  }

  export type AttachmentUpdateManyWithoutMortgageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMortgageInput, AttachmentUncheckedCreateWithoutMortgageInput> | AttachmentCreateWithoutMortgageInput[] | AttachmentUncheckedCreateWithoutMortgageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMortgageInput | AttachmentCreateOrConnectWithoutMortgageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMortgageInput | AttachmentUpsertWithWhereUniqueWithoutMortgageInput[]
    createMany?: AttachmentCreateManyMortgageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMortgageInput | AttachmentUpdateWithWhereUniqueWithoutMortgageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMortgageInput | AttachmentUpdateManyWithWhereWithoutMortgageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutMortgageNestedInput = {
    create?: XOR<AttachmentCreateWithoutMortgageInput, AttachmentUncheckedCreateWithoutMortgageInput> | AttachmentCreateWithoutMortgageInput[] | AttachmentUncheckedCreateWithoutMortgageInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutMortgageInput | AttachmentCreateOrConnectWithoutMortgageInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutMortgageInput | AttachmentUpsertWithWhereUniqueWithoutMortgageInput[]
    createMany?: AttachmentCreateManyMortgageInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutMortgageInput | AttachmentUpdateWithWhereUniqueWithoutMortgageInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutMortgageInput | AttachmentUpdateManyWithWhereWithoutMortgageInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutRevenuesInput = {
    create?: XOR<PropertyCreateWithoutRevenuesInput, PropertyUncheckedCreateWithoutRevenuesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRevenuesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutRevenuesNestedInput = {
    create?: XOR<PropertyCreateWithoutRevenuesInput, PropertyUncheckedCreateWithoutRevenuesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRevenuesInput
    upsert?: PropertyUpsertWithoutRevenuesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutRevenuesInput, PropertyUpdateWithoutRevenuesInput>, PropertyUncheckedUpdateWithoutRevenuesInput>
  }

  export type PropertyCreateNestedOneWithoutExpensesInput = {
    create?: XOR<PropertyCreateWithoutExpensesInput, PropertyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutExpensesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<PropertyCreateWithoutExpensesInput, PropertyUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutExpensesInput
    upsert?: PropertyUpsertWithoutExpensesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutExpensesInput, PropertyUpdateWithoutExpensesInput>, PropertyUncheckedUpdateWithoutExpensesInput>
  }

  export type PropertyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PropertyCreateWithoutInvoicesInput, PropertyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInvoicesInput
    connect?: PropertyWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PropertyCreateWithoutInvoicesInput, PropertyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInvoicesInput
    upsert?: PropertyUpsertWithoutInvoicesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutInvoicesInput, PropertyUpdateWithoutInvoicesInput>, PropertyUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PropertyCreateNestedOneWithoutDepreciationInfoInput = {
    create?: XOR<PropertyCreateWithoutDepreciationInfoInput, PropertyUncheckedCreateWithoutDepreciationInfoInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutDepreciationInfoInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutDepreciationInfoNestedInput = {
    create?: XOR<PropertyCreateWithoutDepreciationInfoInput, PropertyUncheckedCreateWithoutDepreciationInfoInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutDepreciationInfoInput
    upsert?: PropertyUpsertWithoutDepreciationInfoInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutDepreciationInfoInput, PropertyUpdateWithoutDepreciationInfoInput>, PropertyUncheckedUpdateWithoutDepreciationInfoInput>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserRolesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateOneWithoutUserRolesNestedInput = {
    create?: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserRolesInput
    upsert?: CompanyUpsertWithoutUserRolesInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUserRolesInput, CompanyUpdateWithoutUserRolesInput>, CompanyUncheckedUpdateWithoutUserRolesInput>
  }

  export type PropertyCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<PropertyCreateWithoutAttachmentsInput, PropertyUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAttachmentsInput
    connect?: PropertyWhereUniqueInput
  }

  export type MortgageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MortgageCreateWithoutAttachmentsInput, MortgageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MortgageCreateOrConnectWithoutAttachmentsInput
    connect?: MortgageWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<PropertyCreateWithoutAttachmentsInput, PropertyUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAttachmentsInput
    upsert?: PropertyUpsertWithoutAttachmentsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutAttachmentsInput, PropertyUpdateWithoutAttachmentsInput>, PropertyUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MortgageUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<MortgageCreateWithoutAttachmentsInput, MortgageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MortgageCreateOrConnectWithoutAttachmentsInput
    upsert?: MortgageUpsertWithoutAttachmentsInput
    disconnect?: MortgageWhereInput | boolean
    delete?: MortgageWhereInput | boolean
    connect?: MortgageWhereUniqueInput
    update?: XOR<XOR<MortgageUpdateToOneWithWhereWithoutAttachmentsInput, MortgageUpdateWithoutAttachmentsInput>, MortgageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PropertyCreateWithoutUserInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateManyUserInputEnvelope = {
    data: PropertyCreateManyUserInput | PropertyCreateManyUserInput[]
  }

  export type CompanyCreateWithoutUserInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type CompanyCreateManyUserInputEnvelope = {
    data: CompanyCreateManyUserInput | CompanyCreateManyUserInput[]
  }

  export type ShareholderCreateWithoutUserInput = {
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyShareholderCreateNestedManyWithoutShareholderInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderUncheckedCreateWithoutUserInput = {
    id?: number
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyShareholderUncheckedCreateNestedManyWithoutShareholderInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderCreateOrConnectWithoutUserInput = {
    where: ShareholderWhereUniqueInput
    create: XOR<ShareholderCreateWithoutUserInput, ShareholderUncheckedCreateWithoutUserInput>
  }

  export type ShareholderCreateManyUserInputEnvelope = {
    data: ShareholderCreateManyUserInput | ShareholderCreateManyUserInput[]
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
    company?: CompanyCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    companyId?: number | null
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
  }

  export type PropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithWhereWithoutUserInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: IntFilter<"Property"> | number
    userId?: IntFilter<"Property"> | number
    companyId?: IntNullableFilter<"Property"> | number | null
    name?: StringFilter<"Property"> | string
    address?: StringNullableFilter<"Property"> | string | null
    acquisitionDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    purchasePrice?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
  }

  export type CompanyUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUpdateManyWithWhereWithoutUserInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: IntFilter<"Company"> | number
    userId?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    neq?: StringNullableFilter<"Company"> | string | null
    fiscalYearEnd?: DateTimeNullableFilter<"Company"> | Date | string | null
    province?: StringNullableFilter<"Company"> | string | null
    notes?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type ShareholderUpsertWithWhereUniqueWithoutUserInput = {
    where: ShareholderWhereUniqueInput
    update: XOR<ShareholderUpdateWithoutUserInput, ShareholderUncheckedUpdateWithoutUserInput>
    create: XOR<ShareholderCreateWithoutUserInput, ShareholderUncheckedCreateWithoutUserInput>
  }

  export type ShareholderUpdateWithWhereUniqueWithoutUserInput = {
    where: ShareholderWhereUniqueInput
    data: XOR<ShareholderUpdateWithoutUserInput, ShareholderUncheckedUpdateWithoutUserInput>
  }

  export type ShareholderUpdateManyWithWhereWithoutUserInput = {
    where: ShareholderScalarWhereInput
    data: XOR<ShareholderUpdateManyMutationInput, ShareholderUncheckedUpdateManyWithoutUserInput>
  }

  export type ShareholderScalarWhereInput = {
    AND?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
    OR?: ShareholderScalarWhereInput[]
    NOT?: ShareholderScalarWhereInput | ShareholderScalarWhereInput[]
    id?: IntFilter<"Shareholder"> | number
    userId?: IntFilter<"Shareholder"> | number
    type?: StringFilter<"Shareholder"> | string
    displayName?: StringFilter<"Shareholder"> | string
    contactEmail?: StringNullableFilter<"Shareholder"> | string | null
    contactPhone?: StringNullableFilter<"Shareholder"> | string | null
    notes?: StringNullableFilter<"Shareholder"> | string | null
    createdAt?: DateTimeFilter<"Shareholder"> | Date | string
    updatedAt?: DateTimeFilter<"Shareholder"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: IntFilter<"UserRole"> | number
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    companyId?: IntNullableFilter<"UserRole"> | number | null
  }

  export type UserCreateWithoutPropertiesInput = {
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyCreateNestedManyWithoutUserInput
    shareholders?: ShareholderCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPropertiesInput = {
    id?: number
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPropertiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
  }

  export type CompanyCreateWithoutPropertiesInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPropertiesInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPropertiesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPropertiesInput, CompanyUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyUnitCreateWithoutPropertyInput = {
    label: string
    squareFeet?: number | null
    rentExpected?: Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitUncheckedCreateWithoutPropertyInput = {
    id?: number
    label: string
    squareFeet?: number | null
    rentExpected?: Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitCreateOrConnectWithoutPropertyInput = {
    where: PropertyUnitWhereUniqueInput
    create: XOR<PropertyUnitCreateWithoutPropertyInput, PropertyUnitUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyUnitCreateManyPropertyInputEnvelope = {
    data: PropertyUnitCreateManyPropertyInput | PropertyUnitCreateManyPropertyInput[]
  }

  export type MortgageCreateWithoutPropertyInput = {
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutMortgageInput
  }

  export type MortgageUncheckedCreateWithoutPropertyInput = {
    id?: number
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutMortgageInput
  }

  export type MortgageCreateOrConnectWithoutPropertyInput = {
    where: MortgageWhereUniqueInput
    create: XOR<MortgageCreateWithoutPropertyInput, MortgageUncheckedCreateWithoutPropertyInput>
  }

  export type MortgageCreateManyPropertyInputEnvelope = {
    data: MortgageCreateManyPropertyInput | MortgageCreateManyPropertyInput[]
  }

  export type RevenueCreateWithoutPropertyInput = {
    label: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueUncheckedCreateWithoutPropertyInput = {
    id?: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueCreateOrConnectWithoutPropertyInput = {
    where: RevenueWhereUniqueInput
    create: XOR<RevenueCreateWithoutPropertyInput, RevenueUncheckedCreateWithoutPropertyInput>
  }

  export type RevenueCreateManyPropertyInputEnvelope = {
    data: RevenueCreateManyPropertyInput | RevenueCreateManyPropertyInput[]
  }

  export type ExpenseCreateWithoutPropertyInput = {
    label: string
    category: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUncheckedCreateWithoutPropertyInput = {
    id?: number
    label: string
    category: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutPropertyInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput>
  }

  export type ExpenseCreateManyPropertyInputEnvelope = {
    data: ExpenseCreateManyPropertyInput | ExpenseCreateManyPropertyInput[]
  }

  export type InvoiceCreateWithoutPropertyInput = {
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPropertyInput = {
    id?: number
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPropertyInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPropertyInput, InvoiceUncheckedCreateWithoutPropertyInput>
  }

  export type InvoiceCreateManyPropertyInputEnvelope = {
    data: InvoiceCreateManyPropertyInput | InvoiceCreateManyPropertyInput[]
  }

  export type DepreciationSettingCreateWithoutPropertyInput = {
    classCode: string
    ccaRate: Decimal | DecimalJsLike | number | string
    openingUcc: Decimal | DecimalJsLike | number | string
    additions: Decimal | DecimalJsLike | number | string
    dispositions: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationSettingUncheckedCreateWithoutPropertyInput = {
    id?: number
    classCode: string
    ccaRate: Decimal | DecimalJsLike | number | string
    openingUcc: Decimal | DecimalJsLike | number | string
    additions: Decimal | DecimalJsLike | number | string
    dispositions: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationSettingCreateOrConnectWithoutPropertyInput = {
    where: DepreciationSettingWhereUniqueInput
    create: XOR<DepreciationSettingCreateWithoutPropertyInput, DepreciationSettingUncheckedCreateWithoutPropertyInput>
  }

  export type AttachmentCreateWithoutPropertyInput = {
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mortgage?: MortgageCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutPropertyInput = {
    id?: number
    mortgageId?: number | null
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutPropertyInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutPropertyInput, AttachmentUncheckedCreateWithoutPropertyInput>
  }

  export type AttachmentCreateManyPropertyInputEnvelope = {
    data: AttachmentCreateManyPropertyInput | AttachmentCreateManyPropertyInput[]
  }

  export type UserUpsertWithoutPropertiesInput = {
    update: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserUpdateWithoutPropertiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutPropertiesInput = {
    update: XOR<CompanyUpdateWithoutPropertiesInput, CompanyUncheckedUpdateWithoutPropertiesInput>
    create: XOR<CompanyCreateWithoutPropertiesInput, CompanyUncheckedCreateWithoutPropertiesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPropertiesInput, CompanyUncheckedUpdateWithoutPropertiesInput>
  }

  export type CompanyUpdateWithoutPropertiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPropertiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PropertyUnitUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyUnitWhereUniqueInput
    update: XOR<PropertyUnitUpdateWithoutPropertyInput, PropertyUnitUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyUnitCreateWithoutPropertyInput, PropertyUnitUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyUnitUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyUnitWhereUniqueInput
    data: XOR<PropertyUnitUpdateWithoutPropertyInput, PropertyUnitUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyUnitUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyUnitScalarWhereInput
    data: XOR<PropertyUnitUpdateManyMutationInput, PropertyUnitUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyUnitScalarWhereInput = {
    AND?: PropertyUnitScalarWhereInput | PropertyUnitScalarWhereInput[]
    OR?: PropertyUnitScalarWhereInput[]
    NOT?: PropertyUnitScalarWhereInput | PropertyUnitScalarWhereInput[]
    id?: IntFilter<"PropertyUnit"> | number
    propertyId?: IntFilter<"PropertyUnit"> | number
    label?: StringFilter<"PropertyUnit"> | string
    squareFeet?: IntNullableFilter<"PropertyUnit"> | number | null
    rentExpected?: DecimalNullableFilter<"PropertyUnit"> | Decimal | DecimalJsLike | number | string | null
  }

  export type MortgageUpsertWithWhereUniqueWithoutPropertyInput = {
    where: MortgageWhereUniqueInput
    update: XOR<MortgageUpdateWithoutPropertyInput, MortgageUncheckedUpdateWithoutPropertyInput>
    create: XOR<MortgageCreateWithoutPropertyInput, MortgageUncheckedCreateWithoutPropertyInput>
  }

  export type MortgageUpdateWithWhereUniqueWithoutPropertyInput = {
    where: MortgageWhereUniqueInput
    data: XOR<MortgageUpdateWithoutPropertyInput, MortgageUncheckedUpdateWithoutPropertyInput>
  }

  export type MortgageUpdateManyWithWhereWithoutPropertyInput = {
    where: MortgageScalarWhereInput
    data: XOR<MortgageUpdateManyMutationInput, MortgageUncheckedUpdateManyWithoutPropertyInput>
  }

  export type MortgageScalarWhereInput = {
    AND?: MortgageScalarWhereInput | MortgageScalarWhereInput[]
    OR?: MortgageScalarWhereInput[]
    NOT?: MortgageScalarWhereInput | MortgageScalarWhereInput[]
    id?: IntFilter<"Mortgage"> | number
    propertyId?: IntFilter<"Mortgage"> | number
    lender?: StringFilter<"Mortgage"> | string
    principal?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    termMonths?: IntFilter<"Mortgage"> | number
    amortizationMonths?: IntFilter<"Mortgage"> | number
    startDate?: DateTimeFilter<"Mortgage"> | Date | string
    paymentFrequency?: IntFilter<"Mortgage"> | number
    paymentAmount?: DecimalFilter<"Mortgage"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Mortgage"> | Date | string
    updatedAt?: DateTimeFilter<"Mortgage"> | Date | string
  }

  export type RevenueUpsertWithWhereUniqueWithoutPropertyInput = {
    where: RevenueWhereUniqueInput
    update: XOR<RevenueUpdateWithoutPropertyInput, RevenueUncheckedUpdateWithoutPropertyInput>
    create: XOR<RevenueCreateWithoutPropertyInput, RevenueUncheckedCreateWithoutPropertyInput>
  }

  export type RevenueUpdateWithWhereUniqueWithoutPropertyInput = {
    where: RevenueWhereUniqueInput
    data: XOR<RevenueUpdateWithoutPropertyInput, RevenueUncheckedUpdateWithoutPropertyInput>
  }

  export type RevenueUpdateManyWithWhereWithoutPropertyInput = {
    where: RevenueScalarWhereInput
    data: XOR<RevenueUpdateManyMutationInput, RevenueUncheckedUpdateManyWithoutPropertyInput>
  }

  export type RevenueScalarWhereInput = {
    AND?: RevenueScalarWhereInput | RevenueScalarWhereInput[]
    OR?: RevenueScalarWhereInput[]
    NOT?: RevenueScalarWhereInput | RevenueScalarWhereInput[]
    id?: IntFilter<"Revenue"> | number
    propertyId?: IntFilter<"Revenue"> | number
    label?: StringFilter<"Revenue"> | string
    amount?: DecimalFilter<"Revenue"> | Decimal | DecimalJsLike | number | string
    frequency?: StringFilter<"Revenue"> | string
    startDate?: DateTimeFilter<"Revenue"> | Date | string
    endDate?: DateTimeNullableFilter<"Revenue"> | Date | string | null
    createdAt?: DateTimeFilter<"Revenue"> | Date | string
    updatedAt?: DateTimeFilter<"Revenue"> | Date | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutPropertyInput, ExpenseUncheckedUpdateWithoutPropertyInput>
    create: XOR<ExpenseCreateWithoutPropertyInput, ExpenseUncheckedCreateWithoutPropertyInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutPropertyInput, ExpenseUncheckedUpdateWithoutPropertyInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutPropertyInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: IntFilter<"Expense"> | number
    propertyId?: IntFilter<"Expense"> | number
    label?: StringFilter<"Expense"> | string
    category?: StringFilter<"Expense"> | string
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    frequency?: StringFilter<"Expense"> | string
    startDate?: DateTimeFilter<"Expense"> | Date | string
    endDate?: DateTimeNullableFilter<"Expense"> | Date | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPropertyInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPropertyInput, InvoiceUncheckedUpdateWithoutPropertyInput>
    create: XOR<InvoiceCreateWithoutPropertyInput, InvoiceUncheckedCreateWithoutPropertyInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPropertyInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPropertyInput, InvoiceUncheckedUpdateWithoutPropertyInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPropertyInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPropertyInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    propertyId?: IntFilter<"Invoice"> | number
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    supplier?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"Invoice"> | string
    gst?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    qst?: DecimalNullableFilter<"Invoice"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type DepreciationSettingUpsertWithoutPropertyInput = {
    update: XOR<DepreciationSettingUpdateWithoutPropertyInput, DepreciationSettingUncheckedUpdateWithoutPropertyInput>
    create: XOR<DepreciationSettingCreateWithoutPropertyInput, DepreciationSettingUncheckedCreateWithoutPropertyInput>
    where?: DepreciationSettingWhereInput
  }

  export type DepreciationSettingUpdateToOneWithWhereWithoutPropertyInput = {
    where?: DepreciationSettingWhereInput
    data: XOR<DepreciationSettingUpdateWithoutPropertyInput, DepreciationSettingUncheckedUpdateWithoutPropertyInput>
  }

  export type DepreciationSettingUpdateWithoutPropertyInput = {
    classCode?: StringFieldUpdateOperationsInput | string
    ccaRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    additions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationSettingUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classCode?: StringFieldUpdateOperationsInput | string
    ccaRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    openingUcc?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    additions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dispositions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpsertWithWhereUniqueWithoutPropertyInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutPropertyInput, AttachmentUncheckedUpdateWithoutPropertyInput>
    create: XOR<AttachmentCreateWithoutPropertyInput, AttachmentUncheckedCreateWithoutPropertyInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutPropertyInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutPropertyInput, AttachmentUncheckedUpdateWithoutPropertyInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutPropertyInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutPropertyInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: IntFilter<"Attachment"> | number
    propertyId?: IntFilter<"Attachment"> | number
    mortgageId?: IntNullableFilter<"Attachment"> | number | null
    title?: StringFilter<"Attachment"> | string
    filename?: StringFilter<"Attachment"> | string
    contentType?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    storagePath?: StringFilter<"Attachment"> | string
    checksum?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    updatedAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type UserCreateWithoutCompaniesInput = {
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutUserInput
    shareholders?: ShareholderCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: number
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type PropertyCreateWithoutCompanyInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCompanyInput = {
    id?: number
    userId: number
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCompanyInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCompanyInput, PropertyUncheckedCreateWithoutCompanyInput>
  }

  export type PropertyCreateManyCompanyInputEnvelope = {
    data: PropertyCreateManyCompanyInput | PropertyCreateManyCompanyInput[]
  }

  export type CompanyShareholderCreateWithoutCompanyInput = {
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shareholder: ShareholderCreateNestedOneWithoutCompaniesInput
  }

  export type CompanyShareholderUncheckedCreateWithoutCompanyInput = {
    id?: number
    shareholderId: number
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyShareholderCreateOrConnectWithoutCompanyInput = {
    where: CompanyShareholderWhereUniqueInput
    create: XOR<CompanyShareholderCreateWithoutCompanyInput, CompanyShareholderUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyShareholderCreateManyCompanyInputEnvelope = {
    data: CompanyShareholderCreateManyCompanyInput | CompanyShareholderCreateManyCompanyInput[]
  }

  export type ShareClassCreateWithoutCompanyInput = {
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: ShareTransactionCreateNestedManyWithoutShareClassInput
  }

  export type ShareClassUncheckedCreateWithoutCompanyInput = {
    id?: number
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: ShareTransactionUncheckedCreateNestedManyWithoutShareClassInput
  }

  export type ShareClassCreateOrConnectWithoutCompanyInput = {
    where: ShareClassWhereUniqueInput
    create: XOR<ShareClassCreateWithoutCompanyInput, ShareClassUncheckedCreateWithoutCompanyInput>
  }

  export type ShareClassCreateManyCompanyInputEnvelope = {
    data: ShareClassCreateManyCompanyInput | ShareClassCreateManyCompanyInput[]
  }

  export type ShareTransactionCreateWithoutCompanyInput = {
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shareClass: ShareClassCreateNestedOneWithoutTransactionsInput
    shareholder: ShareholderCreateNestedOneWithoutShareTransactionsInput
  }

  export type ShareTransactionUncheckedCreateWithoutCompanyInput = {
    id?: number
    shareClassId: number
    shareholderId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionCreateOrConnectWithoutCompanyInput = {
    where: ShareTransactionWhereUniqueInput
    create: XOR<ShareTransactionCreateWithoutCompanyInput, ShareTransactionUncheckedCreateWithoutCompanyInput>
  }

  export type ShareTransactionCreateManyCompanyInputEnvelope = {
    data: ShareTransactionCreateManyCompanyInput | ShareTransactionCreateManyCompanyInput[]
  }

  export type CorporateStatementCreateWithoutCompanyInput = {
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: CorporateStatementLineCreateNestedManyWithoutStatementInput
  }

  export type CorporateStatementUncheckedCreateWithoutCompanyInput = {
    id?: number
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: CorporateStatementLineUncheckedCreateNestedManyWithoutStatementInput
  }

  export type CorporateStatementCreateOrConnectWithoutCompanyInput = {
    where: CorporateStatementWhereUniqueInput
    create: XOR<CorporateStatementCreateWithoutCompanyInput, CorporateStatementUncheckedCreateWithoutCompanyInput>
  }

  export type CorporateStatementCreateManyCompanyInputEnvelope = {
    data: CorporateStatementCreateManyCompanyInput | CorporateStatementCreateManyCompanyInput[]
  }

  export type CorporateResolutionCreateWithoutCompanyInput = {
    type: string
    title: string
    resolutionDate: Date | string
    body?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateResolutionUncheckedCreateWithoutCompanyInput = {
    id?: number
    type: string
    title: string
    resolutionDate: Date | string
    body?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateResolutionCreateOrConnectWithoutCompanyInput = {
    where: CorporateResolutionWhereUniqueInput
    create: XOR<CorporateResolutionCreateWithoutCompanyInput, CorporateResolutionUncheckedCreateWithoutCompanyInput>
  }

  export type CorporateResolutionCreateManyCompanyInputEnvelope = {
    data: CorporateResolutionCreateManyCompanyInput | CorporateResolutionCreateManyCompanyInput[]
  }

  export type UserRoleCreateWithoutCompanyInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutCompanyInput = {
    id?: number
    userId: number
    roleId: number
  }

  export type UserRoleCreateOrConnectWithoutCompanyInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput>
  }

  export type UserRoleCreateManyCompanyInputEnvelope = {
    data: UserRoleCreateManyCompanyInput | UserRoleCreateManyCompanyInput[]
  }

  export type UserUpsertWithoutCompaniesInput = {
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateWithoutCompaniesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutCompanyInput, PropertyUncheckedUpdateWithoutCompanyInput>
    create: XOR<PropertyCreateWithoutCompanyInput, PropertyUncheckedCreateWithoutCompanyInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutCompanyInput, PropertyUncheckedUpdateWithoutCompanyInput>
  }

  export type PropertyUpdateManyWithWhereWithoutCompanyInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyShareholderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyShareholderWhereUniqueInput
    update: XOR<CompanyShareholderUpdateWithoutCompanyInput, CompanyShareholderUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyShareholderCreateWithoutCompanyInput, CompanyShareholderUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyShareholderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyShareholderWhereUniqueInput
    data: XOR<CompanyShareholderUpdateWithoutCompanyInput, CompanyShareholderUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyShareholderUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyShareholderScalarWhereInput
    data: XOR<CompanyShareholderUpdateManyMutationInput, CompanyShareholderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyShareholderScalarWhereInput = {
    AND?: CompanyShareholderScalarWhereInput | CompanyShareholderScalarWhereInput[]
    OR?: CompanyShareholderScalarWhereInput[]
    NOT?: CompanyShareholderScalarWhereInput | CompanyShareholderScalarWhereInput[]
    id?: IntFilter<"CompanyShareholder"> | number
    companyId?: IntFilter<"CompanyShareholder"> | number
    shareholderId?: IntFilter<"CompanyShareholder"> | number
    role?: StringNullableFilter<"CompanyShareholder"> | string | null
    votingPercent?: DecimalNullableFilter<"CompanyShareholder"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CompanyShareholder"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyShareholder"> | Date | string
  }

  export type ShareClassUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ShareClassWhereUniqueInput
    update: XOR<ShareClassUpdateWithoutCompanyInput, ShareClassUncheckedUpdateWithoutCompanyInput>
    create: XOR<ShareClassCreateWithoutCompanyInput, ShareClassUncheckedCreateWithoutCompanyInput>
  }

  export type ShareClassUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ShareClassWhereUniqueInput
    data: XOR<ShareClassUpdateWithoutCompanyInput, ShareClassUncheckedUpdateWithoutCompanyInput>
  }

  export type ShareClassUpdateManyWithWhereWithoutCompanyInput = {
    where: ShareClassScalarWhereInput
    data: XOR<ShareClassUpdateManyMutationInput, ShareClassUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShareClassScalarWhereInput = {
    AND?: ShareClassScalarWhereInput | ShareClassScalarWhereInput[]
    OR?: ShareClassScalarWhereInput[]
    NOT?: ShareClassScalarWhereInput | ShareClassScalarWhereInput[]
    id?: IntFilter<"ShareClass"> | number
    companyId?: IntFilter<"ShareClass"> | number
    code?: StringFilter<"ShareClass"> | string
    description?: StringNullableFilter<"ShareClass"> | string | null
    hasVotingRights?: BoolFilter<"ShareClass"> | boolean
    participatesInGrowth?: BoolFilter<"ShareClass"> | boolean
    dividendPolicy?: StringNullableFilter<"ShareClass"> | string | null
    createdAt?: DateTimeFilter<"ShareClass"> | Date | string
    updatedAt?: DateTimeFilter<"ShareClass"> | Date | string
  }

  export type ShareTransactionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ShareTransactionWhereUniqueInput
    update: XOR<ShareTransactionUpdateWithoutCompanyInput, ShareTransactionUncheckedUpdateWithoutCompanyInput>
    create: XOR<ShareTransactionCreateWithoutCompanyInput, ShareTransactionUncheckedCreateWithoutCompanyInput>
  }

  export type ShareTransactionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ShareTransactionWhereUniqueInput
    data: XOR<ShareTransactionUpdateWithoutCompanyInput, ShareTransactionUncheckedUpdateWithoutCompanyInput>
  }

  export type ShareTransactionUpdateManyWithWhereWithoutCompanyInput = {
    where: ShareTransactionScalarWhereInput
    data: XOR<ShareTransactionUpdateManyMutationInput, ShareTransactionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ShareTransactionScalarWhereInput = {
    AND?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
    OR?: ShareTransactionScalarWhereInput[]
    NOT?: ShareTransactionScalarWhereInput | ShareTransactionScalarWhereInput[]
    id?: IntFilter<"ShareTransaction"> | number
    companyId?: IntFilter<"ShareTransaction"> | number
    shareClassId?: IntFilter<"ShareTransaction"> | number
    shareholderId?: IntFilter<"ShareTransaction"> | number
    type?: StringFilter<"ShareTransaction"> | string
    transactionDate?: DateTimeFilter<"ShareTransaction"> | Date | string
    quantity?: DecimalFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string
    pricePerShare?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: DecimalNullableFilter<"ShareTransaction"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"ShareTransaction"> | string | null
    createdAt?: DateTimeFilter<"ShareTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"ShareTransaction"> | Date | string
  }

  export type CorporateStatementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CorporateStatementWhereUniqueInput
    update: XOR<CorporateStatementUpdateWithoutCompanyInput, CorporateStatementUncheckedUpdateWithoutCompanyInput>
    create: XOR<CorporateStatementCreateWithoutCompanyInput, CorporateStatementUncheckedCreateWithoutCompanyInput>
  }

  export type CorporateStatementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CorporateStatementWhereUniqueInput
    data: XOR<CorporateStatementUpdateWithoutCompanyInput, CorporateStatementUncheckedUpdateWithoutCompanyInput>
  }

  export type CorporateStatementUpdateManyWithWhereWithoutCompanyInput = {
    where: CorporateStatementScalarWhereInput
    data: XOR<CorporateStatementUpdateManyMutationInput, CorporateStatementUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CorporateStatementScalarWhereInput = {
    AND?: CorporateStatementScalarWhereInput | CorporateStatementScalarWhereInput[]
    OR?: CorporateStatementScalarWhereInput[]
    NOT?: CorporateStatementScalarWhereInput | CorporateStatementScalarWhereInput[]
    id?: IntFilter<"CorporateStatement"> | number
    companyId?: IntFilter<"CorporateStatement"> | number
    statementType?: StringFilter<"CorporateStatement"> | string
    periodStart?: DateTimeFilter<"CorporateStatement"> | Date | string
    periodEnd?: DateTimeFilter<"CorporateStatement"> | Date | string
    isAudited?: BoolFilter<"CorporateStatement"> | boolean
    totalAssets?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFilter<"CorporateStatement"> | Decimal | DecimalJsLike | number | string
    metadata?: StringNullableFilter<"CorporateStatement"> | string | null
    createdAt?: DateTimeFilter<"CorporateStatement"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateStatement"> | Date | string
  }

  export type CorporateResolutionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CorporateResolutionWhereUniqueInput
    update: XOR<CorporateResolutionUpdateWithoutCompanyInput, CorporateResolutionUncheckedUpdateWithoutCompanyInput>
    create: XOR<CorporateResolutionCreateWithoutCompanyInput, CorporateResolutionUncheckedCreateWithoutCompanyInput>
  }

  export type CorporateResolutionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CorporateResolutionWhereUniqueInput
    data: XOR<CorporateResolutionUpdateWithoutCompanyInput, CorporateResolutionUncheckedUpdateWithoutCompanyInput>
  }

  export type CorporateResolutionUpdateManyWithWhereWithoutCompanyInput = {
    where: CorporateResolutionScalarWhereInput
    data: XOR<CorporateResolutionUpdateManyMutationInput, CorporateResolutionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CorporateResolutionScalarWhereInput = {
    AND?: CorporateResolutionScalarWhereInput | CorporateResolutionScalarWhereInput[]
    OR?: CorporateResolutionScalarWhereInput[]
    NOT?: CorporateResolutionScalarWhereInput | CorporateResolutionScalarWhereInput[]
    id?: IntFilter<"CorporateResolution"> | number
    companyId?: IntFilter<"CorporateResolution"> | number
    type?: StringFilter<"CorporateResolution"> | string
    title?: StringFilter<"CorporateResolution"> | string
    resolutionDate?: DateTimeFilter<"CorporateResolution"> | Date | string
    body?: StringNullableFilter<"CorporateResolution"> | string | null
    metadata?: StringNullableFilter<"CorporateResolution"> | string | null
    createdAt?: DateTimeFilter<"CorporateResolution"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateResolution"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutCompanyInput, UserRoleUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserRoleCreateWithoutCompanyInput, UserRoleUncheckedCreateWithoutCompanyInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutCompanyInput, UserRoleUncheckedUpdateWithoutCompanyInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutCompanyInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserCreateWithoutShareholdersInput = {
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutUserInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShareholdersInput = {
    id?: number
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShareholdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShareholdersInput, UserUncheckedCreateWithoutShareholdersInput>
  }

  export type CompanyShareholderCreateWithoutShareholderInput = {
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareholderLinksInput
  }

  export type CompanyShareholderUncheckedCreateWithoutShareholderInput = {
    id?: number
    companyId: number
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyShareholderCreateOrConnectWithoutShareholderInput = {
    where: CompanyShareholderWhereUniqueInput
    create: XOR<CompanyShareholderCreateWithoutShareholderInput, CompanyShareholderUncheckedCreateWithoutShareholderInput>
  }

  export type CompanyShareholderCreateManyShareholderInputEnvelope = {
    data: CompanyShareholderCreateManyShareholderInput | CompanyShareholderCreateManyShareholderInput[]
  }

  export type ShareTransactionCreateWithoutShareholderInput = {
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareTransactionsInput
    shareClass: ShareClassCreateNestedOneWithoutTransactionsInput
  }

  export type ShareTransactionUncheckedCreateWithoutShareholderInput = {
    id?: number
    companyId: number
    shareClassId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionCreateOrConnectWithoutShareholderInput = {
    where: ShareTransactionWhereUniqueInput
    create: XOR<ShareTransactionCreateWithoutShareholderInput, ShareTransactionUncheckedCreateWithoutShareholderInput>
  }

  export type ShareTransactionCreateManyShareholderInputEnvelope = {
    data: ShareTransactionCreateManyShareholderInput | ShareTransactionCreateManyShareholderInput[]
  }

  export type UserUpsertWithoutShareholdersInput = {
    update: XOR<UserUpdateWithoutShareholdersInput, UserUncheckedUpdateWithoutShareholdersInput>
    create: XOR<UserCreateWithoutShareholdersInput, UserUncheckedCreateWithoutShareholdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShareholdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShareholdersInput, UserUncheckedUpdateWithoutShareholdersInput>
  }

  export type UserUpdateWithoutShareholdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutUserNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShareholdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyShareholderUpsertWithWhereUniqueWithoutShareholderInput = {
    where: CompanyShareholderWhereUniqueInput
    update: XOR<CompanyShareholderUpdateWithoutShareholderInput, CompanyShareholderUncheckedUpdateWithoutShareholderInput>
    create: XOR<CompanyShareholderCreateWithoutShareholderInput, CompanyShareholderUncheckedCreateWithoutShareholderInput>
  }

  export type CompanyShareholderUpdateWithWhereUniqueWithoutShareholderInput = {
    where: CompanyShareholderWhereUniqueInput
    data: XOR<CompanyShareholderUpdateWithoutShareholderInput, CompanyShareholderUncheckedUpdateWithoutShareholderInput>
  }

  export type CompanyShareholderUpdateManyWithWhereWithoutShareholderInput = {
    where: CompanyShareholderScalarWhereInput
    data: XOR<CompanyShareholderUpdateManyMutationInput, CompanyShareholderUncheckedUpdateManyWithoutShareholderInput>
  }

  export type ShareTransactionUpsertWithWhereUniqueWithoutShareholderInput = {
    where: ShareTransactionWhereUniqueInput
    update: XOR<ShareTransactionUpdateWithoutShareholderInput, ShareTransactionUncheckedUpdateWithoutShareholderInput>
    create: XOR<ShareTransactionCreateWithoutShareholderInput, ShareTransactionUncheckedCreateWithoutShareholderInput>
  }

  export type ShareTransactionUpdateWithWhereUniqueWithoutShareholderInput = {
    where: ShareTransactionWhereUniqueInput
    data: XOR<ShareTransactionUpdateWithoutShareholderInput, ShareTransactionUncheckedUpdateWithoutShareholderInput>
  }

  export type ShareTransactionUpdateManyWithWhereWithoutShareholderInput = {
    where: ShareTransactionScalarWhereInput
    data: XOR<ShareTransactionUpdateManyMutationInput, ShareTransactionUncheckedUpdateManyWithoutShareholderInput>
  }

  export type CompanyCreateWithoutShareholderLinksInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutShareholderLinksInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutShareholderLinksInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutShareholderLinksInput, CompanyUncheckedCreateWithoutShareholderLinksInput>
  }

  export type ShareholderCreateWithoutCompaniesInput = {
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShareholdersInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderUncheckedCreateWithoutCompaniesInput = {
    id?: number
    userId: number
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderCreateOrConnectWithoutCompaniesInput = {
    where: ShareholderWhereUniqueInput
    create: XOR<ShareholderCreateWithoutCompaniesInput, ShareholderUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyUpsertWithoutShareholderLinksInput = {
    update: XOR<CompanyUpdateWithoutShareholderLinksInput, CompanyUncheckedUpdateWithoutShareholderLinksInput>
    create: XOR<CompanyCreateWithoutShareholderLinksInput, CompanyUncheckedCreateWithoutShareholderLinksInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutShareholderLinksInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutShareholderLinksInput, CompanyUncheckedUpdateWithoutShareholderLinksInput>
  }

  export type CompanyUpdateWithoutShareholderLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutShareholderLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ShareholderUpsertWithoutCompaniesInput = {
    update: XOR<ShareholderUpdateWithoutCompaniesInput, ShareholderUncheckedUpdateWithoutCompaniesInput>
    create: XOR<ShareholderCreateWithoutCompaniesInput, ShareholderUncheckedCreateWithoutCompaniesInput>
    where?: ShareholderWhereInput
  }

  export type ShareholderUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: ShareholderWhereInput
    data: XOR<ShareholderUpdateWithoutCompaniesInput, ShareholderUncheckedUpdateWithoutCompaniesInput>
  }

  export type ShareholderUpdateWithoutCompaniesInput = {
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShareholdersNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutShareholderNestedInput
  }

  export type ShareholderUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutShareholderNestedInput
  }

  export type CompanyCreateWithoutShareClassesInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutShareClassesInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutShareClassesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutShareClassesInput, CompanyUncheckedCreateWithoutShareClassesInput>
  }

  export type ShareTransactionCreateWithoutShareClassInput = {
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareTransactionsInput
    shareholder: ShareholderCreateNestedOneWithoutShareTransactionsInput
  }

  export type ShareTransactionUncheckedCreateWithoutShareClassInput = {
    id?: number
    companyId: number
    shareholderId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionCreateOrConnectWithoutShareClassInput = {
    where: ShareTransactionWhereUniqueInput
    create: XOR<ShareTransactionCreateWithoutShareClassInput, ShareTransactionUncheckedCreateWithoutShareClassInput>
  }

  export type ShareTransactionCreateManyShareClassInputEnvelope = {
    data: ShareTransactionCreateManyShareClassInput | ShareTransactionCreateManyShareClassInput[]
  }

  export type CompanyUpsertWithoutShareClassesInput = {
    update: XOR<CompanyUpdateWithoutShareClassesInput, CompanyUncheckedUpdateWithoutShareClassesInput>
    create: XOR<CompanyCreateWithoutShareClassesInput, CompanyUncheckedCreateWithoutShareClassesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutShareClassesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutShareClassesInput, CompanyUncheckedUpdateWithoutShareClassesInput>
  }

  export type CompanyUpdateWithoutShareClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutShareClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ShareTransactionUpsertWithWhereUniqueWithoutShareClassInput = {
    where: ShareTransactionWhereUniqueInput
    update: XOR<ShareTransactionUpdateWithoutShareClassInput, ShareTransactionUncheckedUpdateWithoutShareClassInput>
    create: XOR<ShareTransactionCreateWithoutShareClassInput, ShareTransactionUncheckedCreateWithoutShareClassInput>
  }

  export type ShareTransactionUpdateWithWhereUniqueWithoutShareClassInput = {
    where: ShareTransactionWhereUniqueInput
    data: XOR<ShareTransactionUpdateWithoutShareClassInput, ShareTransactionUncheckedUpdateWithoutShareClassInput>
  }

  export type ShareTransactionUpdateManyWithWhereWithoutShareClassInput = {
    where: ShareTransactionScalarWhereInput
    data: XOR<ShareTransactionUpdateManyMutationInput, ShareTransactionUncheckedUpdateManyWithoutShareClassInput>
  }

  export type CompanyCreateWithoutShareTransactionsInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutShareTransactionsInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutShareTransactionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutShareTransactionsInput, CompanyUncheckedCreateWithoutShareTransactionsInput>
  }

  export type ShareClassCreateWithoutTransactionsInput = {
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutShareClassesInput
  }

  export type ShareClassUncheckedCreateWithoutTransactionsInput = {
    id?: number
    companyId: number
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareClassCreateOrConnectWithoutTransactionsInput = {
    where: ShareClassWhereUniqueInput
    create: XOR<ShareClassCreateWithoutTransactionsInput, ShareClassUncheckedCreateWithoutTransactionsInput>
  }

  export type ShareholderCreateWithoutShareTransactionsInput = {
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShareholdersInput
    companies?: CompanyShareholderCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderUncheckedCreateWithoutShareTransactionsInput = {
    id?: number
    userId: number
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: CompanyShareholderUncheckedCreateNestedManyWithoutShareholderInput
  }

  export type ShareholderCreateOrConnectWithoutShareTransactionsInput = {
    where: ShareholderWhereUniqueInput
    create: XOR<ShareholderCreateWithoutShareTransactionsInput, ShareholderUncheckedCreateWithoutShareTransactionsInput>
  }

  export type CompanyUpsertWithoutShareTransactionsInput = {
    update: XOR<CompanyUpdateWithoutShareTransactionsInput, CompanyUncheckedUpdateWithoutShareTransactionsInput>
    create: XOR<CompanyCreateWithoutShareTransactionsInput, CompanyUncheckedCreateWithoutShareTransactionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutShareTransactionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutShareTransactionsInput, CompanyUncheckedUpdateWithoutShareTransactionsInput>
  }

  export type CompanyUpdateWithoutShareTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutShareTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ShareClassUpsertWithoutTransactionsInput = {
    update: XOR<ShareClassUpdateWithoutTransactionsInput, ShareClassUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ShareClassCreateWithoutTransactionsInput, ShareClassUncheckedCreateWithoutTransactionsInput>
    where?: ShareClassWhereInput
  }

  export type ShareClassUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ShareClassWhereInput
    data: XOR<ShareClassUpdateWithoutTransactionsInput, ShareClassUncheckedUpdateWithoutTransactionsInput>
  }

  export type ShareClassUpdateWithoutTransactionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareClassesNestedInput
  }

  export type ShareClassUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUpsertWithoutShareTransactionsInput = {
    update: XOR<ShareholderUpdateWithoutShareTransactionsInput, ShareholderUncheckedUpdateWithoutShareTransactionsInput>
    create: XOR<ShareholderCreateWithoutShareTransactionsInput, ShareholderUncheckedCreateWithoutShareTransactionsInput>
    where?: ShareholderWhereInput
  }

  export type ShareholderUpdateToOneWithWhereWithoutShareTransactionsInput = {
    where?: ShareholderWhereInput
    data: XOR<ShareholderUpdateWithoutShareTransactionsInput, ShareholderUncheckedUpdateWithoutShareTransactionsInput>
  }

  export type ShareholderUpdateWithoutShareTransactionsInput = {
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShareholdersNestedInput
    companies?: CompanyShareholderUpdateManyWithoutShareholderNestedInput
  }

  export type ShareholderUncheckedUpdateWithoutShareTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyShareholderUncheckedUpdateManyWithoutShareholderNestedInput
  }

  export type CompanyCreateWithoutStatementsInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutStatementsInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutStatementsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutStatementsInput, CompanyUncheckedCreateWithoutStatementsInput>
  }

  export type CorporateStatementLineCreateWithoutStatementInput = {
    category: string
    label: string
    amount: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementLineUncheckedCreateWithoutStatementInput = {
    id?: number
    category: string
    label: string
    amount: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementLineCreateOrConnectWithoutStatementInput = {
    where: CorporateStatementLineWhereUniqueInput
    create: XOR<CorporateStatementLineCreateWithoutStatementInput, CorporateStatementLineUncheckedCreateWithoutStatementInput>
  }

  export type CorporateStatementLineCreateManyStatementInputEnvelope = {
    data: CorporateStatementLineCreateManyStatementInput | CorporateStatementLineCreateManyStatementInput[]
  }

  export type CompanyUpsertWithoutStatementsInput = {
    update: XOR<CompanyUpdateWithoutStatementsInput, CompanyUncheckedUpdateWithoutStatementsInput>
    create: XOR<CompanyCreateWithoutStatementsInput, CompanyUncheckedCreateWithoutStatementsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutStatementsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutStatementsInput, CompanyUncheckedUpdateWithoutStatementsInput>
  }

  export type CompanyUpdateWithoutStatementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutStatementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CorporateStatementLineUpsertWithWhereUniqueWithoutStatementInput = {
    where: CorporateStatementLineWhereUniqueInput
    update: XOR<CorporateStatementLineUpdateWithoutStatementInput, CorporateStatementLineUncheckedUpdateWithoutStatementInput>
    create: XOR<CorporateStatementLineCreateWithoutStatementInput, CorporateStatementLineUncheckedCreateWithoutStatementInput>
  }

  export type CorporateStatementLineUpdateWithWhereUniqueWithoutStatementInput = {
    where: CorporateStatementLineWhereUniqueInput
    data: XOR<CorporateStatementLineUpdateWithoutStatementInput, CorporateStatementLineUncheckedUpdateWithoutStatementInput>
  }

  export type CorporateStatementLineUpdateManyWithWhereWithoutStatementInput = {
    where: CorporateStatementLineScalarWhereInput
    data: XOR<CorporateStatementLineUpdateManyMutationInput, CorporateStatementLineUncheckedUpdateManyWithoutStatementInput>
  }

  export type CorporateStatementLineScalarWhereInput = {
    AND?: CorporateStatementLineScalarWhereInput | CorporateStatementLineScalarWhereInput[]
    OR?: CorporateStatementLineScalarWhereInput[]
    NOT?: CorporateStatementLineScalarWhereInput | CorporateStatementLineScalarWhereInput[]
    id?: IntFilter<"CorporateStatementLine"> | number
    statementId?: IntFilter<"CorporateStatementLine"> | number
    category?: StringFilter<"CorporateStatementLine"> | string
    label?: StringFilter<"CorporateStatementLine"> | string
    amount?: DecimalFilter<"CorporateStatementLine"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFilter<"CorporateStatementLine"> | number
    metadata?: StringNullableFilter<"CorporateStatementLine"> | string | null
    createdAt?: DateTimeFilter<"CorporateStatementLine"> | Date | string
    updatedAt?: DateTimeFilter<"CorporateStatementLine"> | Date | string
  }

  export type CorporateStatementCreateWithoutLinesInput = {
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutStatementsInput
  }

  export type CorporateStatementUncheckedCreateWithoutLinesInput = {
    id?: number
    companyId: number
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementCreateOrConnectWithoutLinesInput = {
    where: CorporateStatementWhereUniqueInput
    create: XOR<CorporateStatementCreateWithoutLinesInput, CorporateStatementUncheckedCreateWithoutLinesInput>
  }

  export type CorporateStatementUpsertWithoutLinesInput = {
    update: XOR<CorporateStatementUpdateWithoutLinesInput, CorporateStatementUncheckedUpdateWithoutLinesInput>
    create: XOR<CorporateStatementCreateWithoutLinesInput, CorporateStatementUncheckedCreateWithoutLinesInput>
    where?: CorporateStatementWhereInput
  }

  export type CorporateStatementUpdateToOneWithWhereWithoutLinesInput = {
    where?: CorporateStatementWhereInput
    data: XOR<CorporateStatementUpdateWithoutLinesInput, CorporateStatementUncheckedUpdateWithoutLinesInput>
  }

  export type CorporateStatementUpdateWithoutLinesInput = {
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutStatementsNestedInput
  }

  export type CorporateStatementUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutResolutionsInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutResolutionsInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutResolutionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutResolutionsInput, CompanyUncheckedCreateWithoutResolutionsInput>
  }

  export type CompanyUpsertWithoutResolutionsInput = {
    update: XOR<CompanyUpdateWithoutResolutionsInput, CompanyUncheckedUpdateWithoutResolutionsInput>
    create: XOR<CompanyCreateWithoutResolutionsInput, CompanyUncheckedCreateWithoutResolutionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutResolutionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutResolutionsInput, CompanyUncheckedUpdateWithoutResolutionsInput>
  }

  export type CompanyUpdateWithoutResolutionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutResolutionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PropertyCreateWithoutUnitsInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUnitsInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUnitsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
  }

  export type PropertyUpsertWithoutUnitsInput = {
    update: XOR<PropertyUpdateWithoutUnitsInput, PropertyUncheckedUpdateWithoutUnitsInput>
    create: XOR<PropertyCreateWithoutUnitsInput, PropertyUncheckedCreateWithoutUnitsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutUnitsInput, PropertyUncheckedUpdateWithoutUnitsInput>
  }

  export type PropertyUpdateWithoutUnitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutMortgagesInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutMortgagesInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutMortgagesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutMortgagesInput, PropertyUncheckedCreateWithoutMortgagesInput>
  }

  export type AttachmentCreateWithoutMortgageInput = {
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutMortgageInput = {
    id?: number
    propertyId: number
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutMortgageInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutMortgageInput, AttachmentUncheckedCreateWithoutMortgageInput>
  }

  export type AttachmentCreateManyMortgageInputEnvelope = {
    data: AttachmentCreateManyMortgageInput | AttachmentCreateManyMortgageInput[]
  }

  export type PropertyUpsertWithoutMortgagesInput = {
    update: XOR<PropertyUpdateWithoutMortgagesInput, PropertyUncheckedUpdateWithoutMortgagesInput>
    create: XOR<PropertyCreateWithoutMortgagesInput, PropertyUncheckedCreateWithoutMortgagesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutMortgagesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutMortgagesInput, PropertyUncheckedUpdateWithoutMortgagesInput>
  }

  export type PropertyUpdateWithoutMortgagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutMortgagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutMortgageInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutMortgageInput, AttachmentUncheckedUpdateWithoutMortgageInput>
    create: XOR<AttachmentCreateWithoutMortgageInput, AttachmentUncheckedCreateWithoutMortgageInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutMortgageInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutMortgageInput, AttachmentUncheckedUpdateWithoutMortgageInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutMortgageInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutMortgageInput>
  }

  export type PropertyCreateWithoutRevenuesInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutRevenuesInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutRevenuesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutRevenuesInput, PropertyUncheckedCreateWithoutRevenuesInput>
  }

  export type PropertyUpsertWithoutRevenuesInput = {
    update: XOR<PropertyUpdateWithoutRevenuesInput, PropertyUncheckedUpdateWithoutRevenuesInput>
    create: XOR<PropertyCreateWithoutRevenuesInput, PropertyUncheckedCreateWithoutRevenuesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutRevenuesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutRevenuesInput, PropertyUncheckedUpdateWithoutRevenuesInput>
  }

  export type PropertyUpdateWithoutRevenuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutRevenuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutExpensesInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutExpensesInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutExpensesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutExpensesInput, PropertyUncheckedCreateWithoutExpensesInput>
  }

  export type PropertyUpsertWithoutExpensesInput = {
    update: XOR<PropertyUpdateWithoutExpensesInput, PropertyUncheckedUpdateWithoutExpensesInput>
    create: XOR<PropertyCreateWithoutExpensesInput, PropertyUncheckedCreateWithoutExpensesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutExpensesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutExpensesInput, PropertyUncheckedUpdateWithoutExpensesInput>
  }

  export type PropertyUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutInvoicesInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutInvoicesInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutInvoicesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutInvoicesInput, PropertyUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    label: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
  }

  export type PropertyUpsertWithoutInvoicesInput = {
    update: XOR<PropertyUpdateWithoutInvoicesInput, PropertyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PropertyCreateWithoutInvoicesInput, PropertyUncheckedCreateWithoutInvoicesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutInvoicesInput, PropertyUncheckedUpdateWithoutInvoicesInput>
  }

  export type PropertyUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    label?: StringFilter<"InvoiceItem"> | string
    amount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceCreateWithoutItemsInput = {
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    propertyId: number
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateWithoutDepreciationInfoInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    attachments?: AttachmentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutDepreciationInfoInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutDepreciationInfoInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutDepreciationInfoInput, PropertyUncheckedCreateWithoutDepreciationInfoInput>
  }

  export type PropertyUpsertWithoutDepreciationInfoInput = {
    update: XOR<PropertyUpdateWithoutDepreciationInfoInput, PropertyUncheckedUpdateWithoutDepreciationInfoInput>
    create: XOR<PropertyCreateWithoutDepreciationInfoInput, PropertyUncheckedCreateWithoutDepreciationInfoInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutDepreciationInfoInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutDepreciationInfoInput, PropertyUncheckedUpdateWithoutDepreciationInfoInput>
  }

  export type PropertyUpdateWithoutDepreciationInfoInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutDepreciationInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
    company?: CompanyCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    companyId?: number | null
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutRolesInput = {
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutUserInput
    companies?: CompanyCreateNestedManyWithoutUserInput
    shareholders?: ShareholderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    companies?: CompanyUncheckedCreateNestedManyWithoutUserInput
    shareholders?: ShareholderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type CompanyCreateWithoutUserRolesInput = {
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCompaniesInput
    properties?: PropertyCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserRolesInput = {
    id?: number
    userId: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutCompanyInput
    shareholderLinks?: CompanyShareholderUncheckedCreateNestedManyWithoutCompanyInput
    shareClasses?: ShareClassUncheckedCreateNestedManyWithoutCompanyInput
    shareTransactions?: ShareTransactionUncheckedCreateNestedManyWithoutCompanyInput
    statements?: CorporateStatementUncheckedCreateNestedManyWithoutCompanyInput
    resolutions?: CorporateResolutionUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserRolesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutUserNestedInput
    companies?: CompanyUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    companies?: CompanyUncheckedUpdateManyWithoutUserNestedInput
    shareholders?: ShareholderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUpsertWithoutUserRolesInput = {
    update: XOR<CompanyUpdateWithoutUserRolesInput, CompanyUncheckedUpdateWithoutUserRolesInput>
    create: XOR<CompanyCreateWithoutUserRolesInput, CompanyUncheckedCreateWithoutUserRolesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUserRolesInput, CompanyUncheckedUpdateWithoutUserRolesInput>
  }

  export type CompanyUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PropertyCreateWithoutAttachmentsInput = {
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
    company?: CompanyCreateNestedOneWithoutPropertiesInput
    units?: PropertyUnitCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageCreateNestedManyWithoutPropertyInput
    revenues?: RevenueCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    userId: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: PropertyUnitUncheckedCreateNestedManyWithoutPropertyInput
    mortgages?: MortgageUncheckedCreateNestedManyWithoutPropertyInput
    revenues?: RevenueUncheckedCreateNestedManyWithoutPropertyInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutPropertyInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPropertyInput
    depreciationInfo?: DepreciationSettingUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAttachmentsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAttachmentsInput, PropertyUncheckedCreateWithoutAttachmentsInput>
  }

  export type MortgageCreateWithoutAttachmentsInput = {
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutMortgagesInput
  }

  export type MortgageUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    propertyId: number
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MortgageCreateOrConnectWithoutAttachmentsInput = {
    where: MortgageWhereUniqueInput
    create: XOR<MortgageCreateWithoutAttachmentsInput, MortgageUncheckedCreateWithoutAttachmentsInput>
  }

  export type PropertyUpsertWithoutAttachmentsInput = {
    update: XOR<PropertyUpdateWithoutAttachmentsInput, PropertyUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<PropertyCreateWithoutAttachmentsInput, PropertyUncheckedCreateWithoutAttachmentsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutAttachmentsInput, PropertyUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PropertyUpdateWithoutAttachmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type MortgageUpsertWithoutAttachmentsInput = {
    update: XOR<MortgageUpdateWithoutAttachmentsInput, MortgageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MortgageCreateWithoutAttachmentsInput, MortgageUncheckedCreateWithoutAttachmentsInput>
    where?: MortgageWhereInput
  }

  export type MortgageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MortgageWhereInput
    data: XOR<MortgageUpdateWithoutAttachmentsInput, MortgageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MortgageUpdateWithoutAttachmentsInput = {
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutMortgagesNestedInput
  }

  export type MortgageUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyUserInput = {
    id?: number
    companyId?: number | null
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyCreateManyUserInput = {
    id?: number
    name: string
    neq?: string | null
    fiscalYearEnd?: Date | string | null
    province?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareholderCreateManyUserInput = {
    id?: number
    type?: string
    displayName: string
    contactEmail?: string | null
    contactPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: number
    roleId: number
    companyId?: number | null
  }

  export type PropertyUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutCompanyNestedInput
    shareholderLinks?: CompanyShareholderUncheckedUpdateManyWithoutCompanyNestedInput
    shareClasses?: ShareClassUncheckedUpdateManyWithoutCompanyNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutCompanyNestedInput
    statements?: CorporateStatementUncheckedUpdateManyWithoutCompanyNestedInput
    resolutions?: CorporateResolutionUncheckedUpdateManyWithoutCompanyNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    neq?: NullableStringFieldUpdateOperationsInput | string | null
    fiscalYearEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareholderUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyShareholderUpdateManyWithoutShareholderNestedInput
    shareTransactions?: ShareTransactionUpdateManyWithoutShareholderNestedInput
  }

  export type ShareholderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: CompanyShareholderUncheckedUpdateManyWithoutShareholderNestedInput
    shareTransactions?: ShareTransactionUncheckedUpdateManyWithoutShareholderNestedInput
  }

  export type ShareholderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    company?: CompanyUpdateOneWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropertyUnitCreateManyPropertyInput = {
    id?: number
    label: string
    squareFeet?: number | null
    rentExpected?: Decimal | DecimalJsLike | number | string | null
  }

  export type MortgageCreateManyPropertyInput = {
    id?: number
    lender: string
    principal: Decimal | DecimalJsLike | number | string
    rateAnnual: Decimal | DecimalJsLike | number | string
    termMonths: number
    amortizationMonths: number
    startDate: Date | string
    paymentFrequency: number
    paymentAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueCreateManyPropertyInput = {
    id?: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateManyPropertyInput = {
    id?: number
    label: string
    category: string
    amount: Decimal | DecimalJsLike | number | string
    frequency?: string
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPropertyInput = {
    id?: number
    invoiceDate: Date | string
    supplier: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    gst?: Decimal | DecimalJsLike | number | string | null
    qst?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyPropertyInput = {
    id?: number
    mortgageId?: number | null
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUnitUpdateWithoutPropertyInput = {
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PropertyUnitUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    squareFeet?: NullableIntFieldUpdateOperationsInput | number | null
    rentExpected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type MortgageUpdateWithoutPropertyInput = {
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutMortgageNestedInput
  }

  export type MortgageUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutMortgageNestedInput
  }

  export type MortgageUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lender?: StringFieldUpdateOperationsInput | string
    principal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rateAnnual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    termMonths?: IntFieldUpdateOperationsInput | number
    amortizationMonths?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: IntFieldUpdateOperationsInput | number
    paymentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueUpdateWithoutPropertyInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUpdateWithoutPropertyInput = {
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    frequency?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPropertyInput = {
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    gst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    qst?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutPropertyInput = {
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mortgage?: MortgageUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mortgageId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutPropertyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mortgageId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyCompanyInput = {
    id?: number
    userId: number
    name: string
    address?: string | null
    acquisitionDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyShareholderCreateManyCompanyInput = {
    id?: number
    shareholderId: number
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareClassCreateManyCompanyInput = {
    id?: number
    code: string
    description?: string | null
    hasVotingRights?: boolean
    participatesInGrowth?: boolean
    dividendPolicy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionCreateManyCompanyInput = {
    id?: number
    shareClassId: number
    shareholderId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementCreateManyCompanyInput = {
    id?: number
    statementType: string
    periodStart: Date | string
    periodEnd: Date | string
    isAudited?: boolean
    totalAssets?: Decimal | DecimalJsLike | number | string
    totalLiabilities?: Decimal | DecimalJsLike | number | string
    totalEquity?: Decimal | DecimalJsLike | number | string
    totalRevenue?: Decimal | DecimalJsLike | number | string
    totalExpenses?: Decimal | DecimalJsLike | number | string
    netIncome?: Decimal | DecimalJsLike | number | string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateResolutionCreateManyCompanyInput = {
    id?: number
    type: string
    title: string
    resolutionDate: Date | string
    body?: string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleCreateManyCompanyInput = {
    id?: number
    userId: number
    roleId: number
  }

  export type PropertyUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    units?: PropertyUnitUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: PropertyUnitUncheckedUpdateManyWithoutPropertyNestedInput
    mortgages?: MortgageUncheckedUpdateManyWithoutPropertyNestedInput
    revenues?: RevenueUncheckedUpdateManyWithoutPropertyNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutPropertyNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPropertyNestedInput
    depreciationInfo?: DepreciationSettingUncheckedUpdateOneWithoutPropertyNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyShareholderUpdateWithoutCompanyInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareholder?: ShareholderUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type CompanyShareholderUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyShareholderUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareClassUpdateWithoutCompanyInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: ShareTransactionUpdateManyWithoutShareClassNestedInput
  }

  export type ShareClassUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: ShareTransactionUncheckedUpdateManyWithoutShareClassNestedInput
  }

  export type ShareClassUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hasVotingRights?: BoolFieldUpdateOperationsInput | boolean
    participatesInGrowth?: BoolFieldUpdateOperationsInput | boolean
    dividendPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionUpdateWithoutCompanyInput = {
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shareClass?: ShareClassUpdateOneRequiredWithoutTransactionsNestedInput
    shareholder?: ShareholderUpdateOneRequiredWithoutShareTransactionsNestedInput
  }

  export type ShareTransactionUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareClassId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shareClassId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementUpdateWithoutCompanyInput = {
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CorporateStatementLineUpdateManyWithoutStatementNestedInput
  }

  export type CorporateStatementUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: CorporateStatementLineUncheckedUpdateManyWithoutStatementNestedInput
  }

  export type CorporateStatementUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statementType?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isAudited?: BoolFieldUpdateOperationsInput | boolean
    totalAssets?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalLiabilities?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalEquity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalExpenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netIncome?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateResolutionUpdateWithoutCompanyInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateResolutionUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateResolutionUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    resolutionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutCompanyInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyShareholderCreateManyShareholderInput = {
    id?: number
    companyId: number
    role?: string | null
    votingPercent?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionCreateManyShareholderInput = {
    id?: number
    companyId: number
    shareClassId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyShareholderUpdateWithoutShareholderInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareholderLinksNestedInput
  }

  export type CompanyShareholderUncheckedUpdateWithoutShareholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyShareholderUncheckedUpdateManyWithoutShareholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    votingPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionUpdateWithoutShareholderInput = {
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareTransactionsNestedInput
    shareClass?: ShareClassUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type ShareTransactionUncheckedUpdateWithoutShareholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareClassId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionUncheckedUpdateManyWithoutShareholderInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareClassId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionCreateManyShareClassInput = {
    id?: number
    companyId: number
    shareholderId: number
    type: string
    transactionDate: Date | string
    quantity: Decimal | DecimalJsLike | number | string
    pricePerShare?: Decimal | DecimalJsLike | number | string | null
    considerationPaid?: Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShareTransactionUpdateWithoutShareClassInput = {
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutShareTransactionsNestedInput
    shareholder?: ShareholderUpdateOneRequiredWithoutShareTransactionsNestedInput
  }

  export type ShareTransactionUncheckedUpdateWithoutShareClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareTransactionUncheckedUpdateManyWithoutShareClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    shareholderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerShare?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    considerationPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fairMarketValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementLineCreateManyStatementInput = {
    id?: number
    category: string
    label: string
    amount: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorporateStatementLineUpdateWithoutStatementInput = {
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementLineUncheckedUpdateWithoutStatementInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorporateStatementLineUncheckedUpdateManyWithoutStatementInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyMortgageInput = {
    id?: number
    propertyId: number
    title: string
    filename: string
    contentType: string
    size: number
    storagePath: string
    checksum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateWithoutMortgageInput = {
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutMortgageInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutMortgageInput = {
    id?: IntFieldUpdateOperationsInput | number
    propertyId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: number
    label: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: number
    userId: number
    companyId?: number | null
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    company?: CompanyUpdateOneWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyCountOutputTypeDefaultArgs instead
     */
    export type PropertyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShareholderCountOutputTypeDefaultArgs instead
     */
    export type ShareholderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShareholderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShareClassCountOutputTypeDefaultArgs instead
     */
    export type ShareClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShareClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CorporateStatementCountOutputTypeDefaultArgs instead
     */
    export type CorporateStatementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CorporateStatementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MortgageCountOutputTypeDefaultArgs instead
     */
    export type MortgageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MortgageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyDefaultArgs instead
     */
    export type PropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShareholderDefaultArgs instead
     */
    export type ShareholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShareholderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyShareholderDefaultArgs instead
     */
    export type CompanyShareholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyShareholderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShareClassDefaultArgs instead
     */
    export type ShareClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShareClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShareTransactionDefaultArgs instead
     */
    export type ShareTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShareTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CorporateStatementDefaultArgs instead
     */
    export type CorporateStatementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CorporateStatementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CorporateStatementLineDefaultArgs instead
     */
    export type CorporateStatementLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CorporateStatementLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CorporateResolutionDefaultArgs instead
     */
    export type CorporateResolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CorporateResolutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertyUnitDefaultArgs instead
     */
    export type PropertyUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertyUnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MortgageDefaultArgs instead
     */
    export type MortgageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MortgageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevenueDefaultArgs instead
     */
    export type RevenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevenueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepreciationSettingDefaultArgs instead
     */
    export type DepreciationSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepreciationSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}